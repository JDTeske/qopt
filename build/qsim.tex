%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax

\PassOptionsToPackage{warn}{textcomp}
\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
% support both utf8 and utf8x syntaxes
  \ifdefined\DeclareUnicodeCharacterAsOptional
    \def\sphinxDUC#1{\DeclareUnicodeCharacter{"#1}}
  \else
    \let\sphinxDUC\DeclareUnicodeCharacter
  \fi
  \sphinxDUC{00A0}{\nobreakspace}
  \sphinxDUC{2500}{\sphinxunichar{2500}}
  \sphinxDUC{2502}{\sphinxunichar{2502}}
  \sphinxDUC{2514}{\sphinxunichar{2514}}
  \sphinxDUC{251C}{\sphinxunichar{251C}}
  \sphinxDUC{2572}{\textbackslash}
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}



\usepackage{times}
\expandafter\ifx\csname T@LGR\endcsname\relax
\else
% LGR was declared as font encoding
  \substitutefont{LGR}{\rmdefault}{cmr}
  \substitutefont{LGR}{\sfdefault}{cmss}
  \substitutefont{LGR}{\ttdefault}{cmtt}
\fi
\expandafter\ifx\csname T@X2\endcsname\relax
  \expandafter\ifx\csname T@T2A\endcsname\relax
  \else
  % T2A was declared as font encoding
    \substitutefont{T2A}{\rmdefault}{cmr}
    \substitutefont{T2A}{\sfdefault}{cmss}
    \substitutefont{T2A}{\ttdefault}{cmtt}
  \fi
\else
% X2 was declared as font encoding
  \substitutefont{X2}{\rmdefault}{cmr}
  \substitutefont{X2}{\sfdefault}{cmss}
  \substitutefont{X2}{\ttdefault}{cmtt}
\fi


\usepackage[Bjarne]{fncychap}
\usepackage{sphinx}

\fvset{fontsize=\small}
\usepackage{geometry}


% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}
\addto\captionsenglish{\renewcommand{\contentsname}{Contents:}}

\usepackage{sphinxmessages}
\setcounter{tocdepth}{1}


% Jupyter Notebook code cell colors
\definecolor{nbsphinxin}{HTML}{307FC1}
\definecolor{nbsphinxout}{HTML}{BF5B3D}
\definecolor{nbsphinx-code-bg}{HTML}{F5F5F5}
\definecolor{nbsphinx-code-border}{HTML}{E0E0E0}
\definecolor{nbsphinx-stderr}{HTML}{FFDDDD}
% ANSI colors for output streams and traceback highlighting
\definecolor{ansi-black}{HTML}{3E424D}
\definecolor{ansi-black-intense}{HTML}{282C36}
\definecolor{ansi-red}{HTML}{E75C58}
\definecolor{ansi-red-intense}{HTML}{B22B31}
\definecolor{ansi-green}{HTML}{00A250}
\definecolor{ansi-green-intense}{HTML}{007427}
\definecolor{ansi-yellow}{HTML}{DDB62B}
\definecolor{ansi-yellow-intense}{HTML}{B27D12}
\definecolor{ansi-blue}{HTML}{208FFB}
\definecolor{ansi-blue-intense}{HTML}{0065CA}
\definecolor{ansi-magenta}{HTML}{D160C4}
\definecolor{ansi-magenta-intense}{HTML}{A03196}
\definecolor{ansi-cyan}{HTML}{60C6C8}
\definecolor{ansi-cyan-intense}{HTML}{258F8F}
\definecolor{ansi-white}{HTML}{C5C1B4}
\definecolor{ansi-white-intense}{HTML}{A1A6B2}
\definecolor{ansi-default-inverse-fg}{HTML}{FFFFFF}
\definecolor{ansi-default-inverse-bg}{HTML}{000000}

% Define an environment for non-plain-text code cell outputs (e.g. images)
\makeatletter
\newenvironment{nbsphinxfancyoutput}{%
    % Avoid fatal error with framed.sty if graphics too long to fit on one page
    \let\sphinxincludegraphics\nbsphinxincludegraphics
    \nbsphinx@image@maxheight\textheight
    \advance\nbsphinx@image@maxheight -2\fboxsep   % default \fboxsep 3pt
    \advance\nbsphinx@image@maxheight -2\fboxrule  % default \fboxrule 0.4pt
    \advance\nbsphinx@image@maxheight -\baselineskip
\def\nbsphinxfcolorbox{\spx@fcolorbox{nbsphinx-code-border}{white}}%
\def\FrameCommand{\nbsphinxfcolorbox\nbsphinxfancyaddprompt\@empty}%
\def\FirstFrameCommand{\nbsphinxfcolorbox\nbsphinxfancyaddprompt\sphinxVerbatim@Continues}%
\def\MidFrameCommand{\nbsphinxfcolorbox\sphinxVerbatim@Continued\sphinxVerbatim@Continues}%
\def\LastFrameCommand{\nbsphinxfcolorbox\sphinxVerbatim@Continued\@empty}%
\MakeFramed{\advance\hsize-\width\@totalleftmargin\z@\linewidth\hsize\@setminipage}%
\lineskip=1ex\lineskiplimit=1ex\raggedright%
}{\par\unskip\@minipagefalse\endMakeFramed}
\makeatother
\newbox\nbsphinxpromptbox
\def\nbsphinxfancyaddprompt{\ifvoid\nbsphinxpromptbox\else
    \kern\fboxrule\kern\fboxsep
    \copy\nbsphinxpromptbox
    \kern-\ht\nbsphinxpromptbox\kern-\dp\nbsphinxpromptbox
    \kern-\fboxsep\kern-\fboxrule\nointerlineskip
    \fi}
\newlength\nbsphinxcodecellspacing
\setlength{\nbsphinxcodecellspacing}{0pt}

% Define support macros for attaching opening and closing lines to notebooks
\newsavebox\nbsphinxbox
\makeatletter
\newcommand{\nbsphinxstartnotebook}[1]{%
    \par
    % measure needed space
    \setbox\nbsphinxbox\vtop{{#1\par}}
    % reserve some space at bottom of page, else start new page
    \needspace{\dimexpr2.5\baselineskip+\ht\nbsphinxbox+\dp\nbsphinxbox}
    % mimick vertical spacing from \section command
      \addpenalty\@secpenalty
      \@tempskipa 3.5ex \@plus 1ex \@minus .2ex\relax
      \addvspace\@tempskipa
      {\Large\@tempskipa\baselineskip
             \advance\@tempskipa-\prevdepth
             \advance\@tempskipa-\ht\nbsphinxbox
             \ifdim\@tempskipa>\z@
               \vskip \@tempskipa
             \fi}
    \unvbox\nbsphinxbox
    % if notebook starts with a \section, prevent it from adding extra space
    \@nobreaktrue\everypar{\@nobreakfalse\everypar{}}%
    % compensate the parskip which will get inserted by next paragraph
    \nobreak\vskip-\parskip
    % do not break here
    \nobreak
}% end of \nbsphinxstartnotebook

\newcommand{\nbsphinxstopnotebook}[1]{%
    \par
    % measure needed space
    \setbox\nbsphinxbox\vbox{{#1\par}}
    \nobreak % it updates page totals
    \dimen@\pagegoal
    \advance\dimen@-\pagetotal \advance\dimen@-\pagedepth
    \advance\dimen@-\ht\nbsphinxbox \advance\dimen@-\dp\nbsphinxbox
    \ifdim\dimen@<\z@
      % little space left
      \unvbox\nbsphinxbox
      \kern-.8\baselineskip
      \nobreak\vskip\z@\@plus1fil
      \penalty100
      \vskip\z@\@plus-1fil
      \kern.8\baselineskip
    \else
      \unvbox\nbsphinxbox
    \fi
}% end of \nbsphinxstopnotebook

% Ensure height of an included graphics fits in nbsphinxfancyoutput frame
\newdimen\nbsphinx@image@maxheight % set in nbsphinxfancyoutput environment
\newcommand*{\nbsphinxincludegraphics}[2][]{%
    \gdef\spx@includegraphics@options{#1}%
    \setbox\spx@image@box\hbox{\includegraphics[#1,draft]{#2}}%
    \in@false
    \ifdim \wd\spx@image@box>\linewidth
      \g@addto@macro\spx@includegraphics@options{,width=\linewidth}%
      \in@true
    \fi
    % no rotation, no need to worry about depth
    \ifdim \ht\spx@image@box>\nbsphinx@image@maxheight
      \g@addto@macro\spx@includegraphics@options{,height=\nbsphinx@image@maxheight}%
      \in@true
    \fi
    \ifin@
      \g@addto@macro\spx@includegraphics@options{,keepaspectratio}%
    \fi
    \setbox\spx@image@box\box\voidb@x % clear memory
    \expandafter\includegraphics\expandafter[\spx@includegraphics@options]{#2}%
}% end of "\MakeFrame"-safe variant of \sphinxincludegraphics
\makeatother

\makeatletter
\renewcommand*\sphinx@verbatim@nolig@list{\do\'\do\`}
\begingroup
\catcode`'=\active
\let\nbsphinx@noligs\@noligs
\g@addto@macro\nbsphinx@noligs{\let'\PYGZsq}
\endgroup
\makeatother
\renewcommand*\sphinxbreaksbeforeactivelist{\do\<\do\"\do\'}
\renewcommand*\sphinxbreaksafteractivelist{\do\.\do\,\do\:\do\;\do\?\do\!\do\/\do\>\do\-}
\makeatletter
\fvset{codes*=\sphinxbreaksattexescapedchars\do\^\^\let\@noligs\nbsphinx@noligs}
\makeatother



\title{qsim}
\date{May 26, 2020}
\release{0.1}
\author{Julian Teske}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{Release}
\makeindex
\begin{document}

\pagestyle{empty}
\sphinxmaketitle
\pagestyle{plain}
\sphinxtableofcontents
\pagestyle{normal}
\phantomsection\label{\detokenize{index::doc}}


Welcome to Qsim.


\chapter{Documentation}
\label{\detokenize{index:documentation}}

\section{Examples}
\label{\detokenize{examples/examples:examples}}\label{\detokenize{examples/examples:id1}}\label{\detokenize{examples/examples::doc}}
This directory contains static examples that can also be run interactively
from \sphinxstyleemphasis{Doc/source/examples} using \sphinxtitleref{jupyter notebook}.
There are more examples as Python scripts in the top level folder \sphinxstyleemphasis{examples}.


\subsection{Introduction}
\label{\detokenize{examples/schroedinger_solver:Introduction}}\label{\detokenize{examples/schroedinger_solver::doc}}

\subsubsection{Solver}
\label{\detokenize{examples/schroedinger_solver:Solver}}
Quantum mechanical systems can be described by differential equations. In this notebook we will solve Schroedinger’s equation, which describes the time evolution of a quantum mechanical state by multiplication with the Hamilton operator:

\begin{equation}
i \hbar \partial_t \psi = H \psi
\end{equation}

Thus we can describe a system’s evolution by its Hamilton operator. For systems of small dimension it is more performant to store operators in a dense format.

We split the Hamilton operator in a drift and a control part

\begin{align*}
H = H_d + H_c,
\end{align*}

where the latter can be written as sum weighted by control amplitudes

\begin{align*}
H_c = \sum_n u_n H_n.
\end{align*}

Lets consider a qubit under Rabi driving expressed as XY\sphinxhyphen{}control with the Hamilton operator

\begin{align*}
H = \hbar \delta_\omega \sigma_z / 2 + \hbar A_x \sigma_x / 2
+ \hbar A_y \sigma_y / 2
\end{align*}

where \(\delta_\omega\) is the frequency detuning and \(A\) the driving amplitude. Lets set \(\hbar = 1\) for simplicity, then we can split the Hamilton operator:

\begin{align*}
H_c &= A_x \sigma_x / 2 + A_y \sigma_y / 2 \\
H_d &= \delta_\omega \sigma_z / 2
\end{align*}

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[5]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}

\PYG{k+kn}{from} \PYG{n+nn}{qsim}\PYG{n+nn}{.}\PYG{n+nn}{matrix} \PYG{k+kn}{import} \PYG{n}{DenseOperator}

\PYG{n}{sigma\PYGZus{}x} \PYG{o}{=} \PYG{n}{DenseOperator}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{asarray}\PYG{p}{(}\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{sigma\PYGZus{}y} \PYG{o}{=} \PYG{n}{DenseOperator}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{asarray}\PYG{p}{(}\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{n}{j}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{n}{j}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{sigma\PYGZus{}z} \PYG{o}{=} \PYG{n}{DenseOperator}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{asarray}\PYG{p}{(}\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{zero\PYGZus{}matrix} \PYG{o}{=} \PYG{n}{DenseOperator}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{asarray}\PYG{p}{(}\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}

\PYG{n}{delta\PYGZus{}omega} \PYG{o}{=} \PYG{l+m+mi}{0}

\PYG{n}{h\PYGZus{}ctrl} \PYG{o}{=} \PYG{p}{[}\PYG{o}{.}\PYG{l+m+mi}{5} \PYG{o}{*} \PYG{n}{sigma\PYGZus{}x}\PYG{p}{,} \PYG{o}{.}\PYG{l+m+mi}{5} \PYG{o}{*} \PYG{n}{sigma\PYGZus{}y}\PYG{p}{]}
\PYG{n}{h\PYGZus{}drift} \PYG{o}{=} \PYG{p}{[}\PYG{n}{delta\PYGZus{}omega} \PYG{o}{*} \PYG{o}{.}\PYG{l+m+mi}{5} \PYG{o}{*} \PYG{n}{sigma\PYGZus{}z}\PYG{p}{]}
\end{sphinxVerbatim}
}

For computational feasibility, we make the assumption of piece wise constant control.

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[6]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYG{n}{n\PYGZus{}time\PYGZus{}steps} \PYG{o}{=} \PYG{l+m+mi}{5}
\PYG{n}{total\PYGZus{}time} \PYG{o}{=} \PYG{l+m+mi}{1}

\PYG{n}{time\PYGZus{}steps} \PYG{o}{=} \PYG{p}{(}\PYG{n}{total\PYGZus{}time} \PYG{o}{/} \PYG{n}{n\PYGZus{}time\PYGZus{}steps}\PYG{p}{)} \PYG{o}{*} \PYG{n}{np}\PYG{o}{.}\PYG{n}{ones}\PYG{p}{(}\PYG{p}{(}\PYG{n}{n\PYGZus{}time\PYGZus{}steps}\PYG{p}{,} \PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}
}

And set the control amplitudes to values resulting in an \(X_\pi\)\sphinxhyphen{}Rotation.

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[7]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYG{n}{control\PYGZus{}amplitudes} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{zeros}\PYG{p}{(}\PYG{p}{(}\PYG{n}{n\PYGZus{}time\PYGZus{}steps}\PYG{p}{,} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{h\PYGZus{}ctrl}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{control\PYGZus{}amplitudes}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{pi}
\end{sphinxVerbatim}
}

Then we initialize a a solver for Schroedinger’s equation, solve the equation and plot the corresponding pulse.

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[8]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYG{k+kn}{from} \PYG{n+nn}{qsim}\PYG{n+nn}{.}\PYG{n+nn}{solver\PYGZus{}algorithms} \PYG{k+kn}{import} \PYG{n}{SchroedingerSolver}

\PYG{n}{solver} \PYG{o}{=} \PYG{n}{SchroedingerSolver}\PYG{p}{(}
    \PYG{n}{h\PYGZus{}drift}\PYG{o}{=}\PYG{n}{h\PYGZus{}drift} \PYG{o}{*} \PYG{n}{n\PYGZus{}time\PYGZus{}steps}\PYG{p}{,}
    \PYG{n}{h\PYGZus{}ctrl}\PYG{o}{=}\PYG{n}{h\PYGZus{}ctrl}\PYG{p}{,}
    \PYG{n}{tau}\PYG{o}{=}\PYG{n}{time\PYGZus{}steps}
\PYG{p}{)}
\PYG{n}{solver}\PYG{o}{.}\PYG{n}{set\PYGZus{}optimization\PYGZus{}parameters}\PYG{p}{(}\PYG{n}{control\PYGZus{}amplitudes}\PYG{p}{)}

\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Total unitary of the evolution: }\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{solver}\PYG{o}{.}\PYG{n}{forward\PYGZus{}propagators}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{.}\PYG{n}{data}\PYG{p}{)}

\PYG{n}{solver}\PYG{o}{.}\PYG{n}{plot\PYGZus{}bloch\PYGZus{}sphere}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}
}

{

\kern-\sphinxverbatimsmallskipamount\kern-\baselineskip
\kern+\FrameHeightAdjust\kern-\fboxrule
\vspace{\nbsphinxcodecellspacing}

\sphinxsetup{VerbatimColor={named}{white}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Total unitary of the evolution:
[[0.0000000e+00+0.j 0.0000000e+00-1.j]
 [0.0000000e+00-1.j 4.4408921e-16+0.j]]
\end{sphinxVerbatim}
}

\hrule height -\fboxrule\relax
\vspace{\nbsphinxcodecellspacing}

\makeatletter\setbox\nbsphinxpromptbox\box\voidb@x\makeatother

\begin{nbsphinxfancyoutput}

\noindent\sphinxincludegraphics[width=374\sphinxpxdimen,height=374\sphinxpxdimen]{{examples_schroedinger_solver_7_1}.png}

\end{nbsphinxfancyoutput}


\subsection{Quantum Fidelity}
\label{\detokenize{examples/entanglement_fidelity:Quantum-Fidelity}}\label{\detokenize{examples/entanglement_fidelity::doc}}
The fidelity \(F\) or the infidelity \(I=1-F\) is a measure of a quantum channels accuracy. Lets have another look at the previous example:

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[1]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}

\PYG{k+kn}{from} \PYG{n+nn}{qsim}\PYG{n+nn}{.}\PYG{n+nn}{matrix} \PYG{k+kn}{import} \PYG{n}{DenseOperator}
\PYG{k+kn}{from} \PYG{n+nn}{qsim}\PYG{n+nn}{.}\PYG{n+nn}{solver\PYGZus{}algorithms} \PYG{k+kn}{import} \PYG{n}{SchroedingerSolver}

\PYG{n}{sigma\PYGZus{}x} \PYG{o}{=} \PYG{n}{DenseOperator}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{asarray}\PYG{p}{(}\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{sigma\PYGZus{}y} \PYG{o}{=} \PYG{n}{DenseOperator}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{asarray}\PYG{p}{(}\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{n}{j}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{n}{j}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{sigma\PYGZus{}z} \PYG{o}{=} \PYG{n}{DenseOperator}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{asarray}\PYG{p}{(}\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{zero\PYGZus{}matrix} \PYG{o}{=} \PYG{n}{DenseOperator}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{asarray}\PYG{p}{(}\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}

\PYG{n}{delta\PYGZus{}omega} \PYG{o}{=} \PYG{l+m+mi}{0}

\PYG{n}{h\PYGZus{}ctrl} \PYG{o}{=} \PYG{p}{[}\PYG{o}{.}\PYG{l+m+mi}{5} \PYG{o}{*} \PYG{n}{sigma\PYGZus{}x}\PYG{p}{,} \PYG{o}{.}\PYG{l+m+mi}{5} \PYG{o}{*} \PYG{n}{sigma\PYGZus{}y}\PYG{p}{]}
\PYG{n}{h\PYGZus{}drift} \PYG{o}{=} \PYG{p}{[}\PYG{n}{delta\PYGZus{}omega} \PYG{o}{*} \PYG{o}{.}\PYG{l+m+mi}{5} \PYG{o}{*} \PYG{n}{sigma\PYGZus{}z}\PYG{p}{]}

\PYG{n}{n\PYGZus{}time\PYGZus{}steps} \PYG{o}{=} \PYG{l+m+mi}{5}
\PYG{n}{total\PYGZus{}time} \PYG{o}{=} \PYG{l+m+mi}{1}

\PYG{n}{time\PYGZus{}steps} \PYG{o}{=} \PYG{p}{(}\PYG{n}{total\PYGZus{}time} \PYG{o}{/} \PYG{n}{n\PYGZus{}time\PYGZus{}steps}\PYG{p}{)} \PYG{o}{*} \PYG{n}{np}\PYG{o}{.}\PYG{n}{ones}\PYG{p}{(}\PYG{p}{(}\PYG{n}{n\PYGZus{}time\PYGZus{}steps}\PYG{p}{,} \PYG{p}{)}\PYG{p}{)}

\PYG{n}{control\PYGZus{}amplitudes} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{zeros}\PYG{p}{(}\PYG{p}{(}\PYG{n}{n\PYGZus{}time\PYGZus{}steps}\PYG{p}{,} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{h\PYGZus{}ctrl}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{control\PYGZus{}amplitudes}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{pi}

\PYG{n}{solver} \PYG{o}{=} \PYG{n}{SchroedingerSolver}\PYG{p}{(}
    \PYG{n}{h\PYGZus{}drift}\PYG{o}{=}\PYG{n}{h\PYGZus{}drift} \PYG{o}{*} \PYG{n}{n\PYGZus{}time\PYGZus{}steps}\PYG{p}{,}
    \PYG{n}{h\PYGZus{}ctrl}\PYG{o}{=}\PYG{n}{h\PYGZus{}ctrl}\PYG{p}{,}
    \PYG{n}{tau}\PYG{o}{=}\PYG{n}{time\PYGZus{}steps}
\PYG{p}{)}
\PYG{n}{solver}\PYG{o}{.}\PYG{n}{set\PYGZus{}optimization\PYGZus{}parameters}\PYG{p}{(}\PYG{n}{control\PYGZus{}amplitudes}\PYG{p}{)}
\end{sphinxVerbatim}
}

Remember that this pulse implements an \(X_\pi\)\sphinxhyphen{}rotation around the x\sphinxhyphen{}axis. We can now set up the entanglement fidelity of this solver with the \(X_\pi\)\sphinxhyphen{}Rotation as target. The entanglement infidelity \(I_e\) between a quantum channel described by a unitary evolution \(U\) and a target evolution \(V\) can be calculated as Hilbert\sphinxhyphen{}Schmidt vector product: \begin{equation}
I_e = 1 - \frac{1}{d^2}\vert \text{tr}\left( V^\dagger U \right)|^2
\end{equation}

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[5]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYG{k+kn}{from} \PYG{n+nn}{qsim}\PYG{n+nn}{.}\PYG{n+nn}{cost\PYGZus{}functions} \PYG{k+kn}{import} \PYG{n}{OperationInfidelity}


\PYG{n}{entanglement\PYGZus{}infidelity} \PYG{o}{=} \PYG{n}{OperationInfidelity}\PYG{p}{(}
    \PYG{n}{solver}\PYG{o}{=}\PYG{n}{solver}\PYG{p}{,}
    \PYG{n}{target}\PYG{o}{=}\PYG{n}{sigma\PYGZus{}x}
\PYG{p}{)}

\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{The entanglement infidelity }\PYG{l+s+s2}{\PYGZdq{}} \PYG{o}{+}  \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{entanglement\PYGZus{}infidelity}\PYG{o}{.}\PYG{n}{costs}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
      \PYG{o}{+} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ is 0 within the computational accuracy. }\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}
}

{

\kern-\sphinxverbatimsmallskipamount\kern-\baselineskip
\kern+\FrameHeightAdjust\kern-\fboxrule
\vspace{\nbsphinxcodecellspacing}

\sphinxsetup{VerbatimColor={named}{white}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
The entanglement infidelity -8.881784197001252e-16is 0 within the computational accuracy.
\end{sphinxVerbatim}
}

Lets see what happens if we change the pulse to a \(X_{\pi/2}\)\sphinxhyphen{}gate, as we halve the control amplitude value.

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[6]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYG{n}{solver}\PYG{o}{.}\PYG{n}{set\PYGZus{}optimization\PYGZus{}parameters}\PYG{p}{(}\PYG{o}{.}\PYG{l+m+mi}{5} \PYG{o}{*} \PYG{n}{control\PYGZus{}amplitudes}\PYG{p}{)}
\PYG{n}{solver}\PYG{o}{.}\PYG{n}{plot\PYGZus{}bloch\PYGZus{}sphere}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}
}

\hrule height -\fboxrule\relax
\vspace{\nbsphinxcodecellspacing}

\makeatletter\setbox\nbsphinxpromptbox\box\voidb@x\makeatother

\begin{nbsphinxfancyoutput}

\noindent\sphinxincludegraphics[width=374\sphinxpxdimen,height=374\sphinxpxdimen]{{examples_entanglement_fidelity_5_0}.png}

\end{nbsphinxfancyoutput}

We can verify that the system now does only a rotation of \(\pi / 2\) with the bloch sphere plot.

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[7]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{New enganglement fidelity: }\PYG{l+s+s2}{\PYGZdq{}} \PYG{o}{+} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{entanglement\PYGZus{}infidelity}\PYG{o}{.}\PYG{n}{costs}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}
}

{

\kern-\sphinxverbatimsmallskipamount\kern-\baselineskip
\kern+\FrameHeightAdjust\kern-\fboxrule
\vspace{\nbsphinxcodecellspacing}

\sphinxsetup{VerbatimColor={named}{white}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
New enganglement fidelity: 0.5000000000000002
\end{sphinxVerbatim}
}


\subsection{Optimization}
\label{\detokenize{examples/optimization:Optimization}}\label{\detokenize{examples/optimization::doc}}
In the field of optimal control, minimization algorithms are used to search for global minima of cost functions. In the case of quantum computing the cost function is often the aforementioned quantum fidelity and the control parameters are usually pulse amplitudes.

Lets consider the previous example:

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[1]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}

\PYG{k+kn}{from} \PYG{n+nn}{qsim}\PYG{n+nn}{.}\PYG{n+nn}{matrix} \PYG{k+kn}{import} \PYG{n}{DenseOperator}
\PYG{k+kn}{from} \PYG{n+nn}{qsim}\PYG{n+nn}{.}\PYG{n+nn}{solver\PYGZus{}algorithms} \PYG{k+kn}{import} \PYG{n}{SchroedingerSolver}
\PYG{k+kn}{from} \PYG{n+nn}{qsim}\PYG{n+nn}{.}\PYG{n+nn}{cost\PYGZus{}functions} \PYG{k+kn}{import} \PYG{n}{OperationInfidelity}


\PYG{n}{sigma\PYGZus{}x} \PYG{o}{=} \PYG{n}{DenseOperator}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{asarray}\PYG{p}{(}\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{sigma\PYGZus{}y} \PYG{o}{=} \PYG{n}{DenseOperator}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{asarray}\PYG{p}{(}\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{n}{j}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{n}{j}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{sigma\PYGZus{}z} \PYG{o}{=} \PYG{n}{DenseOperator}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{asarray}\PYG{p}{(}\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{zero\PYGZus{}matrix} \PYG{o}{=} \PYG{n}{DenseOperator}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{asarray}\PYG{p}{(}\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}

\PYG{n}{delta\PYGZus{}omega} \PYG{o}{=} \PYG{l+m+mi}{0}

\PYG{n}{h\PYGZus{}ctrl} \PYG{o}{=} \PYG{p}{[}\PYG{o}{.}\PYG{l+m+mi}{5} \PYG{o}{*} \PYG{n}{sigma\PYGZus{}x}\PYG{p}{,} \PYG{o}{.}\PYG{l+m+mi}{5} \PYG{o}{*} \PYG{n}{sigma\PYGZus{}y}\PYG{p}{]}
\PYG{n}{h\PYGZus{}drift} \PYG{o}{=} \PYG{p}{[}\PYG{n}{delta\PYGZus{}omega} \PYG{o}{*} \PYG{o}{.}\PYG{l+m+mi}{5} \PYG{o}{*} \PYG{n}{sigma\PYGZus{}z}\PYG{p}{]}

\PYG{n}{n\PYGZus{}time\PYGZus{}steps} \PYG{o}{=} \PYG{l+m+mi}{5}
\PYG{n}{total\PYGZus{}time} \PYG{o}{=} \PYG{l+m+mi}{1}

\PYG{n}{time\PYGZus{}steps} \PYG{o}{=} \PYG{p}{(}\PYG{n}{total\PYGZus{}time} \PYG{o}{/} \PYG{n}{n\PYGZus{}time\PYGZus{}steps}\PYG{p}{)} \PYG{o}{*} \PYG{n}{np}\PYG{o}{.}\PYG{n}{ones}\PYG{p}{(}\PYG{p}{(}\PYG{n}{n\PYGZus{}time\PYGZus{}steps}\PYG{p}{,} \PYG{p}{)}\PYG{p}{)}

\PYG{n}{control\PYGZus{}amplitudes} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{zeros}\PYG{p}{(}\PYG{p}{(}\PYG{n}{n\PYGZus{}time\PYGZus{}steps}\PYG{p}{,} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{h\PYGZus{}ctrl}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{control\PYGZus{}amplitudes}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{pi}

\PYG{n}{solver} \PYG{o}{=} \PYG{n}{SchroedingerSolver}\PYG{p}{(}
    \PYG{n}{h\PYGZus{}drift}\PYG{o}{=}\PYG{n}{h\PYGZus{}drift} \PYG{o}{*} \PYG{n}{n\PYGZus{}time\PYGZus{}steps}\PYG{p}{,}
    \PYG{n}{h\PYGZus{}ctrl}\PYG{o}{=}\PYG{n}{h\PYGZus{}ctrl}\PYG{p}{,}
    \PYG{n}{tau}\PYG{o}{=}\PYG{n}{time\PYGZus{}steps}
\PYG{p}{)}
\PYG{n}{solver}\PYG{o}{.}\PYG{n}{set\PYGZus{}optimization\PYGZus{}parameters}\PYG{p}{(}\PYG{l+m+mi}{0} \PYG{o}{*} \PYG{n}{control\PYGZus{}amplitudes}\PYG{p}{)}

\PYG{n}{entanglement\PYGZus{}infidelity} \PYG{o}{=} \PYG{n}{OperationInfidelity}\PYG{p}{(}
    \PYG{n}{solver}\PYG{o}{=}\PYG{n}{solver}\PYG{p}{,}
    \PYG{n}{target}\PYG{o}{=}\PYG{n}{sigma\PYGZus{}x}
\PYG{p}{)}
\end{sphinxVerbatim}
}

The Simulator class defines an interface between the simulation and the optimization algorithm.

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[2]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYG{k+kn}{from} \PYG{n+nn}{qsim}\PYG{n+nn}{.}\PYG{n+nn}{simulator} \PYG{k+kn}{import} \PYG{n}{Simulator}

\PYG{n}{simulator} \PYG{o}{=} \PYG{n}{Simulator}\PYG{p}{(}
    \PYG{n}{solvers}\PYG{o}{=}\PYG{p}{[}\PYG{n}{solver}\PYG{p}{,} \PYG{p}{]}\PYG{p}{,}
    \PYG{n}{cost\PYGZus{}fktns}\PYG{o}{=}\PYG{p}{[}\PYG{n}{entanglement\PYGZus{}infidelity}\PYG{p}{,} \PYG{p}{]}
\PYG{p}{)}
\end{sphinxVerbatim}
}

The actual optimization algorithm is controlled by the class Optimizer. Let’s use the least squares optimization of scipy.

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[3]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYG{k+kn}{from} \PYG{n+nn}{qsim}\PYG{n+nn}{.}\PYG{n+nn}{optimize} \PYG{k+kn}{import} \PYG{n}{LeastSquaresOptimizer}

\PYG{n}{termination\PYGZus{}conditions} \PYG{o}{=} \PYG{p}{\PYGZob{}}
    \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{min\PYGZus{}gradient\PYGZus{}norm}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mf}{1e\PYGZhy{}15}\PYG{p}{,}
    \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{min\PYGZus{}cost\PYGZus{}gain}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mf}{1e\PYGZhy{}15}\PYG{p}{,}
    \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{max\PYGZus{}wall\PYGZus{}time}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mf}{30.0}\PYG{p}{,}
    \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{max\PYGZus{}cost\PYGZus{}func\PYGZus{}calls}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mf}{1e6}\PYG{p}{,}
    \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{max\PYGZus{}iterations}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mi}{100}\PYG{p}{,}
    \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{min\PYGZus{}amplitude\PYGZus{}change}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mf}{1e\PYGZhy{}8}
\PYG{p}{\PYGZcb{}}

\PYG{n}{upper\PYGZus{}bounds} \PYG{o}{=} \PYG{l+m+mi}{2} \PYG{o}{*} \PYG{n}{np}\PYG{o}{.}\PYG{n}{pi} \PYG{o}{*} \PYG{n}{np}\PYG{o}{.}\PYG{n}{ones}\PYG{p}{(}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{h\PYGZus{}ctrl}\PYG{p}{)} \PYG{o}{*} \PYG{n}{n\PYGZus{}time\PYGZus{}steps}\PYG{p}{,} \PYG{p}{)}\PYG{p}{)}
\PYG{n}{lower\PYGZus{}bounds} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1} \PYG{o}{*} \PYG{n}{upper\PYGZus{}bounds}

\PYG{n}{optimizer} \PYG{o}{=} \PYG{n}{LeastSquaresOptimizer}\PYG{p}{(}
    \PYG{n}{system\PYGZus{}simulator}\PYG{o}{=}\PYG{n}{simulator}\PYG{p}{,}
    \PYG{n}{termination\PYGZus{}cond}\PYG{o}{=}\PYG{n}{termination\PYGZus{}conditions}\PYG{p}{,}
    \PYG{n}{save\PYGZus{}intermediary\PYGZus{}steps}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{,}
    \PYG{n}{bounds}\PYG{o}{=}\PYG{p}{[}\PYG{n}{lower\PYGZus{}bounds}\PYG{p}{,} \PYG{n}{upper\PYGZus{}bounds}\PYG{p}{]}
\PYG{p}{)}
\end{sphinxVerbatim}
}

The bounds mark the range in which the optimization algorithm shall search for an optimum. As initial values, we use a random pulse.

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[ ]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYG{n}{initial\PYGZus{}pulse} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{pi} \PYG{o}{*} \PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{rand}\PYG{p}{(}\PYG{n}{n\PYGZus{}time\PYGZus{}steps}\PYG{p}{,} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{h\PYGZus{}ctrl}\PYG{p}{)}\PYG{p}{)}

\PYG{n}{result} \PYG{o}{=} \PYG{n}{optimizer}\PYG{o}{.}\PYG{n}{run\PYGZus{}optimization}\PYG{p}{(}\PYG{n}{initial\PYGZus{}control\PYGZus{}amplitudes}\PYG{o}{=}\PYG{n}{initial\PYGZus{}pulse}\PYG{p}{)}
\end{sphinxVerbatim}
}

Next we initialize a data container to store the information gained in the optimization. The DataContainer class is instantiated with a storage path and file name, where the data can be stored.

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[4]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYG{k+kn}{from} \PYG{n+nn}{qsim}\PYG{n+nn}{.}\PYG{n+nn}{data\PYGZus{}container} \PYG{k+kn}{import} \PYG{n}{DataContainer}
\PYG{k+kn}{from} \PYG{n+nn}{qsim}\PYG{n+nn}{.}\PYG{n+nn}{analyser} \PYG{k+kn}{import} \PYG{n}{Analyser}

\PYG{n}{data\PYGZus{}container} \PYG{o}{=} \PYG{n}{DataContainer}\PYG{p}{(}
    \PYG{n}{storage\PYGZus{}path}\PYG{o}{=}\PYG{l+s+sa}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{..}\PYG{l+s+s1}{\PYGZbs{}}\PYG{l+s+s1}{..}\PYG{l+s+s1}{\PYGZbs{}}\PYG{l+s+s1}{..}\PYG{l+s+s1}{\PYGZbs{}}\PYG{l+s+s1}{temp}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
    \PYG{n}{file\PYGZus{}name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{File Name}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{p}{)}

\PYG{n}{data\PYGZus{}container}\PYG{o}{.}\PYG{n}{append\PYGZus{}optim\PYGZus{}result}\PYG{p}{(}\PYG{n}{optim\PYGZus{}result}\PYG{o}{=}\PYG{n}{result}\PYG{p}{)}
\PYG{n}{analyser} \PYG{o}{=} \PYG{n}{Analyser}\PYG{p}{(}\PYG{n}{data}\PYG{o}{=}\PYG{n}{data\PYGZus{}container}\PYG{p}{)}
\end{sphinxVerbatim}
}

The Analyser gives access to some convenience functions to plot the the cost function evaluations during the optimization run.

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[5]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYG{n}{analyser}\PYG{o}{.}\PYG{n}{plot\PYGZus{}costs}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}
}

\hrule height -\fboxrule\relax
\vspace{\nbsphinxcodecellspacing}

\makeatletter\setbox\nbsphinxpromptbox\box\voidb@x\makeatother

\begin{nbsphinxfancyoutput}

\noindent\sphinxincludegraphics[width=386\sphinxpxdimen,height=251\sphinxpxdimen]{{examples_optimization_11_0}.png}

\end{nbsphinxfancyoutput}

In the plotted costs, we can observe the expected linear convergence for newton\sphinxhyphen{}like optimization algorithms.

The Data container allows also to pickle the gathered data for later analysis.

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[10]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYG{n}{data\PYGZus{}container}\PYG{o}{.}\PYG{n}{to\PYGZus{}pickle}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{loaded\PYGZus{}data} \PYG{o}{=} \PYG{n}{DataContainer}\PYG{o}{.}\PYG{n}{from\PYGZus{}pickle}\PYG{p}{(}\PYG{l+s+sa}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{..}\PYG{l+s+s1}{\PYGZbs{}}\PYG{l+s+s1}{..}\PYG{l+s+s1}{\PYGZbs{}}\PYG{l+s+s1}{..}\PYG{l+s+s1}{\PYGZbs{}}\PYG{l+s+s1}{temp}\PYG{l+s+s1}{\PYGZbs{}}\PYG{l+s+s1}{File Name}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

\PYG{n}{analyser} \PYG{o}{=} \PYG{n}{Analyser}\PYG{p}{(}\PYG{n}{loaded\PYGZus{}data}\PYG{p}{)}
\PYG{n}{analyser}\PYG{o}{.}\PYG{n}{plot\PYGZus{}costs}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{solver}\PYG{o}{.}\PYG{n}{set\PYGZus{}optimization\PYGZus{}parameters}\PYG{p}{(}\PYG{n}{loaded\PYGZus{}data}\PYG{o}{.}\PYG{n}{final\PYGZus{}parameters}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{solver}\PYG{o}{.}\PYG{n}{plot\PYGZus{}bloch\PYGZus{}sphere}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}
}

\hrule height -\fboxrule\relax
\vspace{\nbsphinxcodecellspacing}

\makeatletter\setbox\nbsphinxpromptbox\box\voidb@x\makeatother

\begin{nbsphinxfancyoutput}

\noindent\sphinxincludegraphics[width=386\sphinxpxdimen,height=251\sphinxpxdimen]{{examples_optimization_13_0}.png}

\end{nbsphinxfancyoutput}

\hrule height -\fboxrule\relax
\vspace{\nbsphinxcodecellspacing}

\makeatletter\setbox\nbsphinxpromptbox\box\voidb@x\makeatother

\begin{nbsphinxfancyoutput}

\noindent\sphinxincludegraphics[width=374\sphinxpxdimen,height=374\sphinxpxdimen]{{examples_optimization_13_1}.png}

\end{nbsphinxfancyoutput}


\subsection{Pulse Parameterization}
\label{\detokenize{examples/pulse_parameterization:Pulse-Parameterization}}\label{\detokenize{examples/pulse_parameterization::doc}}
Often times, the optimization parameters are not exactly the amplitudes in the Hamilton operator but can be mapped by differentiable functions.

One prominent example is IQ\sphinxhyphen{}modulated control in rabi driving. Lets assume the Hamiltonian

\begin{equation}
H = \frac{\hbar \omega_0}{2} \sigma_z + \hbar A \text{sin}(\omega t + \delta)
\sigma_x,
\end{equation}

change into the rotating frame by transforming with

\begin{equation}
U(t) =
\begin{pmatrix}
e^{-i\omega_0 t / 2} & 0 \\
0 & e^{i\omega_0 t / 2}
\end{pmatrix}
\end{equation}

and apply the rotating wave approximation to get

\begin{equation}
H = \frac{\hbar A}{2} \text{cos} (\delta ) \sigma_x
+ \frac{\hbar A}{2} \text{sin} (\delta ) \sigma_y.
\end{equation}

Our optimization parameters are now \((A, \delta)\) and the amplitudes in our control hamiltonian are \((\frac{\hbar A}{2} \text{cos} (\delta ), \frac{\hbar A}{2} \text{sin} (\delta ))\). We can use the class AmplitudeFunction to implement an interface to our amplitude functions.

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[1]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}
\PYG{k+kn}{from} \PYG{n+nn}{qsim}\PYG{n+nn}{.}\PYG{n+nn}{amplitude\PYGZus{}functions} \PYG{k+kn}{import} \PYG{n}{CustomAmpFunc}


\PYG{n}{n\PYGZus{}time\PYGZus{}steps} \PYG{o}{=} \PYG{l+m+mi}{10}
\PYG{n}{n\PYGZus{}opt\PYGZus{}pars} \PYG{o}{=} \PYG{l+m+mi}{2}
\PYG{n}{n\PYGZus{}ctrl\PYGZus{}amps} \PYG{o}{=} \PYG{l+m+mi}{2}

\PYG{k}{def} \PYG{n+nf}{amp\PYGZus{}func}\PYG{p}{(}\PYG{n}{opt\PYGZus{}pars}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{ctrl\PYGZus{}amps} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{empty}\PYG{p}{(}\PYG{p}{(}\PYG{n}{opt\PYGZus{}pars}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{n\PYGZus{}opt\PYGZus{}pars}\PYG{p}{)}\PYG{p}{)}
    \PYG{n}{ctrl\PYGZus{}amps}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{=} \PYG{o}{.}\PYG{l+m+mi}{5} \PYG{o}{*} \PYG{n}{opt\PYGZus{}pars}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{*} \PYG{n}{np}\PYG{o}{.}\PYG{n}{cos}\PYG{p}{(}\PYG{n}{opt\PYGZus{}pars}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}
    \PYG{n}{ctrl\PYGZus{}amps}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{=} \PYG{o}{.}\PYG{l+m+mi}{5} \PYG{o}{*} \PYG{n}{opt\PYGZus{}pars}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{*} \PYG{n}{np}\PYG{o}{.}\PYG{n}{sin}\PYG{p}{(}\PYG{n}{opt\PYGZus{}pars}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}
    \PYG{k}{return} \PYG{n}{ctrl\PYGZus{}amps}

\PYG{k}{def} \PYG{n+nf}{deriv\PYGZus{}amp\PYGZus{}func}\PYG{p}{(}\PYG{n}{opt\PYGZus{}pars}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{ctrl\PYGZus{}amps\PYGZus{}deriv} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{empty}\PYG{p}{(}\PYG{p}{(}\PYG{n}{opt\PYGZus{}pars}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{n\PYGZus{}opt\PYGZus{}pars}\PYG{p}{,} \PYG{n}{n\PYGZus{}ctrl\PYGZus{}amps}\PYG{p}{)}\PYG{p}{)}

    \PYG{n}{ctrl\PYGZus{}amps\PYGZus{}deriv}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{=} \PYG{o}{.}\PYG{l+m+mi}{5} \PYG{o}{*} \PYG{n}{np}\PYG{o}{.}\PYG{n}{cos}\PYG{p}{(}\PYG{n}{opt\PYGZus{}pars}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}
    \PYG{n}{ctrl\PYGZus{}amps\PYGZus{}deriv}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{=} \PYG{o}{.}\PYG{l+m+mi}{5} \PYG{o}{*} \PYG{n}{np}\PYG{o}{.}\PYG{n}{sin}\PYG{p}{(}\PYG{n}{opt\PYGZus{}pars}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}

    \PYG{n}{ctrl\PYGZus{}amps\PYGZus{}deriv}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{o}{.}\PYG{l+m+mi}{5} \PYG{o}{*} \PYG{n}{opt\PYGZus{}pars}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{*} \PYG{n}{np}\PYG{o}{.}\PYG{n}{sin}\PYG{p}{(}\PYG{n}{opt\PYGZus{}pars}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}
    \PYG{n}{ctrl\PYGZus{}amps\PYGZus{}deriv}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{=} \PYG{o}{.}\PYG{l+m+mi}{5} \PYG{o}{*} \PYG{n}{opt\PYGZus{}pars}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{*} \PYG{n}{np}\PYG{o}{.}\PYG{n}{cos}\PYG{p}{(}\PYG{n}{opt\PYGZus{}pars}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}

    \PYG{k}{return} \PYG{n}{ctrl\PYGZus{}amps\PYGZus{}deriv}

\PYG{n}{amplitude\PYGZus{}function} \PYG{o}{=} \PYG{n}{CustomAmpFunc}\PYG{p}{(}
    \PYG{n}{value\PYGZus{}function}\PYG{o}{=}\PYG{n}{amp\PYGZus{}func}\PYG{p}{,}
    \PYG{n}{derivative\PYGZus{}function}\PYG{o}{=}\PYG{n}{deriv\PYGZus{}amp\PYGZus{}func}
\PYG{p}{)}
\end{sphinxVerbatim}
}

We also need to implement the derivative, which will be used later in the newton type optimization algorithms.

If we now want to take our simulation another step closer to a real experiment, we can additionally simulate the imperfections of control electronics with a transfer function. Let’s assume for example that we cannot change the amplitude \(A\) and the phase \(\delta\) of our control pulse arbitrarily fast, but need some time.

This can be simulated for example with the assumptions that the actual changes will have the shape of an exponential saturation. The transfer function does the following. It oversamples the pulse, meaning that it divides each time step in a number of smaller time steps, and then applies the applies the requested function to the values of the finer time steps.

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[2]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYG{k+kn}{from} \PYG{n+nn}{qsim}\PYG{n+nn}{.}\PYG{n+nn}{transfer\PYGZus{}function} \PYG{k+kn}{import} \PYG{n}{ExponentialTF}
\PYG{n}{rise\PYGZus{}time} \PYG{o}{=} \PYG{o}{.}\PYG{l+m+mi}{02}
\PYG{n}{oversampling} \PYG{o}{=} \PYG{l+m+mi}{10}
\PYG{n}{transfer\PYGZus{}func} \PYG{o}{=} \PYG{n}{ExponentialTF}\PYG{p}{(}
    \PYG{n}{awg\PYGZus{}rise\PYGZus{}time}\PYG{o}{=}\PYG{n}{rise\PYGZus{}time}\PYG{p}{,}
    \PYG{n}{oversampling}\PYG{o}{=}\PYG{n}{oversampling}\PYG{p}{,}
    \PYG{n}{num\PYGZus{}ctrls}\PYG{o}{=}\PYG{n}{n\PYGZus{}ctrl\PYGZus{}amps}
\PYG{p}{)}

\PYG{n}{total\PYGZus{}time} \PYG{o}{=} \PYG{l+m+mi}{1}
\PYG{n}{time\PYGZus{}steps} \PYG{o}{=} \PYG{p}{(}\PYG{n}{total\PYGZus{}time} \PYG{o}{/} \PYG{n}{n\PYGZus{}time\PYGZus{}steps}\PYG{p}{)} \PYG{o}{*} \PYG{n}{np}\PYG{o}{.}\PYG{n}{ones}\PYG{p}{(}\PYG{p}{(}\PYG{n}{n\PYGZus{}time\PYGZus{}steps}\PYG{p}{,} \PYG{p}{)}\PYG{p}{)}

\PYG{n}{transfer\PYGZus{}func}\PYG{o}{.}\PYG{n}{set\PYGZus{}times}\PYG{p}{(}\PYG{n}{time\PYGZus{}steps}\PYG{p}{)}
\end{sphinxVerbatim}
}

It is important to set the time steps in the transfer function, such that the transferred time steps are known within the program.

Lets consider again a pulse with random amplitude and a constant phase to have a look at the effects of the transfer and amplitude function.

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[3]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYG{k+kn}{import} \PYG{n+nn}{matplotlib}\PYG{n+nn}{.}\PYG{n+nn}{pyplot} \PYG{k}{as} \PYG{n+nn}{plt}
\PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{seed}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}
\PYG{n}{random\PYGZus{}pulse} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{pi} \PYG{o}{*} \PYG{l+m+mi}{2} \PYG{o}{*} \PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{rand}\PYG{p}{(}\PYG{n}{n\PYGZus{}time\PYGZus{}steps}\PYG{p}{,} \PYG{n}{n\PYGZus{}ctrl\PYGZus{}amps}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{o}{.}\PYG{l+m+mi}{5}\PYG{p}{)}
\PYG{n}{random\PYGZus{}pulse}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{=} \PYG{o}{.}\PYG{l+m+mi}{1} \PYG{o}{*} \PYG{n}{np}\PYG{o}{.}\PYG{n}{pi}

\PYG{n}{transfer\PYGZus{}func}\PYG{o}{.}\PYG{n}{plot\PYGZus{}pulse}\PYG{p}{(}\PYG{n}{random\PYGZus{}pulse}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{amplitude\PYGZus{}function}\PYG{p}{(}\PYG{n}{transfer\PYGZus{}func}\PYG{p}{(}\PYG{n}{random\PYGZus{}pulse}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{title}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{After Application of Transfer and Amplitude Function}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{xlabel}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Time (a.u.)}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{ylabel}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Control Amplitude (a.u.)}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

\end{sphinxVerbatim}
}

\hrule height -\fboxrule\relax
\vspace{\nbsphinxcodecellspacing}

\makeatletter\setbox\nbsphinxpromptbox\box\voidb@x\makeatother

\begin{nbsphinxfancyoutput}

\noindent\sphinxincludegraphics[width=370\sphinxpxdimen,height=248\sphinxpxdimen]{{examples_pulse_parameterization_5_0}.png}

\end{nbsphinxfancyoutput}

\hrule height -\fboxrule\relax
\vspace{\nbsphinxcodecellspacing}

\makeatletter\setbox\nbsphinxpromptbox\box\voidb@x\makeatother

\begin{nbsphinxfancyoutput}

\noindent\sphinxincludegraphics[width=378\sphinxpxdimen,height=248\sphinxpxdimen]{{examples_pulse_parameterization_5_1}.png}

\end{nbsphinxfancyoutput}

{

\kern-\sphinxverbatimsmallskipamount\kern-\baselineskip
\kern+\FrameHeightAdjust\kern-\fboxrule
\vspace{\nbsphinxcodecellspacing}

\sphinxsetup{VerbatimColor={named}{white}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxout}[3]:\,\hspace{\fboxrule}\hspace{\fboxsep}}Text(0, 0.5, 'Control Amplitude (a.u.)')
\end{sphinxVerbatim}
}

\hrule height -\fboxrule\relax
\vspace{\nbsphinxcodecellspacing}

\makeatletter\setbox\nbsphinxpromptbox\box\voidb@x\makeatother

\begin{nbsphinxfancyoutput}

\noindent\sphinxincludegraphics[width=394\sphinxpxdimen,height=278\sphinxpxdimen]{{examples_pulse_parameterization_5_3}.png}

\end{nbsphinxfancyoutput}

For the optimization we can give the transfer and amplitude function as attributes to the solver class.

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[11]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYG{k+kn}{from} \PYG{n+nn}{qsim}\PYG{n+nn}{.}\PYG{n+nn}{matrix} \PYG{k+kn}{import} \PYG{n}{DenseOperator}
\PYG{k+kn}{from} \PYG{n+nn}{qsim}\PYG{n+nn}{.}\PYG{n+nn}{solver\PYGZus{}algorithms} \PYG{k+kn}{import} \PYG{n}{SchroedingerSolver}
\PYG{k+kn}{from} \PYG{n+nn}{qsim}\PYG{n+nn}{.}\PYG{n+nn}{cost\PYGZus{}functions} \PYG{k+kn}{import} \PYG{n}{OperationInfidelity}


\PYG{n}{sigma\PYGZus{}x} \PYG{o}{=} \PYG{n}{DenseOperator}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{asarray}\PYG{p}{(}\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{sigma\PYGZus{}y} \PYG{o}{=} \PYG{n}{DenseOperator}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{asarray}\PYG{p}{(}\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{n}{j}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{n}{j}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{sigma\PYGZus{}z} \PYG{o}{=} \PYG{n}{DenseOperator}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{asarray}\PYG{p}{(}\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{zero\PYGZus{}matrix} \PYG{o}{=} \PYG{n}{DenseOperator}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{asarray}\PYG{p}{(}\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}

\PYG{n}{delta\PYGZus{}omega} \PYG{o}{=} \PYG{l+m+mi}{0}

\PYG{n}{h\PYGZus{}ctrl} \PYG{o}{=} \PYG{p}{[}\PYG{o}{.}\PYG{l+m+mi}{5} \PYG{o}{*} \PYG{n}{sigma\PYGZus{}x}\PYG{p}{,} \PYG{o}{.}\PYG{l+m+mi}{5} \PYG{o}{*} \PYG{n}{sigma\PYGZus{}y}\PYG{p}{]}
\PYG{n}{h\PYGZus{}drift} \PYG{o}{=} \PYG{p}{[}\PYG{n}{delta\PYGZus{}omega} \PYG{o}{*} \PYG{o}{.}\PYG{l+m+mi}{5} \PYG{o}{*} \PYG{n}{sigma\PYGZus{}z}\PYG{p}{]}

\PYG{n}{control\PYGZus{}amplitudes} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{zeros}\PYG{p}{(}\PYG{p}{(}\PYG{n}{n\PYGZus{}time\PYGZus{}steps}\PYG{p}{,} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{h\PYGZus{}ctrl}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{control\PYGZus{}amplitudes}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{pi}

\PYG{n}{solver} \PYG{o}{=} \PYG{n}{SchroedingerSolver}\PYG{p}{(}
    \PYG{n}{h\PYGZus{}drift}\PYG{o}{=}\PYG{n}{h\PYGZus{}drift} \PYG{o}{*} \PYG{n}{n\PYGZus{}time\PYGZus{}steps} \PYG{o}{*} \PYG{n}{oversampling}\PYG{p}{,}
    \PYG{n}{h\PYGZus{}ctrl}\PYG{o}{=}\PYG{n}{h\PYGZus{}ctrl}\PYG{p}{,}
    \PYG{n}{tau}\PYG{o}{=}\PYG{n}{np}\PYG{o}{.}\PYG{n}{repeat}\PYG{p}{(}\PYG{n}{time\PYGZus{}steps} \PYG{o}{/} \PYG{n}{oversampling}\PYG{p}{,} \PYG{n}{oversampling}\PYG{p}{)}\PYG{p}{,}
    \PYG{n}{transfer\PYGZus{}function}\PYG{o}{=}\PYG{n}{transfer\PYGZus{}func}\PYG{p}{,}
    \PYG{n}{amplitude\PYGZus{}function}\PYG{o}{=}\PYG{n}{amplitude\PYGZus{}function}
\PYG{p}{)}
\PYG{n}{solver}\PYG{o}{.}\PYG{n}{set\PYGZus{}optimization\PYGZus{}parameters}\PYG{p}{(}\PYG{l+m+mi}{0} \PYG{o}{*} \PYG{n}{control\PYGZus{}amplitudes}\PYG{p}{)}

\PYG{n}{entanglement\PYGZus{}infidelity} \PYG{o}{=} \PYG{n}{OperationInfidelity}\PYG{p}{(}
    \PYG{n}{solver}\PYG{o}{=}\PYG{n}{solver}\PYG{p}{,}
    \PYG{n}{target}\PYG{o}{=}\PYG{n}{sigma\PYGZus{}x}
\PYG{p}{)}

\PYG{k+kn}{from} \PYG{n+nn}{qsim}\PYG{n+nn}{.}\PYG{n+nn}{simulator} \PYG{k+kn}{import} \PYG{n}{Simulator}

\PYG{n}{simulator} \PYG{o}{=} \PYG{n}{Simulator}\PYG{p}{(}
    \PYG{n}{solvers}\PYG{o}{=}\PYG{p}{[}\PYG{n}{solver}\PYG{p}{,} \PYG{p}{]}\PYG{p}{,}
    \PYG{n}{cost\PYGZus{}fktns}\PYG{o}{=}\PYG{p}{[}\PYG{n}{entanglement\PYGZus{}infidelity}\PYG{p}{,} \PYG{p}{]}
\PYG{p}{)}

\PYG{k+kn}{from} \PYG{n+nn}{qsim}\PYG{n+nn}{.}\PYG{n+nn}{optimize} \PYG{k+kn}{import} \PYG{n}{LeastSquaresOptimizer}

\PYG{n}{termination\PYGZus{}conditions} \PYG{o}{=} \PYG{p}{\PYGZob{}}
    \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{min\PYGZus{}gradient\PYGZus{}norm}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mf}{1e\PYGZhy{}15}\PYG{p}{,}
    \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{min\PYGZus{}cost\PYGZus{}gain}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mf}{1e\PYGZhy{}15}\PYG{p}{,}
    \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{max\PYGZus{}wall\PYGZus{}time}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mf}{30.0}\PYG{p}{,}
    \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{max\PYGZus{}cost\PYGZus{}func\PYGZus{}calls}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mf}{1e6}\PYG{p}{,}
    \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{max\PYGZus{}iterations}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mi}{1000}\PYG{p}{,}
    \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{min\PYGZus{}amplitude\PYGZus{}change}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mf}{1e\PYGZhy{}8}
\PYG{p}{\PYGZcb{}}

\PYG{n}{upper\PYGZus{}bounds} \PYG{o}{=} \PYG{l+m+mi}{2} \PYG{o}{*} \PYG{l+m+mi}{2} \PYG{o}{*} \PYG{n}{np}\PYG{o}{.}\PYG{n}{pi} \PYG{o}{*} \PYG{n}{np}\PYG{o}{.}\PYG{n}{ones}\PYG{p}{(}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{h\PYGZus{}ctrl}\PYG{p}{)} \PYG{o}{*} \PYG{n}{n\PYGZus{}time\PYGZus{}steps}\PYG{p}{,} \PYG{p}{)}\PYG{p}{)}
\PYG{n}{lower\PYGZus{}bounds} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1} \PYG{o}{*} \PYG{n}{upper\PYGZus{}bounds}

\PYG{n}{optimizer} \PYG{o}{=} \PYG{n}{LeastSquaresOptimizer}\PYG{p}{(}
    \PYG{n}{system\PYGZus{}simulator}\PYG{o}{=}\PYG{n}{simulator}\PYG{p}{,}
    \PYG{n}{termination\PYGZus{}cond}\PYG{o}{=}\PYG{n}{termination\PYGZus{}conditions}\PYG{p}{,}
    \PYG{n}{save\PYGZus{}intermediary\PYGZus{}steps}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{,}
    \PYG{n}{bounds}\PYG{o}{=}\PYG{p}{[}\PYG{n}{lower\PYGZus{}bounds}\PYG{p}{,} \PYG{n}{upper\PYGZus{}bounds}\PYG{p}{]}
\PYG{p}{)}

\PYG{n}{result} \PYG{o}{=} \PYG{n}{optimizer}\PYG{o}{.}\PYG{n}{run\PYGZus{}optimization}\PYG{p}{(}\PYG{n}{initial\PYGZus{}control\PYGZus{}amplitudes}\PYG{o}{=}\PYG{n}{random\PYGZus{}pulse}\PYG{p}{)}
\PYG{n}{solver}\PYG{o}{.}\PYG{n}{set\PYGZus{}optimization\PYGZus{}parameters}\PYG{p}{(}\PYG{n}{result}\PYG{o}{.}\PYG{n}{final\PYGZus{}parameters}\PYG{p}{)}
\PYG{n}{solver}\PYG{o}{.}\PYG{n}{plot\PYGZus{}bloch\PYGZus{}sphere}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}
}

And the optimized control amplitudes are:

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[14]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{amplitude\PYGZus{}function}\PYG{p}{(}\PYG{n}{transfer\PYGZus{}func}\PYG{p}{(}\PYG{n}{result}\PYG{o}{.}\PYG{n}{final\PYGZus{}parameters}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{title}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{After Application of Transfer and Amplitude Function}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{xlabel}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Time (a.u.)}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{ylabel}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Control Amplitude (a.u.)}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}
}

{

\kern-\sphinxverbatimsmallskipamount\kern-\baselineskip
\kern+\FrameHeightAdjust\kern-\fboxrule
\vspace{\nbsphinxcodecellspacing}

\sphinxsetup{VerbatimColor={named}{white}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxout}[14]:\,\hspace{\fboxrule}\hspace{\fboxsep}}Text(0, 0.5, 'Control Amplitude (a.u.)')
\end{sphinxVerbatim}
}

\hrule height -\fboxrule\relax
\vspace{\nbsphinxcodecellspacing}

\makeatletter\setbox\nbsphinxpromptbox\box\voidb@x\makeatother

\begin{nbsphinxfancyoutput}

\noindent\sphinxincludegraphics[width=384\sphinxpxdimen,height=278\sphinxpxdimen]{{examples_pulse_parameterization_9_1}.png}

\end{nbsphinxfancyoutput}


\subsection{Monte Carlo Simulations}
\label{\detokenize{examples/monte_carlo_experiments:Monte-Carlo-Simulations}}\label{\detokenize{examples/monte_carlo_experiments::doc}}
The noise which is present in quantum mechanical systems can be theoretically described by including random variables into Schroedinger’s equation turning it into a stochastic differential equation.

In the previous example of rabi driving, realistic experiments show some instability in the resonance frequency. Resulting in slight shifts. Lets therefore assume that the resonance frequency of our system is time dependent as has a mean value of \(\omega_0\).

\begin{equation}
\omega(t) = \omega_0 + \delta_\omega (t)
\end{equation}

Then we consider the following Hamilton operator in the rotating wave approximation:

\begin{equation}
H = \hbar \delta_\omega (t) \sigma_z / 2 + \hbar A_x (t) \sigma_x / 2
+ \hbar A_y(t) \sigma_y / 2
\end{equation}

We can assume that the noise spectral density \(S(f)\) of our random variable \(\delta_\omega\).

In Monte Carlo experiments, the equation is solved for a number of noise realizations which are created from the spectral noise density \(S\). In the simulation we distinguish between the general case of a real valued spectral noise density and quasi static noise. The latter describes noise with has its spectral weight at frequencies which are slower than the quantum gate, i.e. \(S(f) = 0 \; \forall f > 1/T\) where \(T\) is the total gate time.

The noise realizations required for the Monte Carlo simulations are created in the NoiseTraceGenerator class. Lets consider the case of quasi static noise first:

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[1]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYG{k+kn}{from} \PYG{n+nn}{qsim}\PYG{n+nn}{.}\PYG{n+nn}{noise} \PYG{k+kn}{import} \PYG{n}{NTGQuasiStatic}

\PYG{n}{ntg\PYGZus{}quasi\PYGZus{}static} \PYG{o}{=} \PYG{n}{NTGQuasiStatic}\PYG{p}{(}
    \PYG{n}{n\PYGZus{}samples\PYGZus{}per\PYGZus{}trace}\PYG{o}{=}\PYG{l+m+mi}{10}\PYG{p}{,}
    \PYG{n}{standard\PYGZus{}deviation}\PYG{o}{=}\PYG{p}{[}\PYG{o}{.}\PYG{l+m+mi}{5}\PYG{p}{]}\PYG{p}{,}
    \PYG{n}{n\PYGZus{}traces}\PYG{o}{=}\PYG{l+m+mi}{5}\PYG{p}{,}
    \PYG{n}{always\PYGZus{}redraw\PYGZus{}samples}\PYG{o}{=}\PYG{k+kc}{False}\PYG{p}{,}
    \PYG{n}{sampling\PYGZus{}mode}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{uncorrelated\PYGZus{}deterministic}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{p}{)}
\end{sphinxVerbatim}
}

The NTGQuasiStatic receives a standard deviation for each random variable. For quasi static noise it is usually sufficient to sample only a few traces, while many more are required to suppress the statistical uncertainties for general noise spectral densities.

In the sampling mode uncorrelated\_deterministic the noise is sampled deterministically from a Gauss distribution and each variable is sampled separately. Hence, the number of noise traces which are returned are n\_traces times the number of random variables.

The other implemented sampling mode is monte\_carlo, where the noise traces are created with help of random number generators and all random variables are sampled at once.

Lets optimize the pulse now for quasi static noise. We begin with the same setup as in the noiseless case:

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[2]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}

\PYG{k+kn}{from} \PYG{n+nn}{qsim}\PYG{n+nn}{.}\PYG{n+nn}{matrix} \PYG{k+kn}{import} \PYG{n}{DenseOperator}
\PYG{k+kn}{from} \PYG{n+nn}{qsim}\PYG{n+nn}{.}\PYG{n+nn}{solver\PYGZus{}algorithms} \PYG{k+kn}{import} \PYG{n}{SchroedingerSolver}
\PYG{k+kn}{from} \PYG{n+nn}{qsim}\PYG{n+nn}{.}\PYG{n+nn}{cost\PYGZus{}functions} \PYG{k+kn}{import} \PYG{n}{OperationInfidelity}


\PYG{n}{sigma\PYGZus{}x} \PYG{o}{=} \PYG{n}{DenseOperator}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{asarray}\PYG{p}{(}\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{sigma\PYGZus{}y} \PYG{o}{=} \PYG{n}{DenseOperator}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{asarray}\PYG{p}{(}\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{n}{j}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{n}{j}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{sigma\PYGZus{}z} \PYG{o}{=} \PYG{n}{DenseOperator}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{asarray}\PYG{p}{(}\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{zero\PYGZus{}matrix} \PYG{o}{=} \PYG{n}{DenseOperator}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{asarray}\PYG{p}{(}\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}

\PYG{n}{delta\PYGZus{}omega} \PYG{o}{=} \PYG{l+m+mi}{0}

\PYG{n}{h\PYGZus{}ctrl} \PYG{o}{=} \PYG{p}{[}\PYG{o}{.}\PYG{l+m+mi}{5} \PYG{o}{*} \PYG{n}{sigma\PYGZus{}x}\PYG{p}{,} \PYG{o}{.}\PYG{l+m+mi}{5} \PYG{o}{*} \PYG{n}{sigma\PYGZus{}y}\PYG{p}{]}
\PYG{n}{h\PYGZus{}drift} \PYG{o}{=} \PYG{p}{[}\PYG{n}{delta\PYGZus{}omega} \PYG{o}{*} \PYG{o}{.}\PYG{l+m+mi}{5} \PYG{o}{*} \PYG{n}{sigma\PYGZus{}z}\PYG{p}{]}

\PYG{n}{n\PYGZus{}time\PYGZus{}steps} \PYG{o}{=} \PYG{l+m+mi}{10}
\PYG{n}{total\PYGZus{}time} \PYG{o}{=} \PYG{l+m+mi}{1}

\PYG{n}{time\PYGZus{}steps} \PYG{o}{=} \PYG{p}{(}\PYG{n}{total\PYGZus{}time} \PYG{o}{/} \PYG{n}{n\PYGZus{}time\PYGZus{}steps}\PYG{p}{)} \PYG{o}{*} \PYG{n}{np}\PYG{o}{.}\PYG{n}{ones}\PYG{p}{(}\PYG{p}{(}\PYG{n}{n\PYGZus{}time\PYGZus{}steps}\PYG{p}{,} \PYG{p}{)}\PYG{p}{)}

\PYG{n}{control\PYGZus{}amplitudes} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{zeros}\PYG{p}{(}\PYG{p}{(}\PYG{n}{n\PYGZus{}time\PYGZus{}steps}\PYG{p}{,} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{h\PYGZus{}ctrl}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{control\PYGZus{}amplitudes}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{pi}

\PYG{n}{solver} \PYG{o}{=} \PYG{n}{SchroedingerSolver}\PYG{p}{(}
    \PYG{n}{h\PYGZus{}drift}\PYG{o}{=}\PYG{n}{h\PYGZus{}drift} \PYG{o}{*} \PYG{n}{n\PYGZus{}time\PYGZus{}steps}\PYG{p}{,}
    \PYG{n}{h\PYGZus{}ctrl}\PYG{o}{=}\PYG{n}{h\PYGZus{}ctrl}\PYG{p}{,}
    \PYG{n}{tau}\PYG{o}{=}\PYG{n}{time\PYGZus{}steps}
\PYG{p}{)}
\PYG{n}{solver}\PYG{o}{.}\PYG{n}{set\PYGZus{}optimization\PYGZus{}parameters}\PYG{p}{(}\PYG{l+m+mi}{0} \PYG{o}{*} \PYG{n}{control\PYGZus{}amplitudes}\PYG{p}{)}
\PYG{n}{x\PYGZus{}half} \PYG{o}{=} \PYG{n}{sigma\PYGZus{}x}\PYG{o}{.}\PYG{n}{exp}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{pi} \PYG{o}{*} \PYG{o}{.}\PYG{l+m+mi}{25}\PYG{n}{j}\PYG{p}{)}

\PYG{n}{entanglement\PYGZus{}infidelity} \PYG{o}{=} \PYG{n}{OperationInfidelity}\PYG{p}{(}
    \PYG{n}{solver}\PYG{o}{=}\PYG{n}{solver}\PYG{p}{,}
    \PYG{n}{target}\PYG{o}{=}\PYG{n}{x\PYGZus{}half}
\PYG{p}{)}
\end{sphinxVerbatim}
}

Then we need to add a solver for the stochastic Schroedinger equation.

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[3]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYG{k+kn}{from} \PYG{n+nn}{qsim}\PYG{n+nn}{.}\PYG{n+nn}{solver\PYGZus{}algorithms} \PYG{k+kn}{import} \PYG{n}{SchroedingerSMonteCarlo}

\PYG{n}{solver\PYGZus{}qs\PYGZus{}noise} \PYG{o}{=} \PYG{n}{SchroedingerSMonteCarlo}\PYG{p}{(}
    \PYG{n}{h\PYGZus{}drift}\PYG{o}{=}\PYG{n}{h\PYGZus{}drift} \PYG{o}{*} \PYG{n}{n\PYGZus{}time\PYGZus{}steps}\PYG{p}{,}
    \PYG{n}{h\PYGZus{}ctrl}\PYG{o}{=}\PYG{n}{h\PYGZus{}ctrl}\PYG{p}{,}
    \PYG{n}{h\PYGZus{}noise}\PYG{o}{=}\PYG{p}{[}\PYG{n}{sigma\PYGZus{}z}\PYG{p}{]}\PYG{p}{,}
    \PYG{n}{initial\PYGZus{}state}\PYG{o}{=}\PYG{n}{DenseOperator}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{eye}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{)}\PYG{p}{,}
    \PYG{n}{noise\PYGZus{}trace\PYGZus{}generator}\PYG{o}{=}\PYG{n}{ntg\PYGZus{}quasi\PYGZus{}static}\PYG{p}{,}
    \PYG{n}{tau}\PYG{o}{=}\PYG{n}{time\PYGZus{}steps}
\PYG{p}{)}
\end{sphinxVerbatim}
}

And a corresponding cost function which averages the entanglement infidelity \(F_e\) over the noise realizations to calculate the infidelity caused by noise \(_{n}F_e\):

\begin{equation}
_nF_e = \frac{1}{n_\text{traces}}\sum_{\delta_\omega} F
\end{equation}

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[4]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYG{k+kn}{from} \PYG{n+nn}{qsim}\PYG{n+nn}{.}\PYG{n+nn}{cost\PYGZus{}functions} \PYG{k+kn}{import} \PYG{n}{OperationNoiseInfidelity}

\PYG{n}{qs\PYGZus{}noise\PYGZus{}cost} \PYG{o}{=} \PYG{n}{OperationNoiseInfidelity}\PYG{p}{(}
    \PYG{n}{solver}\PYG{o}{=}\PYG{n}{solver\PYGZus{}qs\PYGZus{}noise}\PYG{p}{,}
    \PYG{n}{target}\PYG{o}{=}\PYG{n}{sigma\PYGZus{}x}\PYG{p}{,}
    \PYG{n}{neglect\PYGZus{}systematic\PYGZus{}errors}\PYG{o}{=}\PYG{k+kc}{True}
\PYG{p}{)}
\end{sphinxVerbatim}
}

We need to add the new solver and cost function to the simulator. We then also increase the maximal wall time since the Monte Carlo simulation is numerically more complex.

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[5]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYG{k+kn}{from} \PYG{n+nn}{qsim}\PYG{n+nn}{.}\PYG{n+nn}{simulator} \PYG{k+kn}{import} \PYG{n}{Simulator}
\PYG{k+kn}{from} \PYG{n+nn}{qsim}\PYG{n+nn}{.}\PYG{n+nn}{optimize} \PYG{k+kn}{import} \PYG{n}{LeastSquaresOptimizer}
\PYG{n}{simulator} \PYG{o}{=} \PYG{n}{Simulator}\PYG{p}{(}
    \PYG{n}{solvers}\PYG{o}{=}\PYG{p}{[}\PYG{n}{solver}\PYG{p}{,} \PYG{n}{solver\PYGZus{}qs\PYGZus{}noise}\PYG{p}{]}\PYG{p}{,}
    \PYG{n}{cost\PYGZus{}fktns}\PYG{o}{=}\PYG{p}{[}\PYG{n}{entanglement\PYGZus{}infidelity}\PYG{p}{,} \PYG{n}{qs\PYGZus{}noise\PYGZus{}cost}\PYG{p}{]}
\PYG{p}{)}

\PYG{n}{termination\PYGZus{}conditions} \PYG{o}{=} \PYG{p}{\PYGZob{}}
    \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{min\PYGZus{}gradient\PYGZus{}norm}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mf}{1e\PYGZhy{}15}\PYG{p}{,}
    \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{min\PYGZus{}cost\PYGZus{}gain}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mf}{1e\PYGZhy{}15}\PYG{p}{,}
    \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{max\PYGZus{}wall\PYGZus{}time}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mf}{120.0}\PYG{p}{,}
    \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{max\PYGZus{}cost\PYGZus{}func\PYGZus{}calls}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mf}{1e6}\PYG{p}{,}
    \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{max\PYGZus{}iterations}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mi}{1000}\PYG{p}{,}
    \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{min\PYGZus{}amplitude\PYGZus{}change}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mf}{1e\PYGZhy{}8}
\PYG{p}{\PYGZcb{}}

\PYG{n}{upper\PYGZus{}bounds} \PYG{o}{=} \PYG{l+m+mi}{5} \PYG{o}{*} \PYG{l+m+mi}{2} \PYG{o}{*} \PYG{n}{np}\PYG{o}{.}\PYG{n}{pi} \PYG{o}{*} \PYG{n}{np}\PYG{o}{.}\PYG{n}{ones}\PYG{p}{(}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{h\PYGZus{}ctrl}\PYG{p}{)} \PYG{o}{*} \PYG{n}{n\PYGZus{}time\PYGZus{}steps}\PYG{p}{,} \PYG{p}{)}\PYG{p}{)}
\PYG{n}{lower\PYGZus{}bounds} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1} \PYG{o}{*} \PYG{n}{upper\PYGZus{}bounds}

\PYG{n}{optimizer} \PYG{o}{=} \PYG{n}{LeastSquaresOptimizer}\PYG{p}{(}
    \PYG{n}{system\PYGZus{}simulator}\PYG{o}{=}\PYG{n}{simulator}\PYG{p}{,}
    \PYG{n}{termination\PYGZus{}cond}\PYG{o}{=}\PYG{n}{termination\PYGZus{}conditions}\PYG{p}{,}
    \PYG{n}{save\PYGZus{}intermediary\PYGZus{}steps}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{,}
    \PYG{n}{bounds}\PYG{o}{=}\PYG{p}{[}\PYG{n}{lower\PYGZus{}bounds}\PYG{p}{,} \PYG{n}{upper\PYGZus{}bounds}\PYG{p}{]}
\PYG{p}{)}
\end{sphinxVerbatim}
}

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[6]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{seed}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}
\PYG{n}{initial\PYGZus{}pulse} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{pi} \PYG{o}{*} \PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{rand}\PYG{p}{(}\PYG{n}{n\PYGZus{}time\PYGZus{}steps}\PYG{p}{,} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{h\PYGZus{}ctrl}\PYG{p}{)}\PYG{p}{)}

\PYG{n}{result} \PYG{o}{=} \PYG{n}{optimizer}\PYG{o}{.}\PYG{n}{run\PYGZus{}optimization}\PYG{p}{(}\PYG{n}{initial\PYGZus{}control\PYGZus{}amplitudes}\PYG{o}{=}\PYG{n}{initial\PYGZus{}pulse}\PYG{p}{)}
\PYG{n}{solver}\PYG{o}{.}\PYG{n}{set\PYGZus{}optimization\PYGZus{}parameters}\PYG{p}{(}\PYG{n}{result}\PYG{o}{.}\PYG{n}{final\PYGZus{}parameters}\PYG{p}{)}
\PYG{n}{solver}\PYG{o}{.}\PYG{n}{plot\PYGZus{}bloch\PYGZus{}sphere}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}
}

\hrule height -\fboxrule\relax
\vspace{\nbsphinxcodecellspacing}

\makeatletter\setbox\nbsphinxpromptbox\box\voidb@x\makeatother

\begin{nbsphinxfancyoutput}

\noindent\sphinxincludegraphics[width=374\sphinxpxdimen,height=374\sphinxpxdimen]{{examples_monte_carlo_experiments_10_0}.png}

\end{nbsphinxfancyoutput}

The optimized pulses, which are not susceptible to quasi static noise

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[7]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYG{k+kn}{from} \PYG{n+nn}{qsim}\PYG{n+nn}{.}\PYG{n+nn}{data\PYGZus{}container} \PYG{k+kn}{import} \PYG{n}{DataContainer}
\PYG{k+kn}{from} \PYG{n+nn}{qsim}\PYG{n+nn}{.}\PYG{n+nn}{analyser} \PYG{k+kn}{import} \PYG{n}{Analyser}

\PYG{n}{data\PYGZus{}container} \PYG{o}{=} \PYG{n}{DataContainer}\PYG{p}{(}
    \PYG{n}{storage\PYGZus{}path}\PYG{o}{=}\PYG{l+s+sa}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{..}\PYG{l+s+s1}{\PYGZbs{}}\PYG{l+s+s1}{..}\PYG{l+s+s1}{\PYGZbs{}}\PYG{l+s+s1}{..}\PYG{l+s+s1}{\PYGZbs{}}\PYG{l+s+s1}{temp}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
    \PYG{n}{file\PYGZus{}name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{File Name}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{p}{)}

\PYG{n}{data\PYGZus{}container}\PYG{o}{.}\PYG{n}{append\PYGZus{}optim\PYGZus{}result}\PYG{p}{(}\PYG{n}{optim\PYGZus{}result}\PYG{o}{=}\PYG{n}{result}\PYG{p}{)}
\PYG{n}{analyser} \PYG{o}{=} \PYG{n}{Analyser}\PYG{p}{(}\PYG{n}{data}\PYG{o}{=}\PYG{n}{data\PYGZus{}container}\PYG{p}{)}
\PYG{n}{analyser}\PYG{o}{.}\PYG{n}{plot\PYGZus{}costs}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}
}

\hrule height -\fboxrule\relax
\vspace{\nbsphinxcodecellspacing}

\makeatletter\setbox\nbsphinxpromptbox\box\voidb@x\makeatother

\begin{nbsphinxfancyoutput}

\noindent\sphinxincludegraphics[width=380\sphinxpxdimen,height=248\sphinxpxdimen]{{examples_monte_carlo_experiments_12_0}.png}

\end{nbsphinxfancyoutput}

To discuss the general case of arbitrary noise spectra, lets consider the example of Johnson noise, which directly applies to the control parameters.

The frequency range of the noise, we can sample is limited by the points in time for which we compute noise samples. The lower limit is \(f_{min} = 1/T\) where \(T\) is the total time of the pulse and the upper limit is given by \(f_{max} = 1 / \delta t\), where \(\delta t\) is the spacing of the time steps. To extend \(f_{max}\) to higher values, we can use a simple transfer function, which does nothing but oversampling the pulse.

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[8]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYG{k+kn}{from} \PYG{n+nn}{qsim}\PYG{n+nn}{.}\PYG{n+nn}{noise} \PYG{k+kn}{import} \PYG{n}{NTGColoredNoise}
\PYG{k+kn}{from} \PYG{n+nn}{qsim}\PYG{n+nn}{.}\PYG{n+nn}{transfer\PYGZus{}function} \PYG{k+kn}{import} \PYG{n}{IdentityTF}
\PYG{n}{oversampling} \PYG{o}{=} \PYG{l+m+mi}{100}
\PYG{k}{def} \PYG{n+nf}{noise\PYGZus{}spectral\PYGZus{}density}\PYG{p}{(}\PYG{n}{f}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{return} \PYG{l+m+mi}{1} \PYG{o}{/} \PYG{n}{f}

\PYG{n}{ntg\PYGZus{}1\PYGZus{}over\PYGZus{}f} \PYG{o}{=} \PYG{n}{NTGColoredNoise}\PYG{p}{(}
    \PYG{n}{noise\PYGZus{}spectral\PYGZus{}density}\PYG{o}{=}\PYG{n}{noise\PYGZus{}spectral\PYGZus{}density}\PYG{p}{,}
    \PYG{n}{dt}\PYG{o}{=}\PYG{n}{time\PYGZus{}steps}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{/} \PYG{n}{oversampling}\PYG{p}{,}
    \PYG{n}{n\PYGZus{}samples\PYGZus{}per\PYGZus{}trace}\PYG{o}{=}\PYG{n}{n\PYGZus{}time\PYGZus{}steps} \PYG{o}{*} \PYG{n}{oversampling}\PYG{p}{,}
    \PYG{n}{n\PYGZus{}traces}\PYG{o}{=}\PYG{l+m+mi}{100}\PYG{p}{,}
    \PYG{n}{n\PYGZus{}noise\PYGZus{}operators}\PYG{o}{=}\PYG{l+m+mi}{2}
\PYG{p}{)}

\PYG{n}{identity\PYGZus{}tf} \PYG{o}{=} \PYG{n}{IdentityTF}\PYG{p}{(}
    \PYG{n}{oversampling}\PYG{o}{=}\PYG{n}{oversampling}\PYG{p}{,}
    \PYG{n}{num\PYGZus{}ctrls}\PYG{o}{=}\PYG{l+m+mi}{2}
\PYG{p}{)}
\PYG{n}{identity\PYGZus{}tf}\PYG{o}{.}\PYG{n}{set\PYGZus{}times}\PYG{p}{(}\PYG{n}{time\PYGZus{}steps}\PYG{p}{)}
\end{sphinxVerbatim}
}

As we apply the noise directly to the optimization parameters we can use the class SchroedingerSMControlNoise, which also automatically takes the amplitude function into account, if any is given.

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[11]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYG{k+kn}{from} \PYG{n+nn}{qsim}\PYG{n+nn}{.}\PYG{n+nn}{solver\PYGZus{}algorithms} \PYG{k+kn}{import} \PYG{n}{SchroedingerSMCControlNoise}

\PYG{n}{solver\PYGZus{}1\PYGZus{}over\PYGZus{}f} \PYG{o}{=} \PYG{n}{SchroedingerSMCControlNoise}\PYG{p}{(}
    \PYG{n}{h\PYGZus{}drift}\PYG{o}{=}\PYG{n}{h\PYGZus{}drift} \PYG{o}{*} \PYG{n}{n\PYGZus{}time\PYGZus{}steps} \PYG{o}{*} \PYG{n}{oversampling}\PYG{p}{,}
    \PYG{n}{h\PYGZus{}ctrl}\PYG{o}{=}\PYG{n}{h\PYGZus{}ctrl}\PYG{p}{,}
    \PYG{n}{initial\PYGZus{}state}\PYG{o}{=}\PYG{n}{DenseOperator}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{eye}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{)}\PYG{p}{,}
    \PYG{n}{noise\PYGZus{}trace\PYGZus{}generator}\PYG{o}{=}\PYG{n}{ntg\PYGZus{}1\PYGZus{}over\PYGZus{}f}\PYG{p}{,}
    \PYG{n}{tau}\PYG{o}{=}\PYG{n}{total\PYGZus{}time} \PYG{o}{/} \PYG{n}{n\PYGZus{}time\PYGZus{}steps} \PYG{o}{/} \PYG{n}{oversampling} \PYG{o}{*} \PYG{n}{np}\PYG{o}{.}\PYG{n}{ones}\PYG{p}{(}
        \PYG{p}{(}\PYG{n}{n\PYGZus{}time\PYGZus{}steps} \PYG{o}{*} \PYG{n}{oversampling}\PYG{p}{,} \PYG{p}{)}
    \PYG{p}{)}\PYG{p}{,}
    \PYG{n}{transfer\PYGZus{}function}\PYG{o}{=}\PYG{n}{identity\PYGZus{}tf}
\PYG{p}{)}

\PYG{n}{cost\PYGZus{}1\PYGZus{}over\PYGZus{}f} \PYG{o}{=} \PYG{n}{OperationNoiseInfidelity}\PYG{p}{(}
    \PYG{n}{solver}\PYG{o}{=}\PYG{n}{solver\PYGZus{}1\PYGZus{}over\PYGZus{}f}\PYG{p}{,}
    \PYG{n}{target}\PYG{o}{=}\PYG{n}{sigma\PYGZus{}x}\PYG{p}{,}
    \PYG{n}{neglect\PYGZus{}systematic\PYGZus{}errors}\PYG{o}{=}\PYG{k+kc}{True}
\PYG{p}{)}

\PYG{n}{solver\PYGZus{}1\PYGZus{}over\PYGZus{}f}\PYG{o}{.}\PYG{n}{set\PYGZus{}optimization\PYGZus{}parameters}\PYG{p}{(}\PYG{n}{result}\PYG{o}{.}\PYG{n}{final\PYGZus{}parameters}\PYG{p}{)}
\PYG{n}{cost\PYGZus{}1\PYGZus{}over\PYGZus{}f}\PYG{o}{.}\PYG{n}{costs}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}
}

{

\kern-\sphinxverbatimsmallskipamount\kern-\baselineskip
\kern+\FrameHeightAdjust\kern-\fboxrule
\vspace{\nbsphinxcodecellspacing}

\sphinxsetup{VerbatimColor={named}{white}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxout}[11]:\,\hspace{\fboxrule}\hspace{\fboxsep}}0.09697704449530707
\end{sphinxVerbatim}
}


\subsection{Simulation of open quantum systems}
\label{\detokenize{examples/open_quantum_systems:Simulation-of-open-quantum-systems}}\label{\detokenize{examples/open_quantum_systems::doc}}
Schroedinger’s equation describes closed quantum systems in which all dynamics are described by unitary propagators and hence reversible. To simulate the loss of information caused by relaxation effects, we can describe the system as open quantum system with a master equation in Lindblad form:

\begin{equation}
\frac{d\rho}{dt}=-i[\rho, H] + \sum_k \left( L_k \rho L_k^\dagger
- \frac{1}{2} L_k^\dagger L_k \rho
- \frac{1}{2} \rho L_k^\dagger L_k \right)
\end{equation}

Lets consider the example of a rabi driven qubit again, but this time we take relaxations into the ground state into account, which attribute to the so called \(T_1\)\sphinxhyphen{}time or depolarization time.

So the Hamiltonian is given by:

\begin{equation}
H = \frac{\hbar A}{2} \text{cos} (\delta ) \sigma_x
+ \frac{\hbar A}{2} \text{sin} (\delta ) \sigma_y
\end{equation}

And the Lindblad operator, which describes the dissipative effects:

\begin{equation}
L = \sqrt{\gamma} \cdot \sigma^-
\end{equation}

where \(\gamma = 1 / T_1\) is the depolarization rate and the descending operator

\begin{equation}
\sigma^- = \frac{1}{2} (\sigma_x - i \sigma_y)  =
\begin{pmatrix}
0 & 0 \\
1 & 0
\end{pmatrix}.
\end{equation}

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[1]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}
\PYG{k+kn}{from} \PYG{n+nn}{qsim}\PYG{n+nn}{.}\PYG{n+nn}{matrix} \PYG{k+kn}{import} \PYG{n}{DenseOperator}


\PYG{n}{sigma\PYGZus{}x} \PYG{o}{=} \PYG{n}{DenseOperator}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{asarray}\PYG{p}{(}\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{sigma\PYGZus{}y} \PYG{o}{=} \PYG{n}{DenseOperator}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{asarray}\PYG{p}{(}\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{n}{j}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{n}{j}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{sigma\PYGZus{}z} \PYG{o}{=} \PYG{n}{DenseOperator}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{asarray}\PYG{p}{(}\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{sigma\PYGZus{}minus} \PYG{o}{=}\PYG{n}{DenseOperator}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{asarray}\PYG{p}{(}\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{zero\PYGZus{}matrix} \PYG{o}{=} \PYG{n}{DenseOperator}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{asarray}\PYG{p}{(}\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}

\PYG{n}{h\PYGZus{}ctrl} \PYG{o}{=} \PYG{p}{[}\PYG{o}{.}\PYG{l+m+mi}{5} \PYG{o}{*} \PYG{n}{sigma\PYGZus{}x}\PYG{p}{,} \PYG{o}{.}\PYG{l+m+mi}{5} \PYG{o}{*} \PYG{n}{sigma\PYGZus{}y}\PYG{p}{]}
\PYG{n}{h\PYGZus{}drift} \PYG{o}{=} \PYG{p}{[}\PYG{n}{zero\PYGZus{}matrix}\PYG{p}{]}
\end{sphinxVerbatim}
}

The master equation can be linearized with the Kronecker product, for which holds:

\begin{align}
AXB = C \Leftarrow \Rightarrow (B^T \otimes A) \vec{X} = \vec{C}
\end{align}

The linearized form of the master equation is then:

\begin{align}
\frac{d}{dt} \vec{\rho} = (-i \mathcal{H} + \mathcal{G}) \vec{\rho}
\end{align}

with \begin{align}
\mathcal{H} = I \otimes H - H \otimes I
\end{align}

and the dissipation operator

\begin{align}
\mathcal{G} = \sum_k (L^\ast_k \otimes L_k)
- \frac{1}{2} I \otimes (L_k^\dagger L_k)
- \frac{1}{2} ( L_k^T L_k^\ast ) \otimes I.
\end{align}

The master equation can be implemented in two different ways. Either we define the Lindblad operators and their corresponding prefactors, or we construct the dissipation operator.

Lets discuss the former option and assume that the relaxation rate is proportional to the driving amplitude:

\begin{align}
L = \sqrt{\gamma} \sigma^- = \sqrt{\gamma_0 \vert u \vert} \sigma^-
\end{align}

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[2]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYG{n}{lindblad\PYGZus{}operators} \PYG{o}{=} \PYG{p}{[}\PYG{n}{sigma\PYGZus{}minus}\PYG{p}{,} \PYG{p}{]}
\PYG{n}{gamma\PYGZus{}0} \PYG{o}{=} \PYG{o}{.}\PYG{l+m+mi}{001}

\PYG{k}{def} \PYG{n+nf}{prefactor\PYGZus{}function}\PYG{p}{(}\PYG{n}{control\PYGZus{}amplitudes}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{return} \PYG{n}{gamma\PYGZus{}0} \PYG{o}{*} \PYG{n}{np}\PYG{o}{.}\PYG{n}{expand\PYGZus{}dims}\PYG{p}{(}
        \PYG{n}{np}\PYG{o}{.}\PYG{n}{sum}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{abs}\PYG{p}{(}\PYG{n}{control\PYGZus{}amplitudes}\PYG{p}{)}\PYG{p}{,} \PYG{n}{axis}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,} \PYG{n}{axis}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}


\PYG{k}{def} \PYG{n+nf}{prefactor\PYGZus{}function\PYGZus{}derivative}\PYG{p}{(}\PYG{n}{control\PYGZus{}amplitudes}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{return} \PYG{n}{np}\PYG{o}{.}\PYG{n}{expand\PYGZus{}dims}\PYG{p}{(}\PYG{n}{gamma\PYGZus{}0} \PYG{o}{*} \PYG{n}{np}\PYG{o}{.}\PYG{n}{sign}\PYG{p}{(}\PYG{n}{control\PYGZus{}amplitudes}\PYG{p}{)}\PYG{p}{,} \PYG{n}{axis}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{)}
\end{sphinxVerbatim}
}

The prefactor function now returns the depolarization rate \(\gamma\), which is the squared amplitude of the lindblad operator. The simulation package assumes that the Lindblad operators can be given as constant operator \(L_k\), which is multiplied with a prefactor \(c_k\) to calculate the dissipation operator as:

\begin{align}
\mathcal{G} = \sum_k c_k (L_k^\ast \otimes L_k
- \frac{1}{2} I \otimes (L_k^\dagger L_k)
- \frac{1}{2} ( L_k^T L_k^\ast ) \otimes I)
\end{align}

The derivatives of the prefactor function must be implemented as well if the derivative of the cost function shall be calculated.

Now we can instantiate the solver and cost function.

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[3]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYG{k+kn}{from} \PYG{n+nn}{qsim}\PYG{n+nn}{.}\PYG{n+nn}{solver\PYGZus{}algorithms} \PYG{k+kn}{import} \PYG{n}{LindbladSolver}
\PYG{k+kn}{from} \PYG{n+nn}{qsim}\PYG{n+nn}{.}\PYG{n+nn}{cost\PYGZus{}functions} \PYG{k+kn}{import} \PYG{n}{OperationInfidelity}

\PYG{n}{total\PYGZus{}time} \PYG{o}{=} \PYG{l+m+mi}{1}
\PYG{n}{n\PYGZus{}time\PYGZus{}steps} \PYG{o}{=} \PYG{l+m+mi}{5}
\PYG{n}{time\PYGZus{}steps} \PYG{o}{=} \PYG{p}{(}\PYG{n}{total\PYGZus{}time} \PYG{o}{/} \PYG{n}{n\PYGZus{}time\PYGZus{}steps}\PYG{p}{)} \PYG{o}{*} \PYG{n}{np}\PYG{o}{.}\PYG{n}{ones}\PYG{p}{(}\PYG{p}{(}\PYG{n}{n\PYGZus{}time\PYGZus{}steps}\PYG{p}{,} \PYG{p}{)}\PYG{p}{)}

\PYG{n}{solver} \PYG{o}{=} \PYG{n}{LindbladSolver}\PYG{p}{(}
    \PYG{n}{h\PYGZus{}drift}\PYG{o}{=}\PYG{n}{h\PYGZus{}drift} \PYG{o}{*} \PYG{n}{n\PYGZus{}time\PYGZus{}steps}\PYG{p}{,}
    \PYG{n}{h\PYGZus{}ctrl}\PYG{o}{=}\PYG{n}{h\PYGZus{}ctrl}\PYG{p}{,}
    \PYG{n}{initial\PYGZus{}state}\PYG{o}{=}\PYG{n}{DenseOperator}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{eye}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{)}\PYG{p}{,}
    \PYG{n}{tau}\PYG{o}{=}\PYG{n}{time\PYGZus{}steps}\PYG{p}{,}
    \PYG{n}{lindblad\PYGZus{}operators}\PYG{o}{=}\PYG{n}{lindblad\PYGZus{}operators}\PYG{p}{,}
    \PYG{n}{prefactor\PYGZus{}function}\PYG{o}{=}\PYG{n}{prefactor\PYGZus{}function}\PYG{p}{,}
    \PYG{n}{prefactor\PYGZus{}derivative\PYGZus{}function}\PYG{o}{=}\PYG{n}{prefactor\PYGZus{}function\PYGZus{}derivative}
\PYG{p}{)}

\PYG{n}{x\PYGZus{}half} \PYG{o}{=} \PYG{n}{sigma\PYGZus{}x}\PYG{o}{.}\PYG{n}{exp}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{pi} \PYG{o}{*} \PYG{o}{.}\PYG{l+m+mi}{25}\PYG{n}{j}\PYG{p}{)}

\PYG{n}{entanglement\PYGZus{}infid} \PYG{o}{=} \PYG{n}{OperationInfidelity}\PYG{p}{(}
    \PYG{n}{solver}\PYG{o}{=}\PYG{n}{solver}\PYG{p}{,}
    \PYG{n}{target}\PYG{o}{=}\PYG{n}{x\PYGZus{}half}\PYG{p}{,}
    \PYG{n}{super\PYGZus{}operator\PYGZus{}formalism}\PYG{o}{=}\PYG{k+kc}{True}
\PYG{p}{)}

\end{sphinxVerbatim}
}

Please note that we have to set the option super\_operator\_formalism in the cost function to True. Next we optimize the control amplitudes.

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[24]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYG{k+kn}{from} \PYG{n+nn}{qsim}\PYG{n+nn}{.}\PYG{n+nn}{simulator} \PYG{k+kn}{import} \PYG{n}{Simulator}
\PYG{k+kn}{from} \PYG{n+nn}{qsim}\PYG{n+nn}{.}\PYG{n+nn}{optimize} \PYG{k+kn}{import} \PYG{n}{LeastSquaresOptimizer}
\PYG{n}{simulator} \PYG{o}{=} \PYG{n}{Simulator}\PYG{p}{(}
    \PYG{n}{solvers}\PYG{o}{=}\PYG{p}{[}\PYG{n}{solver}\PYG{p}{]}\PYG{p}{,}
    \PYG{n}{cost\PYGZus{}fktns}\PYG{o}{=}\PYG{p}{[}\PYG{n}{entanglement\PYGZus{}infid}\PYG{p}{]}
\PYG{p}{)}

\PYG{n}{termination\PYGZus{}conditions} \PYG{o}{=} \PYG{p}{\PYGZob{}}
    \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{min\PYGZus{}gradient\PYGZus{}norm}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mf}{1e\PYGZhy{}15}\PYG{p}{,}
    \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{min\PYGZus{}cost\PYGZus{}gain}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mf}{1e\PYGZhy{}15}\PYG{p}{,}
    \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{max\PYGZus{}wall\PYGZus{}time}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mf}{120.0}\PYG{p}{,}
    \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{max\PYGZus{}cost\PYGZus{}func\PYGZus{}calls}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mf}{1e6}\PYG{p}{,}
    \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{max\PYGZus{}iterations}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mi}{10000}\PYG{p}{,}
    \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{min\PYGZus{}amplitude\PYGZus{}change}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mf}{1e\PYGZhy{}8}
\PYG{p}{\PYGZcb{}}

\PYG{n}{upper\PYGZus{}bounds} \PYG{o}{=} \PYG{l+m+mi}{5} \PYG{o}{*} \PYG{l+m+mi}{2} \PYG{o}{*} \PYG{n}{np}\PYG{o}{.}\PYG{n}{pi} \PYG{o}{*} \PYG{n}{np}\PYG{o}{.}\PYG{n}{ones}\PYG{p}{(}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{h\PYGZus{}ctrl}\PYG{p}{)} \PYG{o}{*} \PYG{n}{n\PYGZus{}time\PYGZus{}steps}\PYG{p}{,} \PYG{p}{)}\PYG{p}{)}
\PYG{n}{lower\PYGZus{}bounds} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1} \PYG{o}{*} \PYG{n}{upper\PYGZus{}bounds}

\PYG{n}{optimizer} \PYG{o}{=} \PYG{n}{LeastSquaresOptimizer}\PYG{p}{(}
    \PYG{n}{system\PYGZus{}simulator}\PYG{o}{=}\PYG{n}{simulator}\PYG{p}{,}
    \PYG{n}{termination\PYGZus{}cond}\PYG{o}{=}\PYG{n}{termination\PYGZus{}conditions}\PYG{p}{,}
    \PYG{n}{save\PYGZus{}intermediary\PYGZus{}steps}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{,}
    \PYG{n}{bounds}\PYG{o}{=}\PYG{p}{[}\PYG{n}{lower\PYGZus{}bounds}\PYG{p}{,} \PYG{n}{upper\PYGZus{}bounds}\PYG{p}{]}
\PYG{p}{)}

\PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{seed}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}
\PYG{n}{initial\PYGZus{}pulse} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{pi} \PYG{o}{*} \PYG{l+m+mi}{2} \PYG{o}{*} \PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{rand}\PYG{p}{(}\PYG{n}{n\PYGZus{}time\PYGZus{}steps}\PYG{p}{,} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{h\PYGZus{}ctrl}\PYG{p}{)}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}\PYG{p}{)}

\PYG{n}{result} \PYG{o}{=} \PYG{n}{optimizer}\PYG{o}{.}\PYG{n}{run\PYGZus{}optimization}\PYG{p}{(}\PYG{n}{initial\PYGZus{}control\PYGZus{}amplitudes}\PYG{o}{=}\PYG{n}{initial\PYGZus{}pulse}\PYG{p}{)}
\PYG{n}{solver}\PYG{o}{.}\PYG{n}{set\PYGZus{}optimization\PYGZus{}parameters}\PYG{p}{(}\PYG{n}{result}\PYG{o}{.}\PYG{n}{final\PYGZus{}parameters}\PYG{p}{)}
\PYG{n}{solver}\PYG{o}{.}\PYG{n}{plot\PYGZus{}bloch\PYGZus{}sphere}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}
}

\hrule height -\fboxrule\relax
\vspace{\nbsphinxcodecellspacing}

\makeatletter\setbox\nbsphinxpromptbox\box\voidb@x\makeatother

\begin{nbsphinxfancyoutput}

\noindent\sphinxincludegraphics[width=374\sphinxpxdimen,height=374\sphinxpxdimen]{{examples_open_quantum_systems_7_0}.png}

\end{nbsphinxfancyoutput}

To verify that the implemented derivatives of the prefactor function is correct, we can compare our derivatives with finite differences. The convenience function compare\_numeric\_to\_analytic\_gradient calculates the absolute and relative difference to the finite difference gradient.

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[27]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYG{n}{simulator}\PYG{o}{.}\PYG{n}{compare\PYGZus{}numeric\PYGZus{}to\PYGZus{}analytic\PYGZus{}gradient}\PYG{p}{(}\PYG{n}{initial\PYGZus{}pulse}\PYG{p}{)}

\end{sphinxVerbatim}
}

{

\kern-\sphinxverbatimsmallskipamount\kern-\baselineskip
\kern+\FrameHeightAdjust\kern-\fboxrule
\vspace{\nbsphinxcodecellspacing}

\sphinxsetup{VerbatimColor={named}{white}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxout}[27]:\,\hspace{\fboxrule}\hspace{\fboxsep}}(1.633248503059409e-08, 9.851677024373317e-08)
\end{sphinxVerbatim}
}

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[1]:\,\hspace{\fboxrule}\hspace{\fboxsep}}\PYG{c+c1}{\PYGZsh{} different methods to store the control operator and calculate matrix}
\PYG{c+c1}{\PYGZsh{} exponential}

\end{sphinxVerbatim}
}

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[ ]:\,\hspace{\fboxrule}\hspace{\fboxsep}}

\end{sphinxVerbatim}
}

{
\sphinxsetup{VerbatimColor={named}{nbsphinx-code-bg}}
\sphinxsetup{VerbatimBorderColor={named}{nbsphinx-code-border}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\llap{\color{nbsphinxin}[ ]:\,\hspace{\fboxrule}\hspace{\fboxsep}}

\end{sphinxVerbatim}
}


\section{qsim package}
\label{\detokenize{qsim:qsim-package}}\label{\detokenize{qsim::doc}}

\subsection{Submodules}
\label{\detokenize{qsim:submodules}}

\subsection{qsim.amplitude\_function module}
\label{\detokenize{qsim:module-qsim.amplitude_functions}}\label{\detokenize{qsim:qsim-amplitude-function-module}}\index{module@\spxentry{module}!qsim.amplitude\_functions@\spxentry{qsim.amplitude\_functions}}\index{qsim.amplitude\_functions@\spxentry{qsim.amplitude\_functions}!module@\spxentry{module}}
This class is designed to express a functional relationship between the
optimization parameters, which can be directly controlled and the control
amplitudes, which appear as factors in the Hamiltonian.

If the Hamiltonian is given as sum of a drift Hamiltonian and a control
Hamiltonian described by operators multiplied with time dependent control
amplitudes
\begin{equation*}
\begin{split}H = H_{drift} + \sum_k u_k(t) H_k,\end{split}
\end{equation*}
then this class describes the control amplitudes as function of optimization
parameters:
\begin{equation*}
\begin{split}u_k(t) = u_k(x(t))\end{split}
\end{equation*}

\subsubsection{Classes}
\label{\detokenize{qsim:classes}}\begin{description}
\item[{{\hyperref[\detokenize{qsim:qsim.amplitude_functions.AmplitudeFunction}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{AmplitudeFunction}}}}}}] \leavevmode
Abstract base class of the amplitude function.

\item[{{\hyperref[\detokenize{qsim:qsim.amplitude_functions.IdentityAmpFunc}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{IdentityAmpFunc}}}}}}] \leavevmode
The transferred optimization parameters are the control amplitudes.

\item[{{\hyperref[\detokenize{qsim:qsim.amplitude_functions.UnaryAnalyticAmpFunc}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{UnaryAnalyticAmpFunc}}}}}}] \leavevmode
An amplitude function which can be given by a unary function.

\item[{{\hyperref[\detokenize{qsim:qsim.amplitude_functions.CustomAmpFunc}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{CustomAmpFunc}}}}}}] \leavevmode
Applies functions handles specified by the user at the initialization.

\end{description}

\begin{sphinxadmonition}{note}{Notes}

The implementation was inspired by the optimal control package of QuTiP \sphinxcite{qsim:r4a6e0c6bb1f9-1}
(Quantum Toolbox in Python)
\end{sphinxadmonition}
\subsubsection*{References}
\index{AmplitudeFunction (class in qsim.amplitude\_functions)@\spxentry{AmplitudeFunction}\spxextra{class in qsim.amplitude\_functions}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:qsim.amplitude_functions.AmplitudeFunction}}\pysigline{\sphinxbfcode{\sphinxupquote{class }}\sphinxbfcode{\sphinxupquote{AmplitudeFunction}}}
Bases: \sphinxcode{\sphinxupquote{abc.ABC}}

Abstract Base class of the amplitude function.
\index{derivative\_by\_chain\_rule() (AmplitudeFunction method)@\spxentry{derivative\_by\_chain\_rule()}\spxextra{AmplitudeFunction method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:qsim.amplitude_functions.AmplitudeFunction.derivative_by_chain_rule}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{abstract }}\sphinxbfcode{\sphinxupquote{derivative\_by\_chain\_rule}}}{\emph{\DUrole{n}{self}}, \emph{\DUrole{n}{deriv\_by\_ctrl\_amps}}, \emph{\DUrole{n}{x}}}{}
Calculates the derivatives of some function f by the optimization
parameters x, when given the optimization parameters x and the
derivative by the control amplitudes. The calculation is performed
using the chain rule: df/dx = df/du * du/dx.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{deriv\_by\_ctrl\_amps}} (\sphinxstyleliteralemphasis{\sphinxupquote{np.array}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{shape}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{num\_t}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{num\_f}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{num\_ctrl}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} The gradients of num\_f functions by num\_ctrl different pulses at
num\_t different time steps, i.e. the derivatives df/du.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{x}} (\sphinxstyleliteralemphasis{\sphinxupquote{np.array}}) \textendash{} Optimization parameters of shape (num\_t, num\_par), where num\_t is
the number of time slices and num\_par the number of different
optimization parameters.

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxstylestrong{deriv\_by\_opt\_par} \textendash{} The derivatives by the optimization parameters.

\item[{Return type}] \leavevmode
np.array, shape: (num\_t, num\_f, num\_par)

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{CustomAmpFunc (class in qsim.amplitude\_functions)@\spxentry{CustomAmpFunc}\spxextra{class in qsim.amplitude\_functions}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:qsim.amplitude_functions.CustomAmpFunc}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxbfcode{\sphinxupquote{CustomAmpFunc}}}{\emph{\DUrole{n}{value\_function}\DUrole{p}{:} \DUrole{n}{Callable\DUrole{p}{{[}}\DUrole{p}{{[}}numpy.ndarray\DUrole{p}{{]}}\DUrole{p}{, }numpy.ndarray\DUrole{p}{{]}}}}, \emph{\DUrole{n}{derivative\_function}\DUrole{p}{:} \DUrole{n}{Callable\DUrole{p}{{[}}\DUrole{p}{{[}}numpy.ndarray\DUrole{p}{{]}}\DUrole{p}{, }numpy.ndarray\DUrole{p}{{]}}}}}{}
Bases: {\hyperref[\detokenize{qsim:qsim.amplitude_functions.AmplitudeFunction}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{qsim.amplitude\_functions.AmplitudeFunction}}}}}

A general amplitude function which is applied to the amplitude
values.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{value\_function}} (\sphinxstyleliteralemphasis{\sphinxupquote{Callable array to array}}) \textendash{} This function expresses the functional dependency of the control
amplitudes on the optimization parameters. The function receives the
optimization parameters x as array of the shape (num\_t, num\_par) and
must return the control amplitudes u as array of the shape
(num\_t, num\_ctrl). Where num\_t is the number of time slices,
num\_par the number of optimization parameters and num\_ctrl the number
of control operators in the Hamiltonian.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{derivative\_function}} (\sphinxstyleliteralemphasis{\sphinxupquote{Callable array to array}}) \textendash{} This function describes the derivative of the control amplitudes by the
optimization parameters.
The function receives the optimisation parameters x as array
of shape (num\_t, num\_par) and must return the derivatives of the
control amplitudes by the optimization parameters as array of shape
(num\_t, num\_par, num\_ctrl).

\end{itemize}

\end{description}\end{quote}
\index{derivative\_by\_chain\_rule() (CustomAmpFunc method)@\spxentry{derivative\_by\_chain\_rule()}\spxextra{CustomAmpFunc method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:qsim.amplitude_functions.CustomAmpFunc.derivative_by_chain_rule}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{derivative\_by\_chain\_rule}}}{\emph{\DUrole{n}{self}}, \emph{\DUrole{n}{deriv\_by\_ctrl\_amps}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}, \emph{\DUrole{n}{x}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}}{{ $\rightarrow$ numpy.ndarray}}
See base class.

\end{fulllineitems}


\end{fulllineitems}

\index{IdentityAmpFunc (class in qsim.amplitude\_functions)@\spxentry{IdentityAmpFunc}\spxextra{class in qsim.amplitude\_functions}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:qsim.amplitude_functions.IdentityAmpFunc}}\pysigline{\sphinxbfcode{\sphinxupquote{class }}\sphinxbfcode{\sphinxupquote{IdentityAmpFunc}}}
Bases: {\hyperref[\detokenize{qsim:qsim.amplitude_functions.AmplitudeFunction}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{qsim.amplitude\_functions.AmplitudeFunction}}}}}

The control amplitudes are identical with the optimization parameters.
\index{derivative\_by\_chain\_rule() (IdentityAmpFunc method)@\spxentry{derivative\_by\_chain\_rule()}\spxextra{IdentityAmpFunc method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:qsim.amplitude_functions.IdentityAmpFunc.derivative_by_chain_rule}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{derivative\_by\_chain\_rule}}}{\emph{\DUrole{n}{self}}, \emph{\DUrole{n}{deriv\_by\_ctrl\_amps}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}, \emph{\DUrole{n}{x}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}}{{ $\rightarrow$ numpy.ndarray}}
See base class.

\end{fulllineitems}


\end{fulllineitems}

\index{UnaryAnalyticAmpFunc (class in qsim.amplitude\_functions)@\spxentry{UnaryAnalyticAmpFunc}\spxextra{class in qsim.amplitude\_functions}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:qsim.amplitude_functions.UnaryAnalyticAmpFunc}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxbfcode{\sphinxupquote{UnaryAnalyticAmpFunc}}}{\emph{\DUrole{n}{value\_function}\DUrole{p}{:} \DUrole{n}{Callable\DUrole{p}{{[}}\DUrole{p}{{[}}float\DUrole{p}{{]}}\DUrole{p}{, }float\DUrole{p}{{]}}}}, \emph{\DUrole{n}{derivative\_function}\DUrole{p}{:} \DUrole{n}{Callable\DUrole{p}{{[}}\DUrole{p}{{[}}float\DUrole{p}{{]}}\DUrole{p}{, }float\DUrole{p}{{]}}}}}{}
Bases: {\hyperref[\detokenize{qsim:qsim.amplitude_functions.AmplitudeFunction}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{qsim.amplitude\_functions.AmplitudeFunction}}}}}

A unary analytic amplitude function which is applied to each amplitude
value. This class can be used for every application case where all
transferred parameters are mapped one\sphinxhyphen{}to\sphinxhyphen{}one to the control amplitudes
by a single unary function.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{value\_function}} (\sphinxstyleliteralemphasis{\sphinxupquote{Callable float to float}}) \textendash{} This scalar function expresses the functional dependency of the control
amplitudes on the optimization parameters. The function is vectorized
internally.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{derivative\_function}} (\sphinxstyleliteralemphasis{\sphinxupquote{Callable float to float}}) \textendash{} This scalar function describes the derivative of the control
amplitudes. The function is vectorized internally.

\end{itemize}

\end{description}\end{quote}
\index{derivative\_by\_chain\_rule() (UnaryAnalyticAmpFunc method)@\spxentry{derivative\_by\_chain\_rule()}\spxextra{UnaryAnalyticAmpFunc method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:qsim.amplitude_functions.UnaryAnalyticAmpFunc.derivative_by_chain_rule}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{derivative\_by\_chain\_rule}}}{\emph{\DUrole{n}{self}}, \emph{\DUrole{n}{deriv\_by\_ctrl\_amps}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}, \emph{\DUrole{n}{x}}}{}
See base class.

\end{fulllineitems}


\end{fulllineitems}



\subsection{qsim.analyser module}
\label{\detokenize{qsim:module-qsim.analyser}}\label{\detokenize{qsim:qsim-analyser-module}}\index{module@\spxentry{module}!qsim.analyser@\spxentry{qsim.analyser}}\index{qsim.analyser@\spxentry{qsim.analyser}!module@\spxentry{module}}
This file contains some functions for the analysis of the optimization.


\subsubsection{Classes}
\label{\detokenize{qsim:id2}}\begin{description}
\item[{{\hyperref[\detokenize{qsim:qsim.analyser.Analyser}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Analyser}}}}}}] \leavevmode
Holds convenience functions to visualize the optimization.

\end{description}

\begin{sphinxadmonition}{note}{Notes}

The implementation was inspired by the optimal control package of QuTiP \sphinxcite{qsim:r60048f1bd449-1}
(Quantum Toolbox in Python)
\end{sphinxadmonition}
\subsubsection*{References}
\index{Analyser (class in qsim.analyser)@\spxentry{Analyser}\spxextra{class in qsim.analyser}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:qsim.analyser.Analyser}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxbfcode{\sphinxupquote{Analyser}}}{\emph{\DUrole{n}{data}\DUrole{p}{:} \DUrole{n}{{\hyperref[\detokenize{qsim:qsim.data_container.DataContainer}]{\sphinxcrossref{qsim.data\_container.DataContainer}}}}}}{}
Bases: \sphinxcode{\sphinxupquote{object}}

Holds convenience functions to visualize the optimization.

The Analyser class can be used to make plots of the optimization data
stored in an instance of the DataContainer class. This can be useful to
judge the performance of optimization algorithms and investigate how fast
the convergence is and whether the algorithm has fully converged.
\index{integral\_cost\_fkt\_times() (Analyser method)@\spxentry{integral\_cost\_fkt\_times()}\spxextra{Analyser method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:qsim.analyser.Analyser.integral_cost_fkt_times}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{integral\_cost\_fkt\_times}}}{\emph{\DUrole{n}{self}}, \emph{\DUrole{n}{n}\DUrole{p}{:} \DUrole{n}{int} \DUrole{o}{=} \DUrole{default_value}{0}}}{{ $\rightarrow$ numpy.ndarray}}
Sum of the time required for the evaluation of the cost
function.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{n}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} Number of the optimization run. Defaults to 0.

\item[{Returns}] \leavevmode
\sphinxstylestrong{integral\_times} \textendash{} Integrated time required for the cost function evaluation.

\item[{Return type}] \leavevmode
np.array

\end{description}\end{quote}

\end{fulllineitems}

\index{integral\_grad\_fkt\_times() (Analyser method)@\spxentry{integral\_grad\_fkt\_times()}\spxextra{Analyser method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:qsim.analyser.Analyser.integral_grad_fkt_times}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{integral\_grad\_fkt\_times}}}{\emph{\DUrole{n}{self}}, \emph{\DUrole{n}{n}\DUrole{p}{:} \DUrole{n}{int} \DUrole{o}{=} \DUrole{default_value}{0}}}{}
Sum of the time required for the evaluation of the cost
function gradients.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{n}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} Number of the optimization run. Defaults to 0.

\item[{Returns}] \leavevmode
\sphinxstylestrong{integral\_times} \textendash{} Integrated time required for the cost function gradient evaluation.

\item[{Return type}] \leavevmode
np.array

\end{description}\end{quote}

\end{fulllineitems}

\index{n\_least\_square() (Analyser property)@\spxentry{n\_least\_square()}\spxextra{Analyser property}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:qsim.analyser.Analyser.n_least_square}}\pysigline{\sphinxbfcode{\sphinxupquote{property }}\sphinxbfcode{\sphinxupquote{n\_least\_square}}}
Returns the number of the optimization run which yields the smallest
total costs.

The total cost is measured as squared sum of the final cost function
values.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxstylestrong{n\_least\_square} \textendash{} Number of optimization run with smallest final costs.

\item[{Return type}] \leavevmode
int

\end{description}\end{quote}

\end{fulllineitems}

\index{opt\_times() (Analyser method)@\spxentry{opt\_times()}\spxextra{Analyser method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:qsim.analyser.Analyser.opt_times}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{opt\_times}}}{\emph{\DUrole{n}{self}}}{}
Total optimization times.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxstylestrong{total\_times} \textendash{} Time required per optimization run.

\item[{Return type}] \leavevmode
np.array

\end{description}\end{quote}

\end{fulllineitems}

\index{plot\_absolute\_costs() (Analyser method)@\spxentry{plot\_absolute\_costs()}\spxextra{Analyser method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:qsim.analyser.Analyser.plot_absolute_costs}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{plot\_absolute\_costs}}}{\emph{\DUrole{n}{self}}}{{ $\rightarrow$ None}}
Plots the absolute costs.

\end{fulllineitems}

\index{plot\_costs() (Analyser method)@\spxentry{plot\_costs()}\spxextra{Analyser method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:qsim.analyser.Analyser.plot_costs}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{plot\_costs}}}{\emph{\DUrole{n}{self}}, \emph{\DUrole{n}{n}\DUrole{o}{=}\DUrole{default_value}{0}}}{{ $\rightarrow$ None}}
Plots the absolute cost values as function of optimization
iteration.

\end{fulllineitems}

\index{time\_share\_cost\_fkt() (Analyser method)@\spxentry{time\_share\_cost\_fkt()}\spxextra{Analyser method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:qsim.analyser.Analyser.time_share_cost_fkt}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{time\_share\_cost\_fkt}}}{\emph{\DUrole{n}{self}}}{}
Time share of the cost function evaluation.

\end{fulllineitems}

\index{time\_share\_grad\_fkt() (Analyser method)@\spxentry{time\_share\_grad\_fkt()}\spxextra{Analyser method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:qsim.analyser.Analyser.time_share_grad_fkt}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{time\_share\_grad\_fkt}}}{\emph{\DUrole{n}{self}}}{}
Time share of the cost function gradient calculation.

\end{fulllineitems}

\index{total\_cost\_fkt\_time() (Analyser method)@\spxentry{total\_cost\_fkt\_time()}\spxextra{Analyser method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:qsim.analyser.Analyser.total_cost_fkt_time}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{total\_cost\_fkt\_time}}}{\emph{\DUrole{n}{self}}}{}
Total time of cost function evaluation.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxstylestrong{total\_t} \textendash{} Total times for the evaluation of cost functions.

\item[{Return type}] \leavevmode
np.array

\end{description}\end{quote}

\end{fulllineitems}

\index{total\_grad\_fkt\_time() (Analyser method)@\spxentry{total\_grad\_fkt\_time()}\spxextra{Analyser method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:qsim.analyser.Analyser.total_grad_fkt_time}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{total\_grad\_fkt\_time}}}{\emph{\DUrole{n}{self}}}{}
Total time of cost function gradient calculation.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxstylestrong{total\_t} \textendash{} Total times for the calculation of cost functions gradients.

\item[{Return type}] \leavevmode
np.array

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\subsection{qsim.cost\_functions module}
\label{\detokenize{qsim:module-qsim.cost_functions}}\label{\detokenize{qsim:qsim-cost-functions-module}}\index{module@\spxentry{module}!qsim.cost\_functions@\spxentry{qsim.cost\_functions}}\index{qsim.cost\_functions@\spxentry{qsim.cost\_functions}!module@\spxentry{module}}
Cost functions which can be minimised in the control optimization.

These classes evaluate the cost function which describe the quantum system
under simulation. This can be for example the infidelity of a quantum channel.
To support gradient based optimization algorithms such as quasi\sphinxhyphen{}Newton type
algorithms the classes also calculate the gradients of the cost functions.
(Jacobians in case of vector valued cost functions.)


\subsubsection{Classes}
\label{\detokenize{qsim:id4}}\begin{description}
\item[{{\hyperref[\detokenize{qsim:qsim.cost_functions.CostFunction}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{CostFunction}}}}}}] \leavevmode
Abstract base class of the fidelity computer.

\item[{{\hyperref[\detokenize{qsim:qsim.cost_functions.OperatorMatrixNorm}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{OperatorMatrixNorm}}}}}}] \leavevmode
Calculates the cost as matrix norm of the difference between the actual
evolution and the target.

\item[{{\hyperref[\detokenize{qsim:qsim.cost_functions.OperationInfidelity}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{OperationInfidelity}}}}}}] \leavevmode
Calculates the cost as operation infidelity of a propagator.

\item[{{\hyperref[\detokenize{qsim:qsim.cost_functions.OperationNoiseInfidelity}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{OperationNoiseInfidelity}}}}}}] \leavevmode
Like Operationfidelity but averaged over noise traces.

\item[{{\hyperref[\detokenize{qsim:qsim.cost_functions.OperatorFilterFunctionInfidelity}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{OperatorFilterFunctionInfidelity}}}}}}] \leavevmode
Estimates infidelities with filter functions.

\item[{{\hyperref[\detokenize{qsim:qsim.cost_functions.LeakageError}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{LeakageError}}}}}}] \leavevmode
Estimates the leakage of quantum gates.

\end{description}


\subsubsection{Functions}
\label{\detokenize{qsim:functions}}\begin{description}
\item[{{\hyperref[\detokenize{qsim:qsim.cost_functions.angle_axis_representation}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{angle\_axis\_representation()}}}}}}] \leavevmode
Calculates the representation of a 2x2 unitary matrix as rotation axis and
angle.

\item[{{\hyperref[\detokenize{qsim:qsim.cost_functions.entanglement_fidelity}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{entanglement\_fidelity()}}}}}}] \leavevmode
Calculates the entanglement fidelity between a unitary target evolution and
a simulated unitary evolution.

\item[{{\hyperref[\detokenize{qsim:qsim.cost_functions.deriv_entanglement_fid_sup_op_with_du}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{deriv\_entanglement\_fid\_sup\_op\_with\_du()}}}}}}] \leavevmode
Calculates the derivatives of the entanglement fidelity with respect to
the control amplitudes.

\item[{{\hyperref[\detokenize{qsim:qsim.cost_functions.entanglement_fidelity_super_operator}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{entanglement\_fidelity\_super\_operator()}}}}}}] \leavevmode
Calculates the entanglement fidelity between two propagators in the super
operator formalism.

\item[{{\hyperref[\detokenize{qsim:qsim.cost_functions.derivative_entanglement_fidelity_with_du}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{derivative\_entanglement\_fidelity\_with\_du()}}}}}}] \leavevmode
Calculates the derivatives of the entanglement fidelity in the super
operator formalism with respect to the control amplitudes.

\end{description}

\begin{sphinxadmonition}{note}{Notes}

The implementation was inspired by the optimal control package of QuTiP \sphinxcite{qsim:r5b9320e02ee3-1}
(Quantum Toolbox in Python)
\end{sphinxadmonition}
\subsubsection*{References}
\index{CostFunction (class in qsim.cost\_functions)@\spxentry{CostFunction}\spxextra{class in qsim.cost\_functions}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:qsim.cost_functions.CostFunction}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxbfcode{\sphinxupquote{CostFunction}}}{\emph{\DUrole{n}{solver}\DUrole{p}{:} \DUrole{n}{{\hyperref[\detokenize{qsim:qsim.solver_algorithms.Solver}]{\sphinxcrossref{qsim.solver\_algorithms.Solver}}}}}, \emph{\DUrole{n}{index}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}List\DUrole{p}{{[}}str\DUrole{p}{{]}}\DUrole{p}{{]}}} \DUrole{o}{=} \DUrole{default_value}{None}}}{}
Bases: \sphinxcode{\sphinxupquote{abc.ABC}}

Abstract base class of the fidelity computer.
\index{solver (CostFunction attribute)@\spxentry{solver}\spxextra{CostFunction attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:qsim.cost_functions.CostFunction.solver}}\pysigline{\sphinxbfcode{\sphinxupquote{solver}}}
Object that compute the forward/backward evolution and propagator.
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
\sphinxtitleref{Solver}

\end{description}\end{quote}

\end{fulllineitems}

\index{index (CostFunction attribute)@\spxentry{index}\spxextra{CostFunction attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:qsim.cost_functions.CostFunction.index}}\pysigline{\sphinxbfcode{\sphinxupquote{index}}}
Indices of the returned infidelities for distinction in the analysis.
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
list of str

\end{description}\end{quote}

\end{fulllineitems}

\index{costs() (CostFunction method)@\spxentry{costs()}\spxextra{CostFunction method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:qsim.cost_functions.CostFunction.costs}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{costs}}}{}{}
Evaluates the cost function.

\end{fulllineitems}

\index{grad() (CostFunction method)@\spxentry{grad()}\spxextra{CostFunction method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:qsim.cost_functions.CostFunction.grad}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{grad}}}{}{}
Calculates the gradient or Jacobian of the cost function.

\end{fulllineitems}

\index{costs() (CostFunction method)@\spxentry{costs()}\spxextra{CostFunction method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:id0}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{abstract }}\sphinxbfcode{\sphinxupquote{costs}}}{\emph{\DUrole{n}{self}}}{{ $\rightarrow$ Union\DUrole{p}{{[}}float\DUrole{p}{, }numpy.ndarray\DUrole{p}{{]}}}}
Evaluates the cost function.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxstylestrong{costs} \textendash{} Result of the cost function’s evaluation.

\item[{Return type}] \leavevmode
np.array or float

\end{description}\end{quote}

\end{fulllineitems}

\index{grad() (CostFunction method)@\spxentry{grad()}\spxextra{CostFunction method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:id6}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{abstract }}\sphinxbfcode{\sphinxupquote{grad}}}{\emph{\DUrole{n}{self}}}{{ $\rightarrow$ numpy.ndarray}}
Calculates the gradient or Jacobian of the cost function.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxstylestrong{gradient} \textendash{} shape: (num\_t, num\_ctrl, num\_f) where num\_t is the number of time
slices, num\_ctrl the number of control parameters and num\_f the
number of values returned by the cost function. Derivatives of
the cost function by the control amplitudes.

\item[{Return type}] \leavevmode
np.array

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{LeakageError (class in qsim.cost\_functions)@\spxentry{LeakageError}\spxextra{class in qsim.cost\_functions}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:qsim.cost_functions.LeakageError}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxbfcode{\sphinxupquote{LeakageError}}}{\emph{\DUrole{n}{solver}\DUrole{p}{:} \DUrole{n}{{\hyperref[\detokenize{qsim:qsim.solver_algorithms.Solver}]{\sphinxcrossref{qsim.solver\_algorithms.Solver}}}}}, \emph{\DUrole{n}{computational\_states}\DUrole{p}{:} \DUrole{n}{List\DUrole{p}{{[}}int\DUrole{p}{{]}}}}, \emph{\DUrole{n}{index}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}List\DUrole{p}{{[}}str\DUrole{p}{{]}}\DUrole{p}{{]}}} \DUrole{o}{=} \DUrole{default_value}{None}}}{}
Bases: {\hyperref[\detokenize{qsim:qsim.cost_functions.CostFunction}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{qsim.cost\_functions.CostFunction}}}}}

This class measures leakage as quantum operation error.

The resulting infidelity is measured by truncating the leakage states of
the propagator U yielding the Propagator V on the computational basis. The
infidelity is then given as the distance from unitarity:
infid = 1 \sphinxhyphen{} trace(V\textasciicircum{}dag V) / 4
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{solver}} (\sphinxstyleliteralemphasis{\sphinxupquote{TimeSlotComputer}}) \textendash{} The time slot computer computing the propagation of the system.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{computational\_states}} (\sphinxstyleliteralemphasis{\sphinxupquote{list of int}}) \textendash{} List of indices marking the computational states of the propagator.
These are all but the leakage states.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{index}} (\sphinxstyleliteralemphasis{\sphinxupquote{list of str}}) \textendash{} Indices of the returned infidelities for distinction in the analysis.

\end{itemize}

\end{description}\end{quote}
\index{costs() (LeakageError method)@\spxentry{costs()}\spxextra{LeakageError method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:qsim.cost_functions.LeakageError.costs}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{costs}}}{\emph{\DUrole{n}{self}}}{}
See base class.

\end{fulllineitems}

\index{grad() (LeakageError method)@\spxentry{grad()}\spxextra{LeakageError method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:qsim.cost_functions.LeakageError.grad}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{grad}}}{\emph{\DUrole{n}{self}}}{}
See base class.

\end{fulllineitems}


\end{fulllineitems}

\index{OperationInfidelity (class in qsim.cost\_functions)@\spxentry{OperationInfidelity}\spxextra{class in qsim.cost\_functions}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:qsim.cost_functions.OperationInfidelity}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxbfcode{\sphinxupquote{OperationInfidelity}}}{\emph{\DUrole{n}{solver}\DUrole{p}{:} \DUrole{n}{{\hyperref[\detokenize{qsim:qsim.solver_algorithms.Solver}]{\sphinxcrossref{qsim.solver\_algorithms.Solver}}}}}, \emph{\DUrole{n}{target}\DUrole{p}{:} \DUrole{n}{{\hyperref[\detokenize{qsim:qsim.matrix.OperatorMatrix}]{\sphinxcrossref{qsim.matrix.OperatorMatrix}}}}}, \emph{\DUrole{n}{fidelity\_measure}\DUrole{p}{:} \DUrole{n}{str} \DUrole{o}{=} \DUrole{default_value}{\textquotesingle{}entanglement\textquotesingle{}}}, \emph{\DUrole{n}{super\_operator\_formalism}\DUrole{p}{:} \DUrole{n}{bool} \DUrole{o}{=} \DUrole{default_value}{False}}, \emph{\DUrole{n}{index}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}List\DUrole{p}{{[}}str\DUrole{p}{{]}}\DUrole{p}{{]}}} \DUrole{o}{=} \DUrole{default_value}{None}}, \emph{\DUrole{n}{computational\_states}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}List\DUrole{p}{{[}}int\DUrole{p}{{]}}\DUrole{p}{{]}}} \DUrole{o}{=} \DUrole{default_value}{None}}, \emph{\DUrole{n}{map\_to\_closest\_unitary}\DUrole{p}{:} \DUrole{n}{bool} \DUrole{o}{=} \DUrole{default_value}{False}}}{}
Bases: {\hyperref[\detokenize{qsim:qsim.cost_functions.CostFunction}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{qsim.cost\_functions.CostFunction}}}}}

Calculates the infidelity of a quantum channel.

The infidelity of a quantum channel described by a unitary evolution or
propagator in the master equation formalism.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{solver}} (\sphinxtitleref{Solver}) \textendash{} The time slot computer simulating the systems dynamics.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{target}} (\sphinxtitleref{ControlMatrix}) \textendash{} Unitary target evolution.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{index}} (\sphinxstyleliteralemphasis{\sphinxupquote{list of str}}) \textendash{} Indices of the returned infidelities for distinction in the analysis.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{fidelity\_measure}} (\sphinxstyleliteralemphasis{\sphinxupquote{string}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} If ‘entanglement’: the entanglement fidelity is calculated.
Otherwise an error is raised.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{super\_operator\_formalism}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} If true, the time slot computer is expected to return a propagator in
the super operator formalism, while the target unitary is not given as
super operator.
If false, no super operators are assumed.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{computational\_states}} (\sphinxstyleliteralemphasis{\sphinxupquote{list of int}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} If set, the chosen fidelity is only calculated for the specified
subspace.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{map\_to\_closest\_unitary}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} If True, then the final propagator is mapped to the closest unitary
before the infidelity is evaluated.

\end{itemize}

\end{description}\end{quote}
\index{solver (OperationInfidelity attribute)@\spxentry{solver}\spxextra{OperationInfidelity attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:qsim.cost_functions.OperationInfidelity.solver}}\pysigline{\sphinxbfcode{\sphinxupquote{solver}}}
The time slot computer simulating the systems dynamics.
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
TimeSlotComputer

\end{description}\end{quote}

\end{fulllineitems}

\index{target (OperationInfidelity attribute)@\spxentry{target}\spxextra{OperationInfidelity attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:qsim.cost_functions.OperationInfidelity.target}}\pysigline{\sphinxbfcode{\sphinxupquote{target}}}
Unitary target evolution.
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
ControlMatrix

\end{description}\end{quote}

\end{fulllineitems}

\index{fidelity\_measure (OperationInfidelity attribute)@\spxentry{fidelity\_measure}\spxextra{OperationInfidelity attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:qsim.cost_functions.OperationInfidelity.fidelity_measure}}\pysigline{\sphinxbfcode{\sphinxupquote{fidelity\_measure}}}
If ‘entanglement’: the entanglement fidelity is calculated.
Otherwise an error is raised.
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
string

\end{description}\end{quote}

\end{fulllineitems}

\index{super\_operator\_formalism (OperationInfidelity attribute)@\spxentry{super\_operator\_formalism}\spxextra{OperationInfidelity attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:qsim.cost_functions.OperationInfidelity.super_operator_formalism}}\pysigline{\sphinxbfcode{\sphinxupquote{super\_operator\_formalism}}}
If true, the time slot computer is expected to return a propagator in
the super operator formalism, while the target unitary is not given as
super operator.
If false, no super operators are assumed.
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
bool

\end{description}\end{quote}

\end{fulllineitems}

\begin{quote}\begin{description}
\item[{Raises}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{NotImplementedError}} \textendash{} If the fidelity measure is not ‘entanglement’.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{Todo:}} \textendash{} \begin{itemize}
\item {} 
add the average fidelity? or remove the fidelity\_measure.

\end{itemize}


\end{itemize}

\end{description}\end{quote}
\index{costs() (OperationInfidelity method)@\spxentry{costs()}\spxextra{OperationInfidelity method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:qsim.cost_functions.OperationInfidelity.costs}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{costs}}}{\emph{\DUrole{n}{self}}}{{ $\rightarrow$ float}}
Calculates the costs by the selected fidelity measure.

\end{fulllineitems}

\index{grad() (OperationInfidelity method)@\spxentry{grad()}\spxextra{OperationInfidelity method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:qsim.cost_functions.OperationInfidelity.grad}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{grad}}}{\emph{\DUrole{n}{self}}}{{ $\rightarrow$ numpy.ndarray}}
Calculates the derivatives of the selected fidelity measure with
respect to the control amplitudes.

\end{fulllineitems}


\end{fulllineitems}

\index{OperationNoiseInfidelity (class in qsim.cost\_functions)@\spxentry{OperationNoiseInfidelity}\spxextra{class in qsim.cost\_functions}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:qsim.cost_functions.OperationNoiseInfidelity}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxbfcode{\sphinxupquote{OperationNoiseInfidelity}}}{\emph{\DUrole{n}{solver}\DUrole{p}{:} \DUrole{n}{{\hyperref[\detokenize{qsim:qsim.solver_algorithms.SchroedingerSMonteCarlo}]{\sphinxcrossref{qsim.solver\_algorithms.SchroedingerSMonteCarlo}}}}}, \emph{\DUrole{n}{target}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}{\hyperref[\detokenize{qsim:qsim.matrix.OperatorMatrix}]{\sphinxcrossref{qsim.matrix.OperatorMatrix}}}\DUrole{p}{{]}}}}, \emph{\DUrole{n}{index}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}List\DUrole{p}{{[}}str\DUrole{p}{{]}}\DUrole{p}{{]}}} \DUrole{o}{=} \DUrole{default_value}{None}}, \emph{\DUrole{n}{fidelity\_measure}\DUrole{p}{:} \DUrole{n}{str} \DUrole{o}{=} \DUrole{default_value}{\textquotesingle{}entanglement\textquotesingle{}}}, \emph{\DUrole{n}{computational\_states}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}List\DUrole{p}{{[}}int\DUrole{p}{{]}}\DUrole{p}{{]}}} \DUrole{o}{=} \DUrole{default_value}{None}}, \emph{\DUrole{n}{map\_to\_closest\_unitary}\DUrole{p}{:} \DUrole{n}{bool} \DUrole{o}{=} \DUrole{default_value}{False}}, \emph{\DUrole{n}{neglect\_systematic\_errors}\DUrole{p}{:} \DUrole{n}{bool} \DUrole{o}{=} \DUrole{default_value}{True}}}{}
Bases: {\hyperref[\detokenize{qsim:qsim.cost_functions.CostFunction}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{qsim.cost\_functions.CostFunction}}}}}

Averages the operator fidelity over noise traces.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{solver}} (\sphinxtitleref{Solver}) \textendash{} The time slot computer simulating the systems dynamics.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{target}} (\sphinxtitleref{ControlMatrix}) \textendash{} Unitary target evolution.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{index}} (\sphinxstyleliteralemphasis{\sphinxupquote{list of str}}) \textendash{} Indices of the returned infidelities for distinction in the analysis.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{fidelity\_measure}} (\sphinxstyleliteralemphasis{\sphinxupquote{string}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} If ‘entanglement’: the entanglement fidelity is calculated.
Otherwise an error is raised.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{computational\_states}} (\sphinxstyleliteralemphasis{\sphinxupquote{list of int}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} If set, the chosen fidelity is only calculated for the specified
subspace.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{map\_to\_closest\_unitary}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} If True, then the final propagator is mapped to the closest unitary
before the infidelity is evaluated.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{neglect\_systematic\_errors}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}) \textendash{} If true, the mean operator fidelity is calculated with respect to the
simulated propagator without statistical noise.
Otherwise the mean operator fidelity is calculated with respect to the
target propagator.

\end{itemize}

\end{description}\end{quote}
\index{neglect\_systematic\_errors (OperationNoiseInfidelity attribute)@\spxentry{neglect\_systematic\_errors}\spxextra{OperationNoiseInfidelity attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:qsim.cost_functions.OperationNoiseInfidelity.neglect_systematic_errors}}\pysigline{\sphinxbfcode{\sphinxupquote{neglect\_systematic\_errors}}}
If true, the standard deviation of the operator fidelity is measured.
Otherwise the mean operator fidelity is calculated with respect to the
target propagator.
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
bool

\end{description}\end{quote}

\end{fulllineitems}

\index{costs() (OperationNoiseInfidelity method)@\spxentry{costs()}\spxextra{OperationNoiseInfidelity method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:qsim.cost_functions.OperationNoiseInfidelity.costs}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{costs}}}{\emph{\DUrole{n}{self}}}{}
See base class.

\end{fulllineitems}

\index{grad() (OperationNoiseInfidelity method)@\spxentry{grad()}\spxextra{OperationNoiseInfidelity method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:qsim.cost_functions.OperationNoiseInfidelity.grad}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{grad}}}{\emph{\DUrole{n}{self}}}{}
See base class.

\end{fulllineitems}


\end{fulllineitems}

\index{OperatorFilterFunctionInfidelity (class in qsim.cost\_functions)@\spxentry{OperatorFilterFunctionInfidelity}\spxextra{class in qsim.cost\_functions}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:qsim.cost_functions.OperatorFilterFunctionInfidelity}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxbfcode{\sphinxupquote{OperatorFilterFunctionInfidelity}}}{\emph{\DUrole{n}{solver}\DUrole{p}{:} \DUrole{n}{{\hyperref[\detokenize{qsim:qsim.solver_algorithms.Solver}]{\sphinxcrossref{qsim.solver\_algorithms.Solver}}}}}, \emph{\DUrole{n}{noise\_power\_spec\_density}\DUrole{p}{:} \DUrole{n}{Union\DUrole{p}{{[}}Sequence\DUrole{p}{{[}}float\DUrole{p}{{]}}\DUrole{p}{, }Callable\DUrole{p}{{]}}}}, \emph{\DUrole{n}{omega}\DUrole{p}{:} \DUrole{n}{Union\DUrole{p}{{[}}Sequence\DUrole{p}{{[}}float\DUrole{p}{{]}}\DUrole{p}{, }Dict\DUrole{p}{{[}}str\DUrole{p}{, }Union\DUrole{p}{{[}}int\DUrole{p}{, }str\DUrole{p}{{]}}\DUrole{p}{{]}}\DUrole{p}{{]}}}}, \emph{\DUrole{n}{index}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}List\DUrole{p}{{[}}str\DUrole{p}{{]}}\DUrole{p}{{]}}} \DUrole{o}{=} \DUrole{default_value}{None}}}{}
Bases: {\hyperref[\detokenize{qsim:qsim.cost_functions.CostFunction}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{qsim.cost\_functions.CostFunction}}}}}

Calculates the infidelity with the filter function formalism.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{solver}} (\sphinxtitleref{Solver}) \textendash{} The time slot computer simulating the systems dynamics.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{index}} (\sphinxstyleliteralemphasis{\sphinxupquote{list of str}}) \textendash{} Indices of the returned infidelities for distinction in the analysis.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{noise\_power\_spec\_density}} (\sphinxstyleliteralemphasis{\sphinxupquote{Union}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{Sequence}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{float}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{Callable}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} The two\sphinxhyphen{}sided noise power spectral density in units of inverse
frequencies as an array of shape (n\_omega,), (n\_nops, n\_omega), or
(n\_nops, n\_nops, n\_omega). In the first case, the same spectrum is
taken for all noise operators, in the second, it is assumed that there
are no correlations between different noise sources and thus there is
one spectrum for each noise operator. In the third and most general
case, there may be a spectrum for each pair of noise operators
corresponding to the correlations between them. n\_nops is the number of
noise operators considered and should be equal to
\sphinxcode{\sphinxupquote{len(n\_oper\_identifiers)}}.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{omega}} (\sphinxstyleliteralemphasis{\sphinxupquote{Union}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{Sequence}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{float}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{Dict}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{Union}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{int}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} The frequencies at which the integration is to be carried out. If
\sphinxstyleemphasis{test\_convergence} is \sphinxcode{\sphinxupquote{True}}, a dict with possible keys (‘omega\_IR’,
‘omega\_UV’, ‘spacing’, ‘n\_min’, ‘n\_max’, ‘n\_points’), where all
entries are integers except for \sphinxcode{\sphinxupquote{spacing}} which should be a string,
either ‘linear’ or ‘log’. ‘n\_points’ controls how many steps are taken.
Note that the frequencies are assumed to be symmetric about zero.

\end{itemize}

\end{description}\end{quote}
\index{costs() (OperatorFilterFunctionInfidelity method)@\spxentry{costs()}\spxextra{OperatorFilterFunctionInfidelity method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:qsim.cost_functions.OperatorFilterFunctionInfidelity.costs}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{costs}}}{\emph{\DUrole{n}{self}}}{{ $\rightarrow$ Union\DUrole{p}{{[}}float\DUrole{p}{, }numpy.ndarray\DUrole{p}{{]}}}}
The infidelity is calculated with the filter function package. See its
documentation for more information.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxstylestrong{costs} \textendash{} The infidelity.

\item[{Return type}] \leavevmode
Union{[}float, np.ndarray{]}

\end{description}\end{quote}

\end{fulllineitems}

\index{grad() (OperatorFilterFunctionInfidelity method)@\spxentry{grad()}\spxextra{OperatorFilterFunctionInfidelity method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:qsim.cost_functions.OperatorFilterFunctionInfidelity.grad}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{grad}}}{\emph{\DUrole{n}{self}}}{}
Not implemented in the current version.
\begin{quote}\begin{description}
\item[{Raises}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{NotImplementedError}} \textendash{} This method has not been implemented yet.

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{OperatorMatrixNorm (class in qsim.cost\_functions)@\spxentry{OperatorMatrixNorm}\spxextra{class in qsim.cost\_functions}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:qsim.cost_functions.OperatorMatrixNorm}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxbfcode{\sphinxupquote{OperatorMatrixNorm}}}{\emph{\DUrole{n}{solver}\DUrole{p}{:} \DUrole{n}{{\hyperref[\detokenize{qsim:qsim.solver_algorithms.Solver}]{\sphinxcrossref{qsim.solver\_algorithms.Solver}}}}}, \emph{\DUrole{n}{target}\DUrole{p}{:} \DUrole{n}{{\hyperref[\detokenize{qsim:qsim.matrix.OperatorMatrix}]{\sphinxcrossref{qsim.matrix.OperatorMatrix}}}}}, \emph{\DUrole{n}{mode}\DUrole{p}{:} \DUrole{n}{str} \DUrole{o}{=} \DUrole{default_value}{\textquotesingle{}scalar\textquotesingle{}}}, \emph{\DUrole{n}{index}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}List\DUrole{p}{{[}}str\DUrole{p}{{]}}\DUrole{p}{{]}}} \DUrole{o}{=} \DUrole{default_value}{None}}}{}
Bases: {\hyperref[\detokenize{qsim:qsim.cost_functions.CostFunction}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{qsim.cost\_functions.CostFunction}}}}}

Computes the fidelity as difference between the propagator and a target.

A global phase difference is ignored. The result can be returned as
absolute value or vector. If the result shall be returned as absolute value
it is calculated in a matrix norm.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{solver}} (\sphinxstyleliteralemphasis{\sphinxupquote{TimeSlotComputer}}) \textendash{} Computes the evolution of the system.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{target}} (\sphinxstyleliteralemphasis{\sphinxupquote{ControlMatrix}}) \textendash{} The ideal evolution.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{mode}} (\sphinxstyleliteralemphasis{\sphinxupquote{string}}) \textendash{} The type of calculation.
‘scalar’: The difference is returned as scalar.
‘vector’: The difference of the individual elements is returned as
vector.
‘rotation\_axis’: For unitary evolutions only. The evolution is described
by its rotation axis and a rotation angle. The first element of the
rotation axis is multiplied by the angle so save one return argument.

\end{itemize}

\end{description}\end{quote}
\index{mode (OperatorMatrixNorm attribute)@\spxentry{mode}\spxextra{OperatorMatrixNorm attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:qsim.cost_functions.OperatorMatrixNorm.mode}}\pysigline{\sphinxbfcode{\sphinxupquote{mode}}}
Type of calculation
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
string

\end{description}\end{quote}

\end{fulllineitems}


\begin{sphinxadmonition}{note}{\label{\detokenize{qsim:id7}}Todo:}\begin{itemize}
\item {} 
implementation for target{[}0,0{]} != 0

\end{itemize}
\end{sphinxadmonition}
\index{costs() (OperatorMatrixNorm method)@\spxentry{costs()}\spxextra{OperatorMatrixNorm method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:qsim.cost_functions.OperatorMatrixNorm.costs}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{costs}}}{\emph{\DUrole{n}{self}}}{{ $\rightarrow$ Union\DUrole{p}{{[}}numpy.ndarray\DUrole{p}{, }float\DUrole{p}{{]}}}}
The costs or infidelity of the quantum channel.

These costs are given as difference between a simulated unitary
evolution and the unitary target evolution depending on the mode.
(See class documentation. )
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxstylestrong{costs} \textendash{} The costs of infidelity.

\item[{Return type}] \leavevmode
Union{[}np.ndarray, float{]}

\end{description}\end{quote}

\end{fulllineitems}

\index{grad() (OperatorMatrixNorm method)@\spxentry{grad()}\spxextra{OperatorMatrixNorm method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:qsim.cost_functions.OperatorMatrixNorm.grad}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{grad}}}{\emph{\DUrole{n}{self}}}{{ $\rightarrow$ numpy.ndarray}}
Calculates the Jacobian of the matrix difference.

Only implemented for the mode ‘vector’.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxstylestrong{jacobian} \textendash{} Jacobian of the matrix difference.

\item[{Return type}] \leavevmode
np.ndarray

\item[{Raises}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{NotImplementedError:}} \textendash{} If self.mode is not ‘vector’.

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{angle\_axis\_representation() (in module qsim.cost\_functions)@\spxentry{angle\_axis\_representation()}\spxextra{in module qsim.cost\_functions}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:qsim.cost_functions.angle_axis_representation}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{angle\_axis\_representation}}}{\emph{u: Union{[}numpy.ndarray}, \emph{qsim.matrix.DenseOperator{]}) \sphinxhyphen{}\textgreater{} (\textless{}class \textquotesingle{}float\textquotesingle{}\textgreater{}}, \emph{\textless{}class \textquotesingle{}numpy.ndarray\textquotesingle{}\textgreater{}}}{}
Calculates the representation of a 2x2 unitary matrix by a rotational axis
and a rotation angle.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{u}} (\sphinxstyleliteralemphasis{\sphinxupquote{np.ndarray}}) \textendash{} A unitary 2x2 matrix.

\item[{Returns}] \leavevmode
\begin{itemize}
\item {} 
\sphinxstylestrong{beta, n} (\sphinxstyleemphasis{float, np.ndarray}) \textendash{} beta is the angle of the rotation and n the rotational axis.

\item {} 
\sphinxstyleemphasis{TODO} \textendash{}
\begin{itemize}
\item {} 
implement for control matrices. Not only numpy arrays.

\end{itemize}

\end{itemize}


\end{description}\end{quote}

\end{fulllineitems}

\index{averge\_gate\_fidelity() (in module qsim.cost\_functions)@\spxentry{averge\_gate\_fidelity()}\spxextra{in module qsim.cost\_functions}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:qsim.cost_functions.averge_gate_fidelity}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{averge\_gate\_fidelity}}}{\emph{\DUrole{n}{unitary}\DUrole{p}{:} \DUrole{n}{{\hyperref[\detokenize{qsim:qsim.matrix.OperatorMatrix}]{\sphinxcrossref{qsim.matrix.OperatorMatrix}}}}}, \emph{\DUrole{n}{target\_unitary}\DUrole{p}{:} \DUrole{n}{{\hyperref[\detokenize{qsim:qsim.matrix.OperatorMatrix}]{\sphinxcrossref{qsim.matrix.OperatorMatrix}}}}}}{}
Average gate fidelity.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{unitary}} (\sphinxstyleliteralemphasis{\sphinxupquote{ControlMatrix}}) \textendash{} The evolution matrix of the system.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{target\_unitary}} (\sphinxstyleliteralemphasis{\sphinxupquote{ControlMatrix}}) \textendash{} The target unitary to which the evolution is compared.

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxstylestrong{fidelity} \textendash{} The average gate fidelity.

\item[{Return type}] \leavevmode
float

\end{description}\end{quote}

\end{fulllineitems}

\index{default\_set\_orthorgonal() (in module qsim.cost\_functions)@\spxentry{default\_set\_orthorgonal()}\spxextra{in module qsim.cost\_functions}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:qsim.cost_functions.default_set_orthorgonal}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{default\_set\_orthorgonal}}}{\emph{\DUrole{n}{dim}\DUrole{p}{:} \DUrole{n}{int}}}{{ $\rightarrow$ List\DUrole{p}{{[}}{\hyperref[\detokenize{qsim:qsim.matrix.OperatorMatrix}]{\sphinxcrossref{qsim.matrix.OperatorMatrix}}}\DUrole{p}{{]}}}}
Set of orthogonal matrices for the calculation of the average gate fidelity.

Currently only for two dimensional systems implemented.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{dim}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} The systems dimension.

\item[{Returns}] \leavevmode
\sphinxstylestrong{orthogonal\_operators} \textendash{} Orthogonal control matrices.

\item[{Return type}] \leavevmode
List{[}ControlMatrix{]}

\end{description}\end{quote}

\end{fulllineitems}

\index{deriv\_entanglement\_fid\_sup\_op\_with\_du() (in module qsim.cost\_functions)@\spxentry{deriv\_entanglement\_fid\_sup\_op\_with\_du()}\spxextra{in module qsim.cost\_functions}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:qsim.cost_functions.deriv_entanglement_fid_sup_op_with_du}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{deriv\_entanglement\_fid\_sup\_op\_with\_du}}}{\emph{\DUrole{n}{target}\DUrole{p}{:} \DUrole{n}{{\hyperref[\detokenize{qsim:qsim.matrix.OperatorMatrix}]{\sphinxcrossref{qsim.matrix.OperatorMatrix}}}}}, \emph{\DUrole{n}{forward\_propagators}\DUrole{p}{:} \DUrole{n}{List\DUrole{p}{{[}}{\hyperref[\detokenize{qsim:qsim.matrix.OperatorMatrix}]{\sphinxcrossref{qsim.matrix.OperatorMatrix}}}\DUrole{p}{{]}}}}, \emph{\DUrole{n}{unitary\_derivatives}\DUrole{p}{:} \DUrole{n}{List\DUrole{p}{{[}}List\DUrole{p}{{[}}{\hyperref[\detokenize{qsim:qsim.matrix.OperatorMatrix}]{\sphinxcrossref{qsim.matrix.OperatorMatrix}}}\DUrole{p}{{]}}\DUrole{p}{{]}}}}, \emph{\DUrole{n}{reversed\_propagators}\DUrole{p}{:} \DUrole{n}{List\DUrole{p}{{[}}{\hyperref[\detokenize{qsim:qsim.matrix.OperatorMatrix}]{\sphinxcrossref{qsim.matrix.OperatorMatrix}}}\DUrole{p}{{]}}}}, \emph{\DUrole{n}{computational\_states}\DUrole{p}{:} \DUrole{n}{Union\DUrole{p}{{[}}List\DUrole{p}{{[}}int\DUrole{p}{{]}}\DUrole{p}{, }NoneType\DUrole{p}{{]}}} \DUrole{o}{=} \DUrole{default_value}{None}}, \emph{\DUrole{n}{map\_to\_closest\_unitary}\DUrole{p}{:} \DUrole{n}{bool} \DUrole{o}{=} \DUrole{default_value}{False}}}{}
Derivative of the entanglement fidelity of a super operator.

Calculates the derivatives of the entanglement fidelity between a target
unitary of dimension d x d and a propagator of dimension d\textasciicircum{}2 x d\textasciicircum{}2 with
respect to the control amplitudes.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{forward\_propagators}} (\sphinxstyleliteralemphasis{\sphinxupquote{List}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{ControlMatrix}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{len: num\_t +1}}) \textendash{} The forward propagators calculated in the systems simulation.
forward\_propagators{[}i{]} is the ordered sum of the propagators i..0 in
descending order.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{unitary\_derivatives}} (\sphinxstyleliteralemphasis{\sphinxupquote{List}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{List}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{ControlMatrix}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}\sphinxstyleliteralemphasis{\sphinxupquote{,}}) \textendash{} shape: {[}{[}{]} * num\_t{]} * num\_ctrl
Frechet derivatives of the propagators by the control amplitudes.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{target}} (\sphinxstyleliteralemphasis{\sphinxupquote{ControlMatrix}}) \textendash{} The target unitary evolution.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{reversed\_propagators}} (\sphinxstyleliteralemphasis{\sphinxupquote{List}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{ControlMatrix}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} The reversed propagators calculated in the systems simulation.
reversed\_propagators{[}i{]} is the ordered sum of the propagators n\sphinxhyphen{}i..n in
ascending order where n is the total number of time steps.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{computational\_states}} (\sphinxstyleliteralemphasis{\sphinxupquote{Optional}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{List}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{int}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} If set, the entanglement fidelity is only calculated for the specified
subspace.s only calculated for the specified
subspace.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{map\_to\_closest\_unitary}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}) \textendash{} If True, then the final propagator is mapped to the closest unitary
before the infidelity is evaluated.

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxstylestrong{derivative\_fidelity} \textendash{} The derivatives of the entanglement fidelity.

\item[{Return type}] \leavevmode
np.ndarray, shape: (num\_t, num\_ctrl)

\end{description}\end{quote}

\end{fulllineitems}

\index{derivative\_average\_gate\_fid\_with\_du() (in module qsim.cost\_functions)@\spxentry{derivative\_average\_gate\_fid\_with\_du()}\spxextra{in module qsim.cost\_functions}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:qsim.cost_functions.derivative_average_gate_fid_with_du}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{derivative\_average\_gate\_fid\_with\_du}}}{\emph{\DUrole{n}{propagators}}, \emph{\DUrole{n}{propagators\_past}}, \emph{\DUrole{n}{unitary\_derivatives}}, \emph{\DUrole{n}{target\_unitary}}}{}~
\end{fulllineitems}

\index{derivative\_average\_gate\_fidelity() (in module qsim.cost\_functions)@\spxentry{derivative\_average\_gate\_fidelity()}\spxextra{in module qsim.cost\_functions}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:qsim.cost_functions.derivative_average_gate_fidelity}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{derivative\_average\_gate\_fidelity}}}{\emph{\DUrole{n}{control\_hamiltonians}}, \emph{\DUrole{n}{propagators}}, \emph{\DUrole{n}{propagators\_past}}, \emph{\DUrole{n}{delta\_t}}, \emph{\DUrole{n}{target\_unitary}}}{}
The derivative of the average gate fidelity.

\end{fulllineitems}

\index{derivative\_entanglement\_fidelity() (in module qsim.cost\_functions)@\spxentry{derivative\_entanglement\_fidelity()}\spxextra{in module qsim.cost\_functions}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:qsim.cost_functions.derivative_entanglement_fidelity}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{derivative\_entanglement\_fidelity}}}{\emph{\DUrole{n}{control\_hamiltonians}\DUrole{p}{:} \DUrole{n}{List\DUrole{p}{{[}}{\hyperref[\detokenize{qsim:qsim.matrix.OperatorMatrix}]{\sphinxcrossref{qsim.matrix.OperatorMatrix}}}\DUrole{p}{{]}}}}, \emph{\DUrole{n}{forward\_propagators}\DUrole{p}{:} \DUrole{n}{List\DUrole{p}{{[}}{\hyperref[\detokenize{qsim:qsim.matrix.OperatorMatrix}]{\sphinxcrossref{qsim.matrix.OperatorMatrix}}}\DUrole{p}{{]}}}}, \emph{\DUrole{n}{reversed\_propagators}\DUrole{p}{:} \DUrole{n}{List\DUrole{p}{{[}}{\hyperref[\detokenize{qsim:qsim.matrix.OperatorMatrix}]{\sphinxcrossref{qsim.matrix.OperatorMatrix}}}\DUrole{p}{{]}}}}, \emph{\DUrole{n}{delta\_t}\DUrole{p}{:} \DUrole{n}{List\DUrole{p}{{[}}float\DUrole{p}{{]}}}}, \emph{\DUrole{n}{target\_unitary}\DUrole{p}{:} \DUrole{n}{{\hyperref[\detokenize{qsim:qsim.matrix.OperatorMatrix}]{\sphinxcrossref{qsim.matrix.OperatorMatrix}}}}}}{{ $\rightarrow$ numpy.ndarray}}
Derivative of the entanglement fidelity using the grape approximation.

dU / du = \sphinxhyphen{}i delta\_t H\_ctrl U
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{control\_hamiltonians}} (\sphinxstyleliteralemphasis{\sphinxupquote{List}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{ControlMatrix}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{len: num\_ctrl}}) \textendash{} The control hamiltonians of the simulation.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{forward\_propagators}} (\sphinxstyleliteralemphasis{\sphinxupquote{List}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{ControlMatrix}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{len: num\_t +1}}) \textendash{} The forward propagators calculated in the systems simulation.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{reversed\_propagators}} (\sphinxstyleliteralemphasis{\sphinxupquote{List}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{ControlMatrix}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} The reversed propagators calculated in the systems simulation.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{delta\_t}} (\sphinxstyleliteralemphasis{\sphinxupquote{List}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{float}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{len: num\_t}}) \textendash{} The durations of the time steps.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{target\_unitary}} (\sphinxstyleliteralemphasis{\sphinxupquote{ControlMatrix}}) \textendash{} The target unitary evolution.

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxstylestrong{derivative\_fidelity} \textendash{} The derivatives of the entanglement fidelity.

\item[{Return type}] \leavevmode
np.ndarray, shape: (num\_t, num\_ctrl)

\end{description}\end{quote}

\end{fulllineitems}

\index{derivative\_entanglement\_fidelity\_with\_du() (in module qsim.cost\_functions)@\spxentry{derivative\_entanglement\_fidelity\_with\_du()}\spxextra{in module qsim.cost\_functions}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:qsim.cost_functions.derivative_entanglement_fidelity_with_du}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{derivative\_entanglement\_fidelity\_with\_du}}}{\emph{\DUrole{n}{target}\DUrole{p}{:} \DUrole{n}{{\hyperref[\detokenize{qsim:qsim.matrix.OperatorMatrix}]{\sphinxcrossref{qsim.matrix.OperatorMatrix}}}}}, \emph{\DUrole{n}{forward\_propagators}\DUrole{p}{:} \DUrole{n}{List\DUrole{p}{{[}}{\hyperref[\detokenize{qsim:qsim.matrix.OperatorMatrix}]{\sphinxcrossref{qsim.matrix.OperatorMatrix}}}\DUrole{p}{{]}}}}, \emph{\DUrole{n}{propagator\_derivatives}\DUrole{p}{:} \DUrole{n}{List\DUrole{p}{{[}}List\DUrole{p}{{[}}{\hyperref[\detokenize{qsim:qsim.matrix.OperatorMatrix}]{\sphinxcrossref{qsim.matrix.OperatorMatrix}}}\DUrole{p}{{]}}\DUrole{p}{{]}}}}, \emph{\DUrole{n}{reversed\_propagators}\DUrole{p}{:} \DUrole{n}{List\DUrole{p}{{[}}{\hyperref[\detokenize{qsim:qsim.matrix.OperatorMatrix}]{\sphinxcrossref{qsim.matrix.OperatorMatrix}}}\DUrole{p}{{]}}}}, \emph{\DUrole{n}{computational\_states}\DUrole{p}{:} \DUrole{n}{Union\DUrole{p}{{[}}List\DUrole{p}{{[}}int\DUrole{p}{{]}}\DUrole{p}{, }NoneType\DUrole{p}{{]}}} \DUrole{o}{=} \DUrole{default_value}{None}}, \emph{\DUrole{n}{map\_to\_closest\_unitary}\DUrole{p}{:} \DUrole{n}{bool} \DUrole{o}{=} \DUrole{default_value}{False}}}{{ $\rightarrow$ numpy.ndarray}}
Derivative of the entanglement fidelity using the derivatives of the
propagators.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{forward\_propagators}} (\sphinxstyleliteralemphasis{\sphinxupquote{List}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{ControlMatrix}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{len: num\_t +1}}) \textendash{} The forward propagators calculated in the systems simulation.
forward\_propagators{[}i{]} is the ordered sum of the propagators i..0 in
descending order.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{propagator\_derivatives}} (\sphinxstyleliteralemphasis{\sphinxupquote{List}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{List}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{ControlMatrix}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}\sphinxstyleliteralemphasis{\sphinxupquote{,}}) \textendash{} shape: {[}{[}{]} * num\_t{]} * num\_ctrl
Frechet derivatives of the propagators by the control amplitudes.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{target}} (\sphinxstyleliteralemphasis{\sphinxupquote{ControlMatrix}}) \textendash{} The target propagator.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{reversed\_propagators}} (\sphinxstyleliteralemphasis{\sphinxupquote{List}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{ControlMatrix}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} The reversed propagators calculated in the systems simulation.
reversed\_propagators{[}i{]} is the ordered sum of the propagators n\sphinxhyphen{}i..n in
ascending order where n is the total number of time steps.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{computational\_states}} (\sphinxstyleliteralemphasis{\sphinxupquote{Optional}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{List}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{int}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} If set, the entanglement fidelity is only calculated for the specified
subspace.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{map\_to\_closest\_unitary}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}) \textendash{} If True, then the final propagator is mapped to the closest unitary
before the infidelity is evaluated.

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxstylestrong{derivative\_fidelity} \textendash{} The derivatives of the entanglement fidelity.

\item[{Return type}] \leavevmode
np.ndarray, shape: (num\_t, num\_ctrl)

\end{description}\end{quote}

\end{fulllineitems}

\index{entanglement\_fidelity() (in module qsim.cost\_functions)@\spxentry{entanglement\_fidelity()}\spxextra{in module qsim.cost\_functions}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:qsim.cost_functions.entanglement_fidelity}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{entanglement\_fidelity}}}{\emph{\DUrole{n}{target}\DUrole{p}{:} \DUrole{n}{Union\DUrole{p}{{[}}numpy.ndarray\DUrole{p}{, }{\hyperref[\detokenize{qsim:qsim.matrix.OperatorMatrix}]{\sphinxcrossref{qsim.matrix.OperatorMatrix}}}\DUrole{p}{{]}}}}, \emph{\DUrole{n}{propagator}\DUrole{p}{:} \DUrole{n}{Union\DUrole{p}{{[}}numpy.ndarray\DUrole{p}{, }{\hyperref[\detokenize{qsim:qsim.matrix.OperatorMatrix}]{\sphinxcrossref{qsim.matrix.OperatorMatrix}}}\DUrole{p}{{]}}}}, \emph{\DUrole{n}{computational\_states}\DUrole{p}{:} \DUrole{n}{Union\DUrole{p}{{[}}List\DUrole{p}{{[}}int\DUrole{p}{{]}}\DUrole{p}{, }NoneType\DUrole{p}{{]}}} \DUrole{o}{=} \DUrole{default_value}{None}}, \emph{\DUrole{n}{map\_to\_closest\_unitary}\DUrole{p}{:} \DUrole{n}{bool} \DUrole{o}{=} \DUrole{default_value}{False}}}{{ $\rightarrow$ numpy.float64}}
The entanglement fidelity between a simulated Propagator and target
propagator.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{propagator}} (\sphinxstyleliteralemphasis{\sphinxupquote{Union}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{np.ndarray}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{ControlMatrix}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} The simulated propagator.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{target}} (\sphinxstyleliteralemphasis{\sphinxupquote{Union}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{np.ndarray}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{ControlMatrix}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} The target unitary evolution.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{computational\_states}} (\sphinxstyleliteralemphasis{\sphinxupquote{Optional}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{List}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{int}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} If set, the entanglement fidelity is only calculated for the specified
subspace.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{map\_to\_closest\_unitary}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}) \textendash{} If True, then the final propagator is mapped to the closest unitary
before the infidelity is evaluated.

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxstylestrong{fidelity} \textendash{} The entanglement fidelity of target\_unitary.dag * unitary.

\item[{Return type}] \leavevmode
float

\end{description}\end{quote}

\end{fulllineitems}

\index{entanglement\_fidelity\_super\_operator() (in module qsim.cost\_functions)@\spxentry{entanglement\_fidelity\_super\_operator()}\spxextra{in module qsim.cost\_functions}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:qsim.cost_functions.entanglement_fidelity_super_operator}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{entanglement\_fidelity\_super\_operator}}}{\emph{\DUrole{n}{target}\DUrole{p}{:} \DUrole{n}{Union\DUrole{p}{{[}}numpy.ndarray\DUrole{p}{, }{\hyperref[\detokenize{qsim:qsim.matrix.OperatorMatrix}]{\sphinxcrossref{qsim.matrix.OperatorMatrix}}}\DUrole{p}{{]}}}}, \emph{\DUrole{n}{propagator}\DUrole{p}{:} \DUrole{n}{Union\DUrole{p}{{[}}numpy.ndarray\DUrole{p}{, }{\hyperref[\detokenize{qsim:qsim.matrix.OperatorMatrix}]{\sphinxcrossref{qsim.matrix.OperatorMatrix}}}\DUrole{p}{{]}}}}, \emph{\DUrole{n}{computational\_states}\DUrole{p}{:} \DUrole{n}{Union\DUrole{p}{{[}}List\DUrole{p}{{[}}int\DUrole{p}{{]}}\DUrole{p}{, }NoneType\DUrole{p}{{]}}} \DUrole{o}{=} \DUrole{default_value}{None}}, \emph{\DUrole{n}{map\_to\_closest\_unitary}\DUrole{p}{:} \DUrole{n}{bool} \DUrole{o}{=} \DUrole{default_value}{False}}}{{ $\rightarrow$ numpy.float64}}
The entanglement fidelity between a simulated Propagator and target
propagator in the super operator formalism.

The entanglement fidelity between a propagator in the super operator
formalism of dimension d\textasciicircum{}2 x d\textasciicircum{}2 and a target unitary operator of dimension
d x d.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{propagator}} (\sphinxstyleliteralemphasis{\sphinxupquote{Union}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{np.ndarray}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{ControlMatrix}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} The simulated evolution propagator in the super operator formalism.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{target}} (\sphinxstyleliteralemphasis{\sphinxupquote{Union}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{np.ndarray}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{ControlMatrix}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} The target unitary evolution. (NOT as super operator.)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{computational\_states}} (\sphinxstyleliteralemphasis{\sphinxupquote{Optional}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{List}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{int}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} If set, the entanglement fidelity is only calculated for the specified
subspace.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{map\_to\_closest\_unitary}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}) \textendash{} If True, then the final propagator is mapped to the closest unitary
before the infidelity is evaluated.

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxstylestrong{fidelity} \textendash{} The entanglement fidelity of target\_unitary.dag * unitary.

\item[{Return type}] \leavevmode
float

\end{description}\end{quote}

\end{fulllineitems}



\subsection{qsim.data\_container module}
\label{\detokenize{qsim:module-qsim.data_container}}\label{\detokenize{qsim:qsim-data-container-module}}\index{module@\spxentry{module}!qsim.data\_container@\spxentry{qsim.data\_container}}\index{qsim.data\_container@\spxentry{qsim.data\_container}!module@\spxentry{module}}
Implements data storage.


\subsubsection{Classes}
\label{\detokenize{qsim:id8}}\begin{description}
\item[{{\hyperref[\detokenize{qsim:qsim.data_container.DataContainer}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{DataContainer}}}}}}] \leavevmode
Data storage class.

\end{description}

\begin{sphinxadmonition}{note}{Notes}

The implementation was inspired by the optimal control package of QuTiP \sphinxcite{qsim:r40c5148f82d6-1}
(Quantum Toolbox in Python)
\end{sphinxadmonition}
\subsubsection*{References}
\index{DataContainer (class in qsim.data\_container)@\spxentry{DataContainer}\spxextra{class in qsim.data\_container}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:qsim.data_container.DataContainer}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxbfcode{\sphinxupquote{DataContainer}}}{\emph{\DUrole{n}{storage\_path}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}str\DUrole{p}{{]}}} \DUrole{o}{=} \DUrole{default_value}{None}}, \emph{\DUrole{n}{file\_name}\DUrole{p}{:} \DUrole{n}{str} \DUrole{o}{=} \DUrole{default_value}{\textquotesingle{}Temp File\textquotesingle{}}}, \emph{\DUrole{n}{indices}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}List\DUrole{p}{{[}}str\DUrole{p}{{]}}\DUrole{p}{{]}}} \DUrole{o}{=} \DUrole{default_value}{None}}, \emph{\DUrole{n}{final\_costs}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}List\DUrole{p}{{]}}} \DUrole{o}{=} \DUrole{default_value}{None}}, \emph{\DUrole{n}{init\_parameters}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}List\DUrole{p}{{]}}} \DUrole{o}{=} \DUrole{default_value}{None}}, \emph{\DUrole{n}{final\_parameters}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}List\DUrole{p}{{]}}} \DUrole{o}{=} \DUrole{default_value}{None}}, \emph{\DUrole{n}{costs}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}List\DUrole{p}{{[}}List\DUrole{p}{{]}}\DUrole{p}{{]}}} \DUrole{o}{=} \DUrole{default_value}{None}}, \emph{\DUrole{n}{parameters}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}List\DUrole{p}{{[}}List\DUrole{p}{{]}}\DUrole{p}{{]}}} \DUrole{o}{=} \DUrole{default_value}{None}}, \emph{\DUrole{n}{status}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}List\DUrole{p}{{]}}} \DUrole{o}{=} \DUrole{default_value}{None}}, \emph{\DUrole{n}{optimization\_stats}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}List\DUrole{p}{{]}}} \DUrole{o}{=} \DUrole{default_value}{None}}, \emph{\DUrole{n}{append\_time\_to\_path}\DUrole{o}{=}\DUrole{default_value}{True}}}{}
Bases: \sphinxcode{\sphinxupquote{object}}

Stores data of the optimization.

This class gathers the information stored in multiple objects of the
class \sphinxtitleref{OptimResult}.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{storage\_path}} (\sphinxstyleliteralemphasis{\sphinxupquote{string}}) \textendash{} The path were this instance of DataContainer is to be stored or from
where is shall be loaded.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{file\_name}} (\sphinxstyleliteralemphasis{\sphinxupquote{string}}) \textendash{} The file name will be appended to the path for storage and loading. The
default value is an empty string assuming that the storage path already
contains the file name.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{indices}} (\sphinxstyleliteralemphasis{\sphinxupquote{list of str}}) \textendash{} The indices of the costs.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{final\_costs}} (\sphinxstyleliteralemphasis{\sphinxupquote{list}}) \textendash{} The final values of the cost function.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{init\_parameters}} (\sphinxstyleliteralemphasis{\sphinxupquote{list}}) \textendash{} The initial optimization parameters.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{final\_parameters}} (\sphinxstyleliteralemphasis{\sphinxupquote{list}}) \textendash{} The final optimization parameters.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{costs}} (\sphinxstyleliteralemphasis{\sphinxupquote{list of list}}) \textendash{} All values of the cost functions during the optimization.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{parameters}} (\sphinxstyleliteralemphasis{\sphinxupquote{list of list}}) \textendash{} All parameters for which the cost functions were evaluated during the
optimization.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{status}} (\sphinxstyleliteralemphasis{\sphinxupquote{list of None}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} The termination\_reason as integer. Like in scipy.OptimizeResult
None if the optimization has not started.
\sphinxhyphen{}1: improper input parameters status
0: the maximum number of function evaluations is exceeded.
1: gradient norm termination condition is satisfied.
2: cost function termination condition is satisfied.
3: minimal step size termination condition is satisfied.
4: Both 2 and 3 termination conditions are satisfied.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{optimization\_stats}} (\sphinxstyleliteralemphasis{\sphinxupquote{list}}) \textendash{} Optimization statistics, which have been appended to the data.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{append\_time\_to\_path}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}) \textendash{} If True, the current time is appended to the file name.

\end{itemize}

\end{description}\end{quote}
\index{append\_optim\_result() (DataContainer method)@\spxentry{append\_optim\_result()}\spxextra{DataContainer method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:qsim.data_container.DataContainer.append_optim_result}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{append\_optim\_result}}}{\emph{optim\_result: \textasciigrave{}OptimizationResult\textasciigrave{}}}{}
Append the data from a single optimization run to the \sphinxtitleref{DataContainer}.

\end{fulllineitems}

\index{to\_pickle() (DataContainer method)@\spxentry{to\_pickle()}\spxextra{DataContainer method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:qsim.data_container.DataContainer.to_pickle}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{to\_pickle}}}{\emph{\DUrole{n}{filename}\DUrole{p}{:} \DUrole{n}{str}}}{}
Dump the class instance into the file.

\end{fulllineitems}

\index{from\_pickle() (DataContainer method)@\spxentry{from\_pickle()}\spxextra{DataContainer method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:qsim.data_container.DataContainer.from_pickle}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{from\_pickle}}}{\emph{\DUrole{n}{filename}\DUrole{p}{:} \DUrole{n}{str}}}{}
Classmethod: Load a pickled \sphinxtitleref{DataContainer}.

\end{fulllineitems}

\index{append\_optim\_result() (DataContainer method)@\spxentry{append\_optim\_result()}\spxextra{DataContainer method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:id10}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{append\_optim\_result}}}{\emph{\DUrole{n}{self}}, \emph{\DUrole{n}{optim\_result}\DUrole{p}{:} \DUrole{n}{{\hyperref[\detokenize{qsim:qsim.optimization_data.OptimizationResult}]{\sphinxcrossref{qsim.optimization\_data.OptimizationResult}}}}}}{}
Appends an instance of \sphinxtitleref{OptimizationResult} to the stored data.

The Information gained in an optimization run is extracted and
appended to the various lists of the \sphinxtitleref{DataContainer}.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{optim\_result}} (\sphinxtitleref{OptimizationResult}) \textendash{} Result of an optimization run.

\end{description}\end{quote}

\end{fulllineitems}

\index{check\_length() (DataContainer method)@\spxentry{check\_length()}\spxextra{DataContainer method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:qsim.data_container.DataContainer.check_length}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{check\_length}}}{\emph{\DUrole{n}{self}}}{}~
\end{fulllineitems}

\index{from\_pickle() (DataContainer class method)@\spxentry{from\_pickle()}\spxextra{DataContainer class method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:id11}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{classmethod }}\sphinxbfcode{\sphinxupquote{from\_pickle}}}{\emph{\DUrole{n}{filename}}}{}
Read class from pickled file.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{filename}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} The name of the file which is loaded.

\end{description}\end{quote}

\end{fulllineitems}

\index{index() (DataContainer property)@\spxentry{index()}\spxextra{DataContainer property}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:qsim.data_container.DataContainer.index}}\pysigline{\sphinxbfcode{\sphinxupquote{property }}\sphinxbfcode{\sphinxupquote{index}}}
Indices of the cost functions.

\end{fulllineitems}

\index{to\_pickle() (DataContainer method)@\spxentry{to\_pickle()}\spxextra{DataContainer method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:id12}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{to\_pickle}}}{\emph{\DUrole{n}{self}}, \emph{\DUrole{n}{filename}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
Dumps the class to pickle.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{filename}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} Name of the file to which the class is pickled.

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\subsection{qsim.energy\_spectrum module}
\label{\detokenize{qsim:module-qsim.energy_spectrum}}\label{\detokenize{qsim:qsim-energy-spectrum-module}}\index{module@\spxentry{module}!qsim.energy\_spectrum@\spxentry{qsim.energy\_spectrum}}\index{qsim.energy\_spectrum@\spxentry{qsim.energy\_spectrum}!module@\spxentry{module}}
This file serves to plot energy spectra of Hamiltonians.


\subsubsection{Functions}
\label{\detokenize{qsim:id13}}\begin{description}
\item[{{\hyperref[\detokenize{qsim:qsim.energy_spectrum.vector_color_map}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{vector\_color\_map()}}}}}}] \leavevmode
Maps eigenvectors to a coloring.

\item[{{\hyperref[\detokenize{qsim:qsim.energy_spectrum.plot_energy_spectrum}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{plot\_energy\_spectrum()}}}}}}] \leavevmode
plot the energy spectrum of an Hamiltonian.

\end{description}
\index{plot\_energy\_spectrum() (in module qsim.energy\_spectrum)@\spxentry{plot\_energy\_spectrum()}\spxextra{in module qsim.energy\_spectrum}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:qsim.energy_spectrum.plot_energy_spectrum}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{plot\_energy\_spectrum}}}{\emph{hamiltonian: List{[}qsim.matrix.OperatorMatrix{]}, x\_val: \textless{}built\sphinxhyphen{}in function array\textgreater{}, x\_label: str}}{}
Calculates and plots the energy spectra of hamilton operators.

The colors demonstrate the contribution of individual base vectors.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{hamiltonian}} (\sphinxstyleliteralemphasis{\sphinxupquote{list of OperatorMatrix}}) \textendash{} The Hamiltonians which shall provide the energy spectra. They need to
be hermitian.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{x\_val}} (\sphinxstyleliteralemphasis{\sphinxupquote{array of float}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{shape}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{n}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} The x\_vales by which the eigenvalues are plotted.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{x\_label}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} Label of the x\sphinxhyphen{}axis.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{vector\_color\_map() (in module qsim.energy\_spectrum)@\spxentry{vector\_color\_map()}\spxextra{in module qsim.energy\_spectrum}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:qsim.energy_spectrum.vector_color_map}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{vector\_color\_map}}}{\emph{vectors: \textless{}built\sphinxhyphen{}in function array\textgreater{}}}{}
Maps eigenvectors to a coloring, encoding the contributions.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{vectors}} (\sphinxstyleliteralemphasis{\sphinxupquote{array}}) \textendash{} Array of eigenvectors. The eigenvectors are given as columns. There
may be no more than 7.

\item[{Returns}] \leavevmode
\sphinxstylestrong{color\_values} \textendash{} The coloring is given as array. Each column signifies one tuple of
RGB color values.

\item[{Return type}] \leavevmode
array

\end{description}\end{quote}

\end{fulllineitems}



\subsection{qsim.matrix module}
\label{\detokenize{qsim:module-qsim.matrix}}\label{\detokenize{qsim:qsim-matrix-module}}\index{module@\spxentry{module}!qsim.matrix@\spxentry{qsim.matrix}}\index{qsim.matrix@\spxentry{qsim.matrix}!module@\spxentry{module}}
This file contains a matrix class which implements the computationally
expensive numeric calculations.

The matrices can be stored and handled either as dense or sparse
matrices for the sake of encapsulation of the numeric methods.
The most frequently used and computationally expensive function is
the matrix exponential and its derivative. These operations are required to
calculate the analytic solution of the Schroedinger and Lindblad master
equation.


\subsubsection{Classes}
\label{\detokenize{qsim:id14}}\begin{description}
\item[{{\hyperref[\detokenize{qsim:qsim.matrix.OperatorMatrix}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{OperatorMatrix}}}}}}] \leavevmode
Abstract base class.

\item[{\sphinxcode{\sphinxupquote{OperatorDense}}}] \leavevmode
Dense control matrices, which are based on numpy arrays.

\item[{\sphinxcode{\sphinxupquote{OperatorSparse}}}] \leavevmode
To be implemented

\end{description}


\subsubsection{Functions}
\label{\detokenize{qsim:id15}}\begin{description}
\item[{{\hyperref[\detokenize{qsim:qsim.matrix.convert_unitary_to_super_operator}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{convert\_unitary\_to\_super\_operator()}}}}}}] \leavevmode
Converts a unitary propagator into a super operator in the lindblad
formalism.

\item[{{\hyperref[\detokenize{qsim:qsim.matrix.closest_unitary}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{closest\_unitary()}}}}}}] \leavevmode
Calculates the closest unitary propagator for a squared matrix.

\end{description}

\begin{sphinxadmonition}{note}{Notes}

The implementation was inspired by the optimal control package of QuTiP \sphinxcite{qsim:r35617950a937-1}
(Quantum Toolbox in Python)
\end{sphinxadmonition}
\subsubsection*{References}
\index{DenseOperator (class in qsim.matrix)@\spxentry{DenseOperator}\spxextra{class in qsim.matrix}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:qsim.matrix.DenseOperator}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxbfcode{\sphinxupquote{DenseOperator}}}{\emph{\DUrole{n}{obj}\DUrole{p}{:} \DUrole{n}{Union\DUrole{p}{{[}}qutip.qobj.Qobj\DUrole{p}{, }numpy.ndarray\DUrole{p}{, }scipy.sparse.csr.csr\_matrix\DUrole{p}{, }DenseOperator\DUrole{p}{{]}}}}}{}
Bases: {\hyperref[\detokenize{qsim:qsim.matrix.OperatorMatrix}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{qsim.matrix.OperatorMatrix}}}}}

Dense control matrix.

The data is stored as numpy array and uses the implementations of the
numpy package.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{obj}} (\sphinxstyleliteralemphasis{\sphinxupquote{Qobj}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{numpy array}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{scipy csr\_matrix}}) \textendash{} The matrix to be stored and handled as dense matrix.

\end{description}\end{quote}
\index{data (DenseOperator attribute)@\spxentry{data}\spxextra{DenseOperator attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:qsim.matrix.DenseOperator.data}}\pysigline{\sphinxbfcode{\sphinxupquote{data}}}
The data stored in a two dimensional numpy array
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
numpy array

\end{description}\end{quote}

\end{fulllineitems}

\index{conj() (DenseOperator method)@\spxentry{conj()}\spxextra{DenseOperator method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:qsim.matrix.DenseOperator.conj}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{conj}}}{\emph{\DUrole{n}{self}}, \emph{\DUrole{n}{copy\_}\DUrole{p}{:} \DUrole{n}{bool} \DUrole{o}{=} \DUrole{default_value}{True}}}{{ $\rightarrow$ Union{[}ForwardRef(‘DenseOperator’), NoneType{]}}}
See base class.

\end{fulllineitems}

\index{copy() (DenseOperator method)@\spxentry{copy()}\spxextra{DenseOperator method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:qsim.matrix.DenseOperator.copy}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{copy}}}{\emph{\DUrole{n}{self}}}{}
See base class.

\end{fulllineitems}

\index{dag() (DenseOperator method)@\spxentry{dag()}\spxextra{DenseOperator method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:qsim.matrix.DenseOperator.dag}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{dag}}}{\emph{\DUrole{n}{self}}, \emph{\DUrole{n}{copy\_}\DUrole{p}{:} \DUrole{n}{bool} \DUrole{o}{=} \DUrole{default_value}{True}}}{{ $\rightarrow$ Union{[}ForwardRef(‘DenseOperator’), NoneType{]}}}
See base class.

\end{fulllineitems}

\index{dexp() (DenseOperator method)@\spxentry{dexp()}\spxextra{DenseOperator method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:qsim.matrix.DenseOperator.dexp}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{dexp}}}{\emph{\DUrole{n}{self}}, \emph{\DUrole{n}{direction}\DUrole{p}{:} \DUrole{n}{‘DenseOperator’}}, \emph{\DUrole{n}{tau}\DUrole{p}{:} \DUrole{n}{complex} \DUrole{o}{=} \DUrole{default_value}{1}}, \emph{\DUrole{n}{compute\_expm}\DUrole{p}{:} \DUrole{n}{bool} \DUrole{o}{=} \DUrole{default_value}{False}}, \emph{\DUrole{n}{method}\DUrole{p}{:} \DUrole{n}{str} \DUrole{o}{=} \DUrole{default_value}{\textquotesingle{}spectral\textquotesingle{}}}, \emph{\DUrole{n}{is\_skew\_hermitian}\DUrole{p}{:} \DUrole{n}{bool} \DUrole{o}{=} \DUrole{default_value}{False}}, \emph{\DUrole{n}{epsilon}\DUrole{p}{:} \DUrole{n}{float} \DUrole{o}{=} \DUrole{default_value}{1e\sphinxhyphen{}10}}}{{ $\rightarrow$ Union{[}ForwardRef(‘DenseOperator’), Tuple{[}ForwardRef(‘DenseOperator’){]}{]}}}
Frechet derivative of the matrix exponential.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{direction}} ({\hyperref[\detokenize{qsim:qsim.matrix.DenseOperator}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{DenseOperator}}}}}) \textendash{} Direction in which the frechet derivative is calculated. Must be of
the same shape as self.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{tau}} (\sphinxstyleliteralemphasis{\sphinxupquote{complex}}) \textendash{} The matrix is multiplied by tau before calculating the exponential.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{compute\_expm}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}) \textendash{} If true, then the matrix exponential is calculated and returned as
well.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{method}} (\sphinxstyleliteralemphasis{\sphinxupquote{string}}) \textendash{} Numerical method used for the calculation of the matrix
exponential.
Currently the following are implemented:
\sphinxhyphen{} ‘Frechet’: Uses the scipy linalg matrix exponential for
simultaniously calculation of the frechet derivative expm\_frechet
\sphinxhyphen{} ‘approx’: Approximates the Derivative by finite differences.
\sphinxhyphen{} ‘first\_order’: First order taylor approximation
\sphinxhyphen{} ‘second\_order’: Second order taylor approximation
\sphinxhyphen{} ‘third\_order’: Third order taylor approximation
\sphinxhyphen{} ‘spectral’: Use the self implemented spectral decomposition

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{is\_skew\_hermitian}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}) \textendash{} Only required, for the method ‘spectral’. If set to True, then the
matrix is assumed to be skew hermitian in the spectral
decomposition.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{epsilon}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} Width of the finite difference. Only relevant for the method
‘approx’.

\end{itemize}

\item[{Returns}] \leavevmode
\begin{itemize}
\item {} 
\sphinxstylestrong{prop} (\sphinxstyleemphasis{DenseOperator}) \textendash{} The matrix exponential. Only returned if compute\_expm is True!

\item {} 
\sphinxstylestrong{prop\_grad} (\sphinxstyleemphasis{DenseOperator}) \textendash{} The frechet derivative d exp(Ax + B)/dx at x=0 where A is the
direction and B is the matrix stored in self.

\end{itemize}


\item[{Raises}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{NotImplementedError:}} \textendash{} If the method given as parameter is not implemented.

\end{description}\end{quote}

\end{fulllineitems}

\index{exp() (DenseOperator method)@\spxentry{exp()}\spxextra{DenseOperator method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:qsim.matrix.DenseOperator.exp}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{exp}}}{\emph{\DUrole{n}{self}}, \emph{\DUrole{n}{tau}\DUrole{p}{:} \DUrole{n}{complex} \DUrole{o}{=} \DUrole{default_value}{1}}, \emph{\DUrole{n}{method}\DUrole{p}{:} \DUrole{n}{str} \DUrole{o}{=} \DUrole{default_value}{\textquotesingle{}spectral\textquotesingle{}}}, \emph{\DUrole{n}{is\_skew\_hermitian}\DUrole{p}{:} \DUrole{n}{bool} \DUrole{o}{=} \DUrole{default_value}{False}}}{{ $\rightarrow$ ’DenseOperator’}}
Matrix exponential.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{tau}} (\sphinxstyleliteralemphasis{\sphinxupquote{complex}}) \textendash{} The matrix is multiplied by tau before calculating the exponential.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{method}} (\sphinxstyleliteralemphasis{\sphinxupquote{string}}) \textendash{} Numerical method used for the calculation of the matrix
exponential.
Currently the following are implemented:
\sphinxhyphen{} ‘approx’, ‘Frechet’: use the scipy linalg matrix exponential
\sphinxhyphen{} ‘first\_order’: First order taylor approximation
\sphinxhyphen{} ‘second\_order’: Second order taylor approximation
\sphinxhyphen{} ‘third\_order’: Third order taylor approximation
\sphinxhyphen{} ‘spectral’: Use the self implemented spectral decomposition

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{is\_skew\_hermitian}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}) \textendash{} Only important for the method ‘spectral’. If set to True then the
matrix is assumed to be skew hermitian in the spectral
decomposition.

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxstylestrong{prop} \textendash{} The matrix exponential.

\item[{Return type}] \leavevmode
{\hyperref[\detokenize{qsim:qsim.matrix.DenseOperator}]{\sphinxcrossref{DenseOperator}}}

\item[{Raises}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{NotImplementedError:}} \textendash{} If the method given as parameter is not implemented.

\end{description}\end{quote}

\end{fulllineitems}

\index{flatten() (DenseOperator method)@\spxentry{flatten()}\spxextra{DenseOperator method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:qsim.matrix.DenseOperator.flatten}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{flatten}}}{\emph{\DUrole{n}{self}}}{{ $\rightarrow$ numpy.ndarray}}
See base class.

\end{fulllineitems}

\index{identity\_like() (DenseOperator method)@\spxentry{identity\_like()}\spxextra{DenseOperator method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:qsim.matrix.DenseOperator.identity_like}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{identity\_like}}}{\emph{\DUrole{n}{self}}}{{ $\rightarrow$ ’DenseOperator’}}
See base class.

\end{fulllineitems}

\index{kron() (DenseOperator method)@\spxentry{kron()}\spxextra{DenseOperator method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:qsim.matrix.DenseOperator.kron}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{kron}}}{\emph{\DUrole{n}{self}}, \emph{\DUrole{n}{other}\DUrole{p}{:} \DUrole{n}{‘DenseOperator’}}}{{ $\rightarrow$ ’DenseOperator’}}
See base class.

\end{fulllineitems}

\index{prop() (DenseOperator method)@\spxentry{prop()}\spxextra{DenseOperator method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:qsim.matrix.DenseOperator.prop}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{prop}}}{\emph{\DUrole{n}{self}}, \emph{\DUrole{n}{tau}\DUrole{p}{:} \DUrole{n}{complex} \DUrole{o}{=} \DUrole{default_value}{1}}}{{ $\rightarrow$ ’DenseOperator’}}
See base class.

\end{fulllineitems}

\index{spectral\_decomposition() (DenseOperator method)@\spxentry{spectral\_decomposition()}\spxextra{DenseOperator method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:qsim.matrix.DenseOperator.spectral_decomposition}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{spectral\_decomposition}}}{\emph{\DUrole{n}{self}}, \emph{\DUrole{n}{hermitian}\DUrole{p}{:} \DUrole{n}{bool} \DUrole{o}{=} \DUrole{default_value}{False}}}{}
See base class.

\end{fulllineitems}

\index{tr() (DenseOperator method)@\spxentry{tr()}\spxextra{DenseOperator method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:qsim.matrix.DenseOperator.tr}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{tr}}}{\emph{\DUrole{n}{self}}}{{ $\rightarrow$ complex}}
See base class.

\end{fulllineitems}

\index{transpose() (DenseOperator method)@\spxentry{transpose()}\spxextra{DenseOperator method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:qsim.matrix.DenseOperator.transpose}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{transpose}}}{\emph{\DUrole{n}{self}}, \emph{\DUrole{n}{copy\_}\DUrole{p}{:} \DUrole{n}{bool} \DUrole{o}{=} \DUrole{default_value}{True}}}{{ $\rightarrow$ Union{[}ForwardRef(‘DenseOperator’), NoneType{]}}}
See base class.

\end{fulllineitems}

\index{truncate\_to\_subspace() (DenseOperator method)@\spxentry{truncate\_to\_subspace()}\spxextra{DenseOperator method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:qsim.matrix.DenseOperator.truncate_to_subspace}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{truncate\_to\_subspace}}}{\emph{\DUrole{n}{self}}, \emph{\DUrole{n}{subspace\_indices}\DUrole{p}{:} \DUrole{n}{Union\DUrole{p}{{[}}Sequence\DUrole{p}{{[}}int\DUrole{p}{{]}}\DUrole{p}{, }NoneType\DUrole{p}{{]}}}}, \emph{\DUrole{n}{map\_to\_closest\_unitary}\DUrole{p}{:} \DUrole{n}{bool} \DUrole{o}{=} \DUrole{default_value}{False}}}{{ $\rightarrow$ ’DenseOperator’}}
See base class.

\end{fulllineitems}


\end{fulllineitems}

\index{OperatorMatrix (class in qsim.matrix)@\spxentry{OperatorMatrix}\spxextra{class in qsim.matrix}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:qsim.matrix.OperatorMatrix}}\pysigline{\sphinxbfcode{\sphinxupquote{class }}\sphinxbfcode{\sphinxupquote{OperatorMatrix}}}
Bases: \sphinxcode{\sphinxupquote{abc.ABC}}
\begin{quote}

The abstract base class of the operator matrix for the qsim control
package.

It offers an identical interface to use sparse and dense matrices and has
hence the limitations of both representations in terms of usability.
\end{quote}
\begin{quote}\begin{description}
\item[{Attributes}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{data:}}] \leavevmode
The stored data. Its type is defined in subclasses.

\end{description}

\end{description}\end{quote}
\subsubsection*{Methods}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

\sphinxstylestrong{dag:}
&
Adjoint (dagger) of matrix. Also called hermitian conjugate.  tr: Trace of matrix.  prop(tau): The matrix exponential exp(A*tau) of the matrix A.  dexp(dirr, tau, compute\_expm=False) The deriative of the exponential in the given dirrection  clean: Delete stored data.  copy: Returns a deep copy of the object.  shape: Returns the shape of the matrix.  conj({\color{red}\bfseries{}copy\_}): Complex conjugate of the matrix. Returns a copy or operates in place.  conjugate({\color{red}\bfseries{}copy\_}): Alias for conj.  transpose({\color{red}\bfseries{}copy\_}): Transpose the matrix.  flatten: Returns the flattened matrix.  prop(tau): Convenience function to calculate the propagator of the Schroedinger equation.  exp(tau, method): Returns the matrix exponential.  dexp(direction, tau, method): Returns the matrix exponential and its frechet derivative.  kron(other): Kronecker matrix product.  identity\_like: ControlMatrix Returns an identity matrix of the same shape and type. Only for square matrices!  spectral\_decomposition(hermitian): Eigenvalues and eigenvectors.  \_\_getitem\_\_(identifier): Returns the matrix element corresponding to the identifier.  \_\_add\_\_(other): Addition with other instances of the same type or instances of the data storage type.  \_\_iadd\_\_(other): In place addition with other instances of the same type or instances of the data storage type.  \_\_mul\_\_(other): Either Matrix multiplication or scalar multiplication.  \_\_imul\_\_(other): Inplace matrix or scalar multiplication.  \_\_rmul\_\_(other): Reflective scalar or matrix multiplication.
\\
\hline
\sphinxstylestrong{.. todo:: * implement element wise division for scalars}
&\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\index{clean() (OperatorMatrix method)@\spxentry{clean()}\spxextra{OperatorMatrix method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:qsim.matrix.OperatorMatrix.clean}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{clean}}}{\emph{\DUrole{n}{self}}}{}
Delete stored data.

\end{fulllineitems}

\index{conj() (OperatorMatrix method)@\spxentry{conj()}\spxextra{OperatorMatrix method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:qsim.matrix.OperatorMatrix.conj}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{abstract }}\sphinxbfcode{\sphinxupquote{conj}}}{\emph{\DUrole{n}{self}}, \emph{\DUrole{n}{copy\_}\DUrole{p}{:} \DUrole{n}{bool} \DUrole{o}{=} \DUrole{default_value}{True}}}{{ $\rightarrow$ Union{[}ForwardRef(‘OperatorMatrix’), NoneType{]}}}
Complex conjugate of the matrix.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{copy\_}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} If false, then the operation is executed inplace. Otherwise returns
a new instance. Defaults to True.

\item[{Returns}] \leavevmode
\sphinxstylestrong{out} \textendash{} If {\color{red}\bfseries{}copy\_} is true, then a new instance otherwise self.

\item[{Return type}] \leavevmode
{\hyperref[\detokenize{qsim:qsim.matrix.OperatorMatrix}]{\sphinxcrossref{OperatorMatrix}}}

\end{description}\end{quote}

\end{fulllineitems}

\index{conjugate() (OperatorMatrix method)@\spxentry{conjugate()}\spxextra{OperatorMatrix method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:qsim.matrix.OperatorMatrix.conjugate}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{conjugate}}}{\emph{\DUrole{n}{self}}, \emph{\DUrole{n}{copy\_}\DUrole{p}{:} \DUrole{n}{bool} \DUrole{o}{=} \DUrole{default_value}{True}}}{{ $\rightarrow$ Union{[}ForwardRef(‘OperatorMatrix’), NoneType{]}}}
Alias for conj.

\end{fulllineitems}

\index{copy() (OperatorMatrix method)@\spxentry{copy()}\spxextra{OperatorMatrix method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:qsim.matrix.OperatorMatrix.copy}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{abstract }}\sphinxbfcode{\sphinxupquote{copy}}}{\emph{\DUrole{n}{self}}}{}
Return a deep copy of the control matrix.

\end{fulllineitems}

\index{dag() (OperatorMatrix method)@\spxentry{dag()}\spxextra{OperatorMatrix method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:qsim.matrix.OperatorMatrix.dag}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{abstract }}\sphinxbfcode{\sphinxupquote{dag}}}{\emph{\DUrole{n}{self}}, \emph{\DUrole{n}{copy\_}\DUrole{p}{:} \DUrole{n}{bool} \DUrole{o}{=} \DUrole{default_value}{True}}}{{ $\rightarrow$ Union{[}ForwardRef(‘OperatorMatrix’), NoneType{]}}}
Adjoint (dagger) of the matrix.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{copy\_}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} If false, then the operation is executed inplace. Otherwise returns
a new instance. Defaults to True.

\item[{Returns}] \leavevmode
\sphinxstylestrong{out} \textendash{} If {\color{red}\bfseries{}copy\_} is true, then a new instance otherwise self.

\item[{Return type}] \leavevmode
{\hyperref[\detokenize{qsim:qsim.matrix.OperatorMatrix}]{\sphinxcrossref{OperatorMatrix}}}

\end{description}\end{quote}

\end{fulllineitems}

\index{dexp() (OperatorMatrix method)@\spxentry{dexp()}\spxextra{OperatorMatrix method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:qsim.matrix.OperatorMatrix.dexp}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{abstract }}\sphinxbfcode{\sphinxupquote{dexp}}}{\emph{\DUrole{n}{self}}, \emph{\DUrole{n}{direction}\DUrole{p}{:} \DUrole{n}{‘OperatorMatrix’}}, \emph{\DUrole{n}{tau}\DUrole{p}{:} \DUrole{n}{complex} \DUrole{o}{=} \DUrole{default_value}{1}}, \emph{\DUrole{n}{compute\_expm}\DUrole{p}{:} \DUrole{n}{bool} \DUrole{o}{=} \DUrole{default_value}{False}}, \emph{\DUrole{n}{method}\DUrole{p}{:} \DUrole{n}{Union\DUrole{p}{{[}}str\DUrole{p}{, }NoneType\DUrole{p}{{]}}} \DUrole{o}{=} \DUrole{default_value}{None}}, \emph{\DUrole{n}{is\_skew\_hermitian}\DUrole{p}{:} \DUrole{n}{bool} \DUrole{o}{=} \DUrole{default_value}{False}}}{{ $\rightarrow$ Union{[}ForwardRef(‘OperatorMatrix’), Tuple{[}ForwardRef(‘OperatorMatrix’){]}{]}}}
The Frechet derivative of the exponential in the given direction
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{direction}} ({\hyperref[\detokenize{qsim:qsim.matrix.OperatorMatrix}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{OperatorMatrix}}}}}) \textendash{} The direction in which the Frechet derivative is to be calculated.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{tau}} (\sphinxstyleliteralemphasis{\sphinxupquote{complex}}) \textendash{} A scalar by which the matrix is multiplied before exponentiation.
This can be i. e. the length of a time segment if a propagator is
calculated.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{compute\_expm}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}) \textendash{} If set to false only the derivative is calculated and returned.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{method}} (\sphinxstyleliteralemphasis{\sphinxupquote{Optional}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{string}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} The method by which the exponential is calculated.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{is\_skew\_hermitian}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}) \textendash{} If set to true, the matrix is expected to be hermitian, which
allows to speed up the spectral decomposition.

\end{itemize}

\item[{Returns}] \leavevmode
\begin{itemize}
\item {} 
\sphinxstylestrong{prop} (\sphinxstyleemphasis{OperatorMatrix}) \textendash{} The matrix exponential: exp(self*tau) (Optional, if compute\_expm)

\item {} 
\sphinxstylestrong{derivative\_prop} (\sphinxstyleemphasis{OperatorMatrix}) \textendash{} The frechet derivative of the matrix exponential:
(exp((self+direction*dt)*tau)\sphinxhyphen{}exp(self*tau)) / dt

\end{itemize}


\end{description}\end{quote}

\end{fulllineitems}

\index{exp() (OperatorMatrix method)@\spxentry{exp()}\spxextra{OperatorMatrix method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:qsim.matrix.OperatorMatrix.exp}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{abstract }}\sphinxbfcode{\sphinxupquote{exp}}}{\emph{\DUrole{n}{self}}, \emph{\DUrole{n}{tau}\DUrole{p}{:} \DUrole{n}{complex} \DUrole{o}{=} \DUrole{default_value}{1}}, \emph{\DUrole{n}{method}\DUrole{p}{:} \DUrole{n}{Union\DUrole{p}{{[}}str\DUrole{p}{, }NoneType\DUrole{p}{{]}}} \DUrole{o}{=} \DUrole{default_value}{None}}, \emph{\DUrole{n}{is\_skew\_hermitian}\DUrole{p}{:} \DUrole{n}{bool} \DUrole{o}{=} \DUrole{default_value}{False}}}{{ $\rightarrow$ ’OperatorMatrix’}}
The matrix exponential.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{tau}} (\sphinxstyleliteralemphasis{\sphinxupquote{complex}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} A scalar by which the matrix is multiplied before calculating the
exponential.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{method}} (\sphinxstyleliteralemphasis{\sphinxupquote{string}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} The method by which the matrix exponential is calculated.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{is\_skew\_hermitian}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}) \textendash{} If set to true, the matrix is expected to be skew Hermitian, which
allows to speed up the spectral decomposition.

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxstylestrong{exponential} \textendash{} exponential = exp(A * tau) where A is the stored matrix.

\item[{Return type}] \leavevmode
{\hyperref[\detokenize{qsim:qsim.matrix.OperatorMatrix}]{\sphinxcrossref{OperatorMatrix}}}

\end{description}\end{quote}

\end{fulllineitems}

\index{flatten() (OperatorMatrix method)@\spxentry{flatten()}\spxextra{OperatorMatrix method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:qsim.matrix.OperatorMatrix.flatten}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{abstract }}\sphinxbfcode{\sphinxupquote{flatten}}}{\emph{\DUrole{n}{self}}}{{ $\rightarrow$ numpy.ndarray}}
Flattens the matrix.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxstylestrong{out} \textendash{} The flattened control matrix as one dimensional numpy array.

\item[{Return type}] \leavevmode
np.array

\end{description}\end{quote}

\end{fulllineitems}

\index{identity\_like() (OperatorMatrix method)@\spxentry{identity\_like()}\spxextra{OperatorMatrix method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:qsim.matrix.OperatorMatrix.identity_like}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{abstract }}\sphinxbfcode{\sphinxupquote{identity\_like}}}{\emph{\DUrole{n}{self}}}{{ $\rightarrow$ ’OperatorMatrix’}}
For square matrices, the identity of same dimension is returned.

\end{fulllineitems}

\index{kron() (OperatorMatrix method)@\spxentry{kron()}\spxextra{OperatorMatrix method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:qsim.matrix.OperatorMatrix.kron}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{abstract }}\sphinxbfcode{\sphinxupquote{kron}}}{\emph{\DUrole{n}{self}}, \emph{\DUrole{n}{other}\DUrole{p}{:} \DUrole{n}{‘OperatorMatrix’}}}{{ $\rightarrow$ ’OperatorMatrix’}}
Computes the kronecker matrix product with another matrix.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{other}} ({\hyperref[\detokenize{qsim:qsim.matrix.OperatorMatrix}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{OperatorMatrix}}}}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{np.ndarray}}) \textendash{} Second factor of the kronecker product.

\item[{Returns}] \leavevmode
\sphinxstylestrong{out} \textendash{} Operator matrix of the same type containing the product.

\item[{Return type}] \leavevmode
{\hyperref[\detokenize{qsim:qsim.matrix.OperatorMatrix}]{\sphinxcrossref{OperatorMatrix}}}

\item[{Raises}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{ValueError:}} \textendash{} If the operation is not defined for the input type.

\end{description}\end{quote}

\end{fulllineitems}

\index{shape() (OperatorMatrix property)@\spxentry{shape()}\spxextra{OperatorMatrix property}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:qsim.matrix.OperatorMatrix.shape}}\pysigline{\sphinxbfcode{\sphinxupquote{property }}\sphinxbfcode{\sphinxupquote{shape}}}
Returns the shape of the matrix.

\end{fulllineitems}

\index{spectral\_decomposition() (OperatorMatrix method)@\spxentry{spectral\_decomposition()}\spxextra{OperatorMatrix method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:qsim.matrix.OperatorMatrix.spectral_decomposition}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{abstract }}\sphinxbfcode{\sphinxupquote{spectral\_decomposition}}}{\emph{\DUrole{n}{self}}, \emph{\DUrole{n}{hermitian}\DUrole{p}{:} \DUrole{n}{bool} \DUrole{o}{=} \DUrole{default_value}{False}}}{}
Calculates the eigenvalues and eigenvectors of a square matrix.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{hermitian}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}) \textendash{} If True, the matrix is assumed to be hermitian.

\item[{Returns}] \leavevmode
\begin{itemize}
\item {} 
\sphinxstylestrong{eig\_vals} (\sphinxstyleemphasis{array of shape (n, )}) \textendash{} Eigenvalues

\item {} 
\sphinxstylestrong{eig\_vecs} (\sphinxstyleemphasis{array of shape (n, n)}) \textendash{} Right Eigenvectors. The normalized eigenvalue eig\_vals{[}i{]}
corresponds to the eigenvector eig\_vec{[}:,i{]}.

\end{itemize}


\end{description}\end{quote}

\end{fulllineitems}

\index{tr() (OperatorMatrix method)@\spxentry{tr()}\spxextra{OperatorMatrix method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:qsim.matrix.OperatorMatrix.tr}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{abstract }}\sphinxbfcode{\sphinxupquote{tr}}}{\emph{\DUrole{n}{self}}}{{ $\rightarrow$ complex}}
Trace of the matrix.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxstylestrong{trace} \textendash{} Trace of the matrix.

\item[{Return type}] \leavevmode
float

\end{description}\end{quote}

\end{fulllineitems}

\index{transpose() (OperatorMatrix method)@\spxentry{transpose()}\spxextra{OperatorMatrix method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:qsim.matrix.OperatorMatrix.transpose}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{abstract }}\sphinxbfcode{\sphinxupquote{transpose}}}{\emph{\DUrole{n}{self}}, \emph{\DUrole{n}{copy\_}\DUrole{p}{:} \DUrole{n}{bool} \DUrole{o}{=} \DUrole{default_value}{True}}}{{ $\rightarrow$ Union{[}ForwardRef(‘OperatorMatrix’), NoneType{]}}}
Transpose of the matrix.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{copy\_}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} If false, then the operation is executed inplace. Otherwise returns
a new instance. Defaults to True.

\item[{Returns}] \leavevmode
\sphinxstylestrong{out} \textendash{} If {\color{red}\bfseries{}copy\_} is true, then a new instance otherwise self.

\item[{Return type}] \leavevmode
{\hyperref[\detokenize{qsim:qsim.matrix.OperatorMatrix}]{\sphinxcrossref{OperatorMatrix}}}

\end{description}\end{quote}

\end{fulllineitems}

\index{truncate\_to\_subspace() (OperatorMatrix method)@\spxentry{truncate\_to\_subspace()}\spxextra{OperatorMatrix method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:qsim.matrix.OperatorMatrix.truncate_to_subspace}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{abstract }}\sphinxbfcode{\sphinxupquote{truncate\_to\_subspace}}}{\emph{\DUrole{n}{self}}, \emph{\DUrole{n}{subspace\_indices}\DUrole{p}{:} \DUrole{n}{Union\DUrole{p}{{[}}Sequence\DUrole{p}{{[}}int\DUrole{p}{{]}}\DUrole{p}{, }NoneType\DUrole{p}{{]}}}}, \emph{\DUrole{n}{map\_to\_closest\_unitary}\DUrole{p}{:} \DUrole{n}{bool} \DUrole{o}{=} \DUrole{default_value}{False}}}{{ $\rightarrow$ ’OperatorMatrix’}}
Convenience Function to truncate a control matrix to a subspace.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{subspace\_indices}} (\sphinxstyleliteralemphasis{\sphinxupquote{list of int}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} Indices of the subspace to which the control matrix shall be
truncated. If None, then a reference to the original matrix will be
returned.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{map\_to\_closest\_unitary}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}) \textendash{} If True, then the final propagator is mapped to the closest unitary
before the infidelity is evaluated.

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxstylestrong{truncated\_matrix} \textendash{} The truncated operator matrix.

\item[{Return type}] \leavevmode
‘OperatorMatrix’

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{SparseOperator (class in qsim.matrix)@\spxentry{SparseOperator}\spxextra{class in qsim.matrix}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:qsim.matrix.SparseOperator}}\pysigline{\sphinxbfcode{\sphinxupquote{class }}\sphinxbfcode{\sphinxupquote{SparseOperator}}}
Bases: {\hyperref[\detokenize{qsim:qsim.matrix.OperatorMatrix}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{qsim.matrix.OperatorMatrix}}}}}

\end{fulllineitems}

\index{closest\_unitary() (in module qsim.matrix)@\spxentry{closest\_unitary()}\spxextra{in module qsim.matrix}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:qsim.matrix.closest_unitary}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{closest\_unitary}}}{\emph{\DUrole{n}{matrix}\DUrole{p}{:} \DUrole{n}{{\hyperref[\detokenize{qsim:qsim.matrix.OperatorMatrix}]{\sphinxcrossref{qsim.matrix.OperatorMatrix}}}}}}{}
Calculate the unitary matrix U that is closest with respect to the
operator norm distance to the general matrix A.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{matrix}} ({\hyperref[\detokenize{qsim:qsim.matrix.OperatorMatrix}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{OperatorMatrix}}}}}) \textendash{} The matrix which shall be mapped to the closest unitary.

\item[{Returns}] \leavevmode
\sphinxstylestrong{unitary} \textendash{} The closest unitary to the propagator.

\item[{Return type}] \leavevmode
{\hyperref[\detokenize{qsim:qsim.matrix.OperatorMatrix}]{\sphinxcrossref{OperatorMatrix}}}

\end{description}\end{quote}

\end{fulllineitems}

\index{convert\_unitary\_to\_super\_operator() (in module qsim.matrix)@\spxentry{convert\_unitary\_to\_super\_operator()}\spxextra{in module qsim.matrix}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:qsim.matrix.convert_unitary_to_super_operator}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{convert\_unitary\_to\_super\_operator}}}{\emph{unitary: Union{[}ForwardRef(\textquotesingle{}OperatorMatrix\textquotesingle{}), \textless{}built\sphinxhyphen{}in function array\textgreater{}{]}}}{}~\begin{quote}

We assume that the unitary U shall be used to propagate a density matrix m
like

U m U\textasciicircum{}dag

which is equivalent to
\begin{equation*}
\begin{split}( U^st \otimes U)\end{split}
\end{equation*}\end{quote}

ec\{m\}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{unitary: OperatorMatrix or numpy array}}] \leavevmode
The unitary propagator.

\end{description}

\item[{Returns}] \leavevmode\begin{description}
\item[{unitary\_super\_operator:}] \leavevmode
The unitary propagator in the Lindblad formalism.

\end{description}

\item[{Raises}] \leavevmode\begin{description}
\item[{ValueError:}] \leavevmode
If the operation is not defined for the input type.

\end{description}

\end{description}\end{quote}

\end{fulllineitems}



\subsection{qsim.noise module}
\label{\detokenize{qsim:module-qsim.noise}}\label{\detokenize{qsim:qsim-noise-module}}\index{module@\spxentry{module}!qsim.noise@\spxentry{qsim.noise}}\index{qsim.noise@\spxentry{qsim.noise}!module@\spxentry{module}}
This file contains classes and helper functions for the generation of noise
traces.


\subsubsection{Classes}
\label{\detokenize{qsim:id17}}\begin{description}
\item[{{\hyperref[\detokenize{qsim:qsim.noise.NoiseTraceGenerator}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{NoiseTraceGenerator}}}}}}] \leavevmode
Abstract base class defining the interface of the noise trace generators.

\item[{{\hyperref[\detokenize{qsim:qsim.noise.NTGQuasiStatic}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{NTGQuasiStatic}}}}}}] \leavevmode
Generates noise traces for quasi static noise.

\item[{{\hyperref[\detokenize{qsim:qsim.noise.NTGColoredNoise}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{NTGColoredNoise}}}}}}] \leavevmode
Generates noise traces of arbitrary colored spectra.

\end{description}


\subsubsection{Functions}
\label{\detokenize{qsim:id18}}\begin{description}
\item[{{\hyperref[\detokenize{qsim:qsim.noise.bell_curve_1dim}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{bell\_curve\_1dim()}}}}}}] \leavevmode
One dimensional bell curve.

\item[{{\hyperref[\detokenize{qsim:qsim.noise.sample_1dim_gaussian_distribution}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{sample\_1dim\_gaussian\_distribution()}}}}}}] \leavevmode
Draw samples from the one dimensional bell curve.

\item[{{\hyperref[\detokenize{qsim:qsim.noise.bell_curve_2dim}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{bell\_curve\_2dim()}}}}}}] \leavevmode
Two dimensional bell curve.

\item[{{\hyperref[\detokenize{qsim:qsim.noise.sample_2dim_gaussian_distribution}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{sample\_2dim\_gaussian\_distribution()}}}}}}] \leavevmode
Draw samples from the two dimensional bell curve.

\item[{{\hyperref[\detokenize{qsim:qsim.noise.fast_colored_noise}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{fast\_colored\_noise()}}}}}}] \leavevmode
Samples an arbitrary colored noise spectrum.

\end{description}

\begin{sphinxadmonition}{note}{Notes}

The implementation was inspired by the optimal control package of QuTiP \sphinxcite{qsim:r8081257120ee-1}
(Quantum Toolbox in Python)
\end{sphinxadmonition}
\subsubsection*{References}
\index{NTGColoredNoise (class in qsim.noise)@\spxentry{NTGColoredNoise}\spxextra{class in qsim.noise}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:qsim.noise.NTGColoredNoise}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxbfcode{\sphinxupquote{NTGColoredNoise}}}{\emph{\DUrole{n}{n\_samples\_per\_trace}\DUrole{p}{:} \DUrole{n}{int}}, \emph{\DUrole{n}{noise\_spectral\_density}\DUrole{p}{:} \DUrole{n}{Callable}}, \emph{\DUrole{n}{dt}\DUrole{p}{:} \DUrole{n}{float}}, \emph{\DUrole{n}{n\_traces}\DUrole{p}{:} \DUrole{n}{int} \DUrole{o}{=} \DUrole{default_value}{1}}, \emph{\DUrole{n}{n\_noise\_operators}\DUrole{p}{:} \DUrole{n}{int} \DUrole{o}{=} \DUrole{default_value}{1}}, \emph{\DUrole{n}{always\_redraw\_samples}\DUrole{p}{:} \DUrole{n}{bool} \DUrole{o}{=} \DUrole{default_value}{True}}}{}
Bases: {\hyperref[\detokenize{qsim:qsim.noise.NoiseTraceGenerator}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{qsim.noise.NoiseTraceGenerator}}}}}

This class draws noise samples from noises of arbitrary colored spectra.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{n\_samples\_per\_trace}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Number of noise samples per trace.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{n\_traces}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} Number of noise traces. Default is 1.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{n\_noise\_operators}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} Number of noise operators. Default is 1.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{always\_redraw\_samples}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}) \textendash{} If true. The samples are always redrawn upon request. The stored samples
are not returned.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{noise\_spectral\_density}} (\sphinxstyleliteralemphasis{\sphinxupquote{function}}) \textendash{} The noise spectral density as function of frequency.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{dt}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} Time distance between two adjacent samples.

\end{itemize}

\end{description}\end{quote}
\index{noise\_spectral\_density (NTGColoredNoise attribute)@\spxentry{noise\_spectral\_density}\spxextra{NTGColoredNoise attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:qsim.noise.NTGColoredNoise.noise_spectral_density}}\pysigline{\sphinxbfcode{\sphinxupquote{noise\_spectral\_density}}}
The noise spectral density as function of frequency.
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
function

\end{description}\end{quote}

\end{fulllineitems}

\index{dt (NTGColoredNoise attribute)@\spxentry{dt}\spxextra{NTGColoredNoise attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:qsim.noise.NTGColoredNoise.dt}}\pysigline{\sphinxbfcode{\sphinxupquote{dt}}}
Time distance between two adjacent samples.
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
float

\end{description}\end{quote}

\end{fulllineitems}



\begin{fulllineitems}
\pysigline{\sphinxbfcode{\sphinxupquote{\_sample\_noise:~None}}}
Samples noise from an arbitrary colored spectrum.

\end{fulllineitems}



\sphinxstrong{See also:}

\begin{description}
\item[{\sphinxcode{\sphinxupquote{noise.NoiseTraceGenerator}}}] \leavevmode
Abstract Base Class

\end{description}


\index{plot\_periodogram() (NTGColoredNoise method)@\spxentry{plot\_periodogram()}\spxextra{NTGColoredNoise method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:qsim.noise.NTGColoredNoise.plot_periodogram}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{plot\_periodogram}}}{\emph{\DUrole{n}{self}}, \emph{\DUrole{n}{n\_average}\DUrole{p}{:} \DUrole{n}{int}}, \emph{\DUrole{n}{scaling}\DUrole{p}{:} \DUrole{n}{str} \DUrole{o}{=} \DUrole{default_value}{\textquotesingle{}density\textquotesingle{}}}, \emph{\DUrole{n}{log\_plot}\DUrole{p}{:} \DUrole{n}{Union\DUrole{p}{{[}}str\DUrole{p}{, }NoneType\DUrole{p}{{]}}} \DUrole{o}{=} \DUrole{default_value}{None}}, \emph{\DUrole{n}{draw\_plot}\DUrole{o}{=}\DUrole{default_value}{True}}}{}
Creates noise samples and plots the corresponding periodogram.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{n\_average}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Number of Periodograms which are averaged.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{scaling}} (\sphinxstyleliteralemphasis{\sphinxupquote{\{\textquotesingle{}density\textquotesingle{}}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{\textquotesingle{}spectrum\textquotesingle{}\}}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} If ‘density’ then the power spectral density in units of V**2/Hz is
plotted.
If ‘spectral’ then the power spectrum in units of V**2 is plotted.
Defaults to ‘density’.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{log\_plot}} (\sphinxstyleliteralemphasis{\sphinxupquote{\{None}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{\textquotesingle{}semilogy\textquotesingle{}}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{\textquotesingle{}semilogx\textquotesingle{}}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{\textquotesingle{}loglog\textquotesingle{}\}}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} If None, then the plot is not plotted logarithmically. If
‘semilogy’ only the y\sphinxhyphen{}axis is plotted logarithmically, if
‘semilogx’ only the x\sphinxhyphen{}axis is plotted logarithmically, if ‘loglog’
both axis are plotted logarithmically. Defaults to None.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{draw\_plot}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} If true, then the periodogram is plotted. Defaults to True.

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxstylestrong{deviation\_norm} \textendash{} The vector norm of the deviation between the actual power spectral
density and the power spectral densitry found in the periodogram.

\item[{Return type}] \leavevmode
float

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{NTGQuasiStatic (class in qsim.noise)@\spxentry{NTGQuasiStatic}\spxextra{class in qsim.noise}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:qsim.noise.NTGQuasiStatic}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxbfcode{\sphinxupquote{NTGQuasiStatic}}}{\emph{\DUrole{n}{standard\_deviation}\DUrole{p}{:} \DUrole{n}{List\DUrole{p}{{[}}float\DUrole{p}{{]}}}}, \emph{\DUrole{n}{n\_samples\_per\_trace}\DUrole{p}{:} \DUrole{n}{int}}, \emph{\DUrole{n}{n\_traces}\DUrole{p}{:} \DUrole{n}{int} \DUrole{o}{=} \DUrole{default_value}{1}}, \emph{\DUrole{n}{noise\_samples}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}numpy.ndarray\DUrole{p}{{]}}} \DUrole{o}{=} \DUrole{default_value}{None}}, \emph{\DUrole{n}{always\_redraw\_samples}\DUrole{p}{:} \DUrole{n}{bool} \DUrole{o}{=} \DUrole{default_value}{True}}, \emph{\DUrole{n}{sampling\_mode}\DUrole{p}{:} \DUrole{n}{str} \DUrole{o}{=} \DUrole{default_value}{\textquotesingle{}uncorrelated\_deterministic\textquotesingle{}}}}{}
Bases: {\hyperref[\detokenize{qsim:qsim.noise.NoiseTraceGenerator}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{qsim.noise.NoiseTraceGenerator}}}}}

This class draws noise traces of quasistatic noise.

The Noise distribution is assumed normal. It would not make sense to use
the attribute always\_redraw\_samples if the samples are deterministic,
and therefore always the same. If multiple noise operators are given, then
the noise is sampled for each one separately.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{standard\_deviation}} (\sphinxstyleliteralemphasis{\sphinxupquote{List}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{float}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{len:}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{n\_noise\_operators}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} Standard deviations of the noise assumed on the noise operators.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{n\_samples\_per\_trace}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Number of noise samples per trace.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{n\_traces}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} Number of noise traces. Default is 1.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{noise\_samples}} (\sphinxstyleliteralemphasis{\sphinxupquote{None}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{np.ndarray}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} shape: (n\_noise\_operators, n\_traces, n\_samples\_per\_trace)
Precalculated noise samples. Defaults to None.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{sampling\_mode}} (\sphinxstyleliteralemphasis{\sphinxupquote{\{\textquotesingle{}uncorrelated\_deterministic\textquotesingle{}}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{\textquotesingle{}monte\_carlo\textquotesingle{}\}}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} The method by which the quasi static noise samples are drawn. The
following are implemented:
‘uncorrelated\_deterministic’: No correlations are assumed. Each noise
operator is sampled n\_traces times deterministically.
‘monte\_carlo’: The noise is assumed to be correlated. Samples are drawn
by pseudo\sphinxhyphen{}randomly. Defaults to ‘uncorrelated\_deterministic’.

\end{itemize}

\end{description}\end{quote}
\index{standard\_deviation (NTGQuasiStatic attribute)@\spxentry{standard\_deviation}\spxextra{NTGQuasiStatic attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:qsim.noise.NTGQuasiStatic.standard_deviation}}\pysigline{\sphinxbfcode{\sphinxupquote{standard\_deviation}}}
Standard deviations of the noise assumed on the noise operators.
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
List{[}float{]}, len: (n\_noise\_operators)

\end{description}\end{quote}

\end{fulllineitems}



\sphinxstrong{See also:}

\begin{description}
\item[{\sphinxcode{\sphinxupquote{noise.NoiseTraceGenerator}}}] \leavevmode
Abstract Base Class

\end{description}


\index{n\_traces() (NTGQuasiStatic property)@\spxentry{n\_traces()}\spxextra{NTGQuasiStatic property}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:qsim.noise.NTGQuasiStatic.n_traces}}\pysigline{\sphinxbfcode{\sphinxupquote{property }}\sphinxbfcode{\sphinxupquote{n\_traces}}}
Number of traces.

The number of requested traces must be multiplied with the number of
standard deviations because if standard deviation is sampled
separately.

\end{fulllineitems}


\end{fulllineitems}

\index{NoiseTraceGenerator (class in qsim.noise)@\spxentry{NoiseTraceGenerator}\spxextra{class in qsim.noise}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:qsim.noise.NoiseTraceGenerator}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxbfcode{\sphinxupquote{NoiseTraceGenerator}}}{\emph{\DUrole{n}{n\_samples\_per\_trace}\DUrole{p}{:} \DUrole{n}{int}}, \emph{\DUrole{n}{always\_redraw\_samples}\DUrole{p}{:} \DUrole{n}{bool}}, \emph{\DUrole{n}{n\_traces}\DUrole{p}{:} \DUrole{n}{int} \DUrole{o}{=} \DUrole{default_value}{1}}, \emph{\DUrole{n}{n\_noise\_operators}\DUrole{p}{:} \DUrole{n}{int} \DUrole{o}{=} \DUrole{default_value}{1}}, \emph{\DUrole{n}{noise\_samples}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}numpy.ndarray\DUrole{p}{{]}}} \DUrole{o}{=} \DUrole{default_value}{None}}}{}
Bases: \sphinxcode{\sphinxupquote{abc.ABC}}

Abstract base class defining the interface of the noise trace generators.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{n\_samples\_per\_trace}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Number of noise samples per trace.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{n\_traces}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} Number of noise traces. Default is 1.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{n\_noise\_operators}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} Number of noise operators. Default is 1.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{noise\_samples}} (\sphinxstyleliteralemphasis{\sphinxupquote{None}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{np.ndarray}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} shape: (n\_noise\_operators, n\_traces, n\_samples\_per\_trace)
Precalculated noise samples. Defaults to None.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{always\_redraw\_samples}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}) \textendash{} If true. The samples are always redrawn upon request. The stored samples
are not returned.

\end{itemize}

\end{description}\end{quote}
\index{noise\_samples (NoiseTraceGenerator attribute)@\spxentry{noise\_samples}\spxextra{NoiseTraceGenerator attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:qsim.noise.NoiseTraceGenerator.noise_samples}}\pysigline{\sphinxbfcode{\sphinxupquote{noise\_samples}}}~\begin{quote}

shape: (n\_noise\_operators, n\_traces, n\_samples\_per\_trace)
\end{quote}

The noise samples stored or generated by this class.
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
np.ndarray,

\end{description}\end{quote}

\end{fulllineitems}

\index{n\_samples\_per\_trace (NoiseTraceGenerator attribute)@\spxentry{n\_samples\_per\_trace}\spxextra{NoiseTraceGenerator attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:qsim.noise.NoiseTraceGenerator.n_samples_per_trace}}\pysigline{\sphinxbfcode{\sphinxupquote{n\_samples\_per\_trace}}}
Number of noise samples per trace.
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
int

\end{description}\end{quote}

\end{fulllineitems}

\index{n\_traces (NoiseTraceGenerator attribute)@\spxentry{n\_traces}\spxextra{NoiseTraceGenerator attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:qsim.noise.NoiseTraceGenerator.n_traces}}\pysigline{\sphinxbfcode{\sphinxupquote{n\_traces}}}
Number of noise traces.
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
int

\end{description}\end{quote}

\end{fulllineitems}

\index{n\_noise\_operators (NoiseTraceGenerator attribute)@\spxentry{n\_noise\_operators}\spxextra{NoiseTraceGenerator attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:qsim.noise.NoiseTraceGenerator.n_noise_operators}}\pysigline{\sphinxbfcode{\sphinxupquote{n\_noise\_operators}}}
Number of noise operators.
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
int

\end{description}\end{quote}

\end{fulllineitems}

\index{always\_redraw\_samples (NoiseTraceGenerator attribute)@\spxentry{always\_redraw\_samples}\spxextra{NoiseTraceGenerator attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:qsim.noise.NoiseTraceGenerator.always_redraw_samples}}\pysigline{\sphinxbfcode{\sphinxupquote{always\_redraw\_samples}}}
If true. The samples are always redrawn upon request. The stored samples
are not returned.
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
bool

\end{description}\end{quote}

\end{fulllineitems}



\begin{fulllineitems}
\pysigline{\sphinxbfcode{\sphinxupquote{\_sample\_noise:~None}}}
Draw noise samples.

\end{fulllineitems}

\index{n\_noise\_operators() (NoiseTraceGenerator property)@\spxentry{n\_noise\_operators()}\spxextra{NoiseTraceGenerator property}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:id20}}\pysigline{\sphinxbfcode{\sphinxupquote{property }}\sphinxbfcode{\sphinxupquote{n\_noise\_operators}}}
Number of noise operators.

\end{fulllineitems}

\index{n\_samples\_per\_trace() (NoiseTraceGenerator property)@\spxentry{n\_samples\_per\_trace()}\spxextra{NoiseTraceGenerator property}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:id21}}\pysigline{\sphinxbfcode{\sphinxupquote{property }}\sphinxbfcode{\sphinxupquote{n\_samples\_per\_trace}}}
Number of samples per trace.

\end{fulllineitems}

\index{n\_traces() (NoiseTraceGenerator property)@\spxentry{n\_traces()}\spxextra{NoiseTraceGenerator property}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:id22}}\pysigline{\sphinxbfcode{\sphinxupquote{property }}\sphinxbfcode{\sphinxupquote{n\_traces}}}
Number of traces.

\end{fulllineitems}

\index{noise\_samples() (NoiseTraceGenerator property)@\spxentry{noise\_samples()}\spxextra{NoiseTraceGenerator property}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:id23}}\pysigline{\sphinxbfcode{\sphinxupquote{property }}\sphinxbfcode{\sphinxupquote{noise\_samples}}}~
\end{fulllineitems}


\end{fulllineitems}

\index{bell\_curve\_1dim() (in module qsim.noise)@\spxentry{bell\_curve\_1dim()}\spxextra{in module qsim.noise}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:qsim.noise.bell_curve_1dim}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{bell\_curve\_1dim}}}{\emph{\DUrole{n}{x}\DUrole{p}{:} \DUrole{n}{Union\DUrole{p}{{[}}numpy.ndarray\DUrole{p}{, }float\DUrole{p}{{]}}}}, \emph{\DUrole{n}{stdx}\DUrole{p}{:} \DUrole{n}{float}}}{{ $\rightarrow$ Union\DUrole{p}{{[}}numpy.ndarray\DUrole{p}{, }float\DUrole{p}{{]}}}}
One dimensional Bell curve.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{x}} (\sphinxstyleliteralemphasis{\sphinxupquote{np.ndarray}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} Point at which the bell curve is evaluated.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{stdx}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} Standard deviation of the bell curve.

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxstylestrong{out} \textendash{} Function values.

\item[{Return type}] \leavevmode
np.ndarray or scalar

\end{description}\end{quote}

\end{fulllineitems}

\index{bell\_curve\_2dim() (in module qsim.noise)@\spxentry{bell\_curve\_2dim()}\spxextra{in module qsim.noise}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:qsim.noise.bell_curve_2dim}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{bell\_curve\_2dim}}}{\emph{\DUrole{n}{x}\DUrole{p}{:} \DUrole{n}{Union\DUrole{p}{{[}}numpy.ndarray\DUrole{p}{, }float\DUrole{p}{{]}}}}, \emph{\DUrole{n}{stdx}\DUrole{p}{:} \DUrole{n}{float}}, \emph{\DUrole{n}{y}\DUrole{p}{:} \DUrole{n}{Union\DUrole{p}{{[}}numpy.ndarray\DUrole{p}{, }float\DUrole{p}{{]}}}}, \emph{\DUrole{n}{stdy}\DUrole{p}{:} \DUrole{n}{float}}}{{ $\rightarrow$ Union\DUrole{p}{{[}}numpy.ndarray\DUrole{p}{, }float\DUrole{p}{{]}}}}
Two dimensional Bell curve.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{x}} (\sphinxstyleliteralemphasis{\sphinxupquote{np.ndarray}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} First dimension value at which the bell curve is evaluated.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{stdx}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} Standard deviation of the bell curve in the x dimension.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{y}} (\sphinxstyleliteralemphasis{\sphinxupquote{np.ndarray}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} Second dimension value at which the bell curve is evaluated.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{stdy}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} Standard deviation of the bell curve in the y dimension.

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxstylestrong{out} \textendash{} Function values.

\item[{Return type}] \leavevmode
np.ndarray or scalar

\end{description}\end{quote}

\end{fulllineitems}

\index{fast\_colored\_noise() (in module qsim.noise)@\spxentry{fast\_colored\_noise()}\spxextra{in module qsim.noise}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:qsim.noise.fast_colored_noise}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{fast\_colored\_noise}}}{\emph{\DUrole{n}{spectral\_density}\DUrole{p}{:} \DUrole{n}{Callable}}, \emph{\DUrole{n}{dt}\DUrole{p}{:} \DUrole{n}{float}}, \emph{\DUrole{n}{n\_samples}\DUrole{p}{:} \DUrole{n}{int}}, \emph{\DUrole{n}{output\_shape}\DUrole{p}{:} \DUrole{n}{Tuple}}, \emph{\DUrole{n}{r\_power\_of\_two}\DUrole{o}{=}\DUrole{default_value}{False}}}{{ $\rightarrow$ numpy.ndarray}}
Generates noise traces of arbitrary colored noise.

Use this code for validation:
\textgreater{}\textgreater{}\textgreater{} from scipy import signal
\textgreater{}\textgreater{}\textgreater{} import matplotlib.pyplot as plt
\textgreater{}\textgreater{}\textgreater{} traces = fast\_colored\_noise(spectral\_density, dt, n\_samples,
\textgreater{}\textgreater{}\textgreater{}                             output\_shape)
\textgreater{}\textgreater{}\textgreater{} f\_max = 1 / dt
\textgreater{}\textgreater{}\textgreater{} f, S = signal.welch(traces, f\_max, axis=\sphinxhyphen{}1)
\textgreater{}\textgreater{}\textgreater{} plt.loglog(f, spectral\_density(f))
\textgreater{}\textgreater{}\textgreater{} plt.loglog(f, S.mean(axis=0))
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{spectral\_density}} (\sphinxstyleliteralemphasis{\sphinxupquote{Callable}}) \textendash{} The spectral density as function of frequency.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{dt}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} Time distance between two samples.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{n\_samples}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Number of samples.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{output\_shape}} (\sphinxstyleliteralemphasis{\sphinxupquote{tuple of int}}) \textendash{} Shape of the noise traces to be returned.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{r\_power\_of\_two}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}) \textendash{} If true, then n\_samples is rounded downwards to the next power of 2 for
an efficient fast fourier transform.

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxstylestrong{delta\_colored} \textendash{} Where actual\_n\_samples is n\_samples or the largest power of 2 smaller
than n\_samples if r\_power\_of\_two is true.

\item[{Return type}] \leavevmode
np.ndarray, shape(output\_shape, actual\_n\_samples)

\end{description}\end{quote}

\end{fulllineitems}

\index{sample\_1dim\_gaussian\_distribution() (in module qsim.noise)@\spxentry{sample\_1dim\_gaussian\_distribution()}\spxextra{in module qsim.noise}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:qsim.noise.sample_1dim_gaussian_distribution}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{sample\_1dim\_gaussian\_distribution}}}{\emph{\DUrole{n}{std1}\DUrole{p}{:} \DUrole{n}{float}}, \emph{\DUrole{n}{n\_samples}\DUrole{p}{:} \DUrole{n}{int}}}{{ $\rightarrow$ List}}
Returns ‘n\_samples’ samples from the one dimensional bell curve.

The samples are chosen such, that the integral over the bell curve between
two adjacent samples is always the same.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{std1}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} Standard deviation of the bell curve.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{n\_samples}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Number of samples returned.

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxstylestrong{selected\_x} \textendash{} Noise samples.

\item[{Return type}] \leavevmode
np.ndarray

\end{description}\end{quote}

\end{fulllineitems}

\index{sample\_2dim\_gaussian\_distribution() (in module qsim.noise)@\spxentry{sample\_2dim\_gaussian\_distribution()}\spxextra{in module qsim.noise}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:qsim.noise.sample_2dim_gaussian_distribution}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{sample\_2dim\_gaussian\_distribution}}}{\emph{\DUrole{n}{std1}\DUrole{p}{:} \DUrole{n}{float}}, \emph{\DUrole{n}{std2}\DUrole{p}{:} \DUrole{n}{float}}, \emph{\DUrole{n}{n\_samples}\DUrole{p}{:} \DUrole{n}{int}}}{}
Returns ‘n\_samples’ samples from the two dimensional bell curve.

The samples are chosen such, that the integral over the bell curve between
two adjacent samples is always the same.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{std1}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} Standard deviation of the bell curve in the first dimension.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{std2}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} Standard deviation of the bell curve in the second dimension.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{n\_samples}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Number of samples returned.

\end{itemize}

\item[{Returns}] \leavevmode
\begin{itemize}
\item {} 
\sphinxstylestrong{selected\_x} (\sphinxstyleemphasis{np.ndarray,}) \textendash{} X values of the noise samples.

\item {} 
\sphinxstylestrong{selected\_y} (\sphinxstyleemphasis{np.ndarray,}) \textendash{} Y values of the noise samples.

\end{itemize}


\end{description}\end{quote}

\end{fulllineitems}



\subsection{qsim.optimization\_data module}
\label{\detokenize{qsim:module-qsim.optimization_data}}\label{\detokenize{qsim:qsim-optimization-data-module}}\index{module@\spxentry{module}!qsim.optimization\_data@\spxentry{qsim.optimization\_data}}\index{qsim.optimization\_data@\spxentry{qsim.optimization\_data}!module@\spxentry{module}}
This module stores information about the optimization and its result.


\subsubsection{Classes}
\label{\detokenize{qsim:id24}}\begin{description}
\item[{{\hyperref[\detokenize{qsim:qsim.optimization_data.OptimizationResult}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{OptimizationResult}}}}}}] \leavevmode
Describes the information gained by an optimization run.

\item[{{\hyperref[\detokenize{qsim:qsim.optimization_data.OptimizationSummary}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{OptimizationSummary}}}}}}] \leavevmode
Describes the whole information gained during an optimization run.

\end{description}

\begin{sphinxadmonition}{note}{Notes}

The implementation was inspired by the optimal control package of QuTiP \sphinxcite{qsim:r2896d74c7423-1}
(Quantum Toolbox in Python)
\end{sphinxadmonition}
\subsubsection*{References}
\index{OptimizationResult (class in qsim.optimization\_data)@\spxentry{OptimizationResult}\spxextra{class in qsim.optimization\_data}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:qsim.optimization_data.OptimizationResult}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxbfcode{\sphinxupquote{OptimizationResult}}}{\emph{\DUrole{n}{final\_cost}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{indices}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{final\_parameters}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{final\_grad\_norm}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{init\_parameters}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{num\_iter}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{termination\_reason}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}not started yet\textquotesingle{}}}, \emph{\DUrole{n}{status}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{optimization\_stats}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{optimizer}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{optim\_summary}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
Bases: \sphinxcode{\sphinxupquote{object}}

Resulting data of the optimization.

An instance of this class is returned by the \sphinxtitleref{Optimizer} after the
optimization has terminated. It holds the results of the optimization and
can also contain an instance of \sphinxtitleref{OptimizationSummary} to describe the
optimization run itself, for example its convergence.
The parameters of the initialization method are all optional. This class is
intended to be initialized empty or loaded from a dictionary by the class
method {\hyperref[\detokenize{qsim:qsim.optimization_data.OptimizationResult.from_dict}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{from\_dict()}}}}}.
\index{termination\_reason (OptimizationResult attribute)@\spxentry{termination\_reason}\spxextra{OptimizationResult attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:qsim.optimization_data.OptimizationResult.termination_reason}}\pysigline{\sphinxbfcode{\sphinxupquote{termination\_reason}}}
Reason for the termination as string.
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
string

\end{description}\end{quote}

\end{fulllineitems}

\index{status (OptimizationResult attribute)@\spxentry{status}\spxextra{OptimizationResult attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:qsim.optimization_data.OptimizationResult.status}}\pysigline{\sphinxbfcode{\sphinxupquote{status}}}
The termination\_reason as integer. Like in scipy.OptimizeResult
None if the optimization has not started.
\sphinxhyphen{}1: improper input parameters status
0: the maximum number of function evaluations is exceeded.
1: gradient norm termination condition is satisfied.
2: cost function termination condition is satisfied.
3: minimal step size termination condition is satisfied.
4: Both 2 and 3 termination conditions are satisfied.
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
None or int

\end{description}\end{quote}

\end{fulllineitems}

\index{final\_cost (OptimizationResult attribute)@\spxentry{final\_cost}\spxextra{OptimizationResult attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:qsim.optimization_data.OptimizationResult.final_cost}}\pysigline{\sphinxbfcode{\sphinxupquote{final\_cost}}}
Value of the cost functions after the optimization.
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
float

\end{description}\end{quote}

\end{fulllineitems}

\index{final\_grad\_norm (OptimizationResult attribute)@\spxentry{final\_grad\_norm}\spxextra{OptimizationResult attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:qsim.optimization_data.OptimizationResult.final_grad_norm}}\pysigline{\sphinxbfcode{\sphinxupquote{final\_grad\_norm}}}
Norm of the gradient after the optimization.
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
float

\end{description}\end{quote}

\end{fulllineitems}

\index{num\_iter (OptimizationResult attribute)@\spxentry{num\_iter}\spxextra{OptimizationResult attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:qsim.optimization_data.OptimizationResult.num_iter}}\pysigline{\sphinxbfcode{\sphinxupquote{num\_iter}}}
Number of iterations in the optimization algorithm.
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
integer

\end{description}\end{quote}

\end{fulllineitems}

\index{init\_parameters (OptimizationResult attribute)@\spxentry{init\_parameters}\spxextra{OptimizationResult attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:qsim.optimization_data.OptimizationResult.init_parameters}}\pysigline{\sphinxbfcode{\sphinxupquote{init\_parameters}}}
The amplitudes at the start of the optimisation, where n\_t is
the number of time steps simulated and n\_par the number of
optimization parameters.
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
array, shape: (n\_t, n\_par)

\end{description}\end{quote}

\end{fulllineitems}

\index{final\_parameters (OptimizationResult attribute)@\spxentry{final\_parameters}\spxextra{OptimizationResult attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:qsim.optimization_data.OptimizationResult.final_parameters}}\pysigline{\sphinxbfcode{\sphinxupquote{final\_parameters}}}
The optimization parameters at the end of the optimisation, where n\_t
is the number of time steps simulated and n\_par the number of
optimization parameters.
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
array, shape: (n\_t, n\_par)

\end{description}\end{quote}

\end{fulllineitems}

\index{optimizer (OptimizationResult attribute)@\spxentry{optimizer}\spxextra{OptimizationResult attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:qsim.optimization_data.OptimizationResult.optimizer}}\pysigline{\sphinxbfcode{\sphinxupquote{optimizer}}}
Instance of the \sphinxtitleref{Optimizer} used to generate the result
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
\sphinxtitleref{Optimizer}

\end{description}\end{quote}

\end{fulllineitems}

\index{optim\_summary (OptimizationResult attribute)@\spxentry{optim\_summary}\spxextra{OptimizationResult attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:qsim.optimization_data.OptimizationResult.optim_summary}}\pysigline{\sphinxbfcode{\sphinxupquote{optim\_summary}}}
None if no intermediary results are saved. Otherwise the infidelity
during the optimization.
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
\sphinxtitleref{OptimizationSummary}

\end{description}\end{quote}

\end{fulllineitems}

\index{from\_dict() (OptimizationResult class method)@\spxentry{from\_dict()}\spxextra{OptimizationResult class method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:qsim.optimization_data.OptimizationResult.from_dict}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{classmethod }}\sphinxbfcode{\sphinxupquote{from\_dict}}}{\emph{\DUrole{n}{data\_dict}\DUrole{p}{:} \DUrole{n}{Dict}}}{}
Initialize the class with the information held in a dictionary.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{data\_dict}} (\sphinxstyleliteralemphasis{\sphinxupquote{dict}}) \textendash{} Class information.

\item[{Returns}] \leavevmode
\sphinxstylestrong{optim\_result} \textendash{} Class instance.

\item[{Return type}] \leavevmode
{\hyperref[\detokenize{qsim:qsim.optimization_data.OptimizationResult}]{\sphinxcrossref{OptimizationResult}}}

\end{description}\end{quote}

\end{fulllineitems}

\index{to\_dict() (OptimizationResult method)@\spxentry{to\_dict()}\spxextra{OptimizationResult method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:qsim.optimization_data.OptimizationResult.to_dict}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{to\_dict}}}{\emph{\DUrole{n}{self}}}{}
Writes the information held by this instance to a dictionary.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxstylestrong{dictionary} \textendash{} The information stored in a class instance as dictionary.

\item[{Return type}] \leavevmode
dict

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{OptimizationSummary (class in qsim.optimization\_data)@\spxentry{OptimizationSummary}\spxextra{class in qsim.optimization\_data}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:qsim.optimization_data.OptimizationSummary}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxbfcode{\sphinxupquote{OptimizationSummary}}}{\emph{\DUrole{n}{indices}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{iter\_num}\DUrole{o}{=}\DUrole{default_value}{0}}, \emph{\DUrole{n}{costs}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{gradients}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{parameters}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
Bases: \sphinxcode{\sphinxupquote{object}}

A summary of an optimization run.

This class saves the state of the optimization for each iteration. All
parameters for the initialization are optimal. The class is intended to be
either initialized empty.
\index{iter\_num (OptimizationSummary attribute)@\spxentry{iter\_num}\spxextra{OptimizationSummary attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:qsim.optimization_data.OptimizationSummary.iter_num}}\pysigline{\sphinxbfcode{\sphinxupquote{iter\_num}}}
Number of iterations stored. Serves as checksum to verify that full
data has been stored.
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
int

\end{description}\end{quote}

\end{fulllineitems}

\index{costs (OptimizationSummary attribute)@\spxentry{costs}\spxextra{OptimizationSummary attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:qsim.optimization_data.OptimizationSummary.costs}}\pysigline{\sphinxbfcode{\sphinxupquote{costs}}}
Evaluation results of the cost functions. The dictionary is sorted by
cost function indices. The lists hold one entry for each evaluation.
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
List{[}float{]}

\end{description}\end{quote}

\end{fulllineitems}

\index{indices (OptimizationSummary attribute)@\spxentry{indices}\spxextra{OptimizationSummary attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:qsim.optimization_data.OptimizationSummary.indices}}\pysigline{\sphinxbfcode{\sphinxupquote{indices}}}
The indices of the cost functions.
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
List{[}str{]}

\end{description}\end{quote}

\end{fulllineitems}

\index{gradients (OptimizationSummary attribute)@\spxentry{gradients}\spxextra{OptimizationSummary attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:qsim.optimization_data.OptimizationSummary.gradients}}\pysigline{\sphinxbfcode{\sphinxupquote{gradients}}}
Gradients of the cost functions. The dictionary is again sorted by cost
function indices and the lists hold one entry per evaluation.
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
List{[}array{]}

\end{description}\end{quote}

\end{fulllineitems}

\index{parameters (OptimizationSummary attribute)@\spxentry{parameters}\spxextra{OptimizationSummary attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:qsim.optimization_data.OptimizationSummary.parameters}}\pysigline{\sphinxbfcode{\sphinxupquote{parameters}}}
Optimization parameters during the optimization.
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
List{[}array{]}

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\subsection{qsim.optimize module}
\label{\detokenize{qsim:module-qsim.optimize}}\label{\detokenize{qsim:qsim-optimize-module}}\index{module@\spxentry{module}!qsim.optimize@\spxentry{qsim.optimize}}\index{qsim.optimize@\spxentry{qsim.optimize}!module@\spxentry{module}}
Optimization algorithms.

This module implements the optimization algorithms for the optimal control
problem.

Currently supported are:
\begin{quote}

LS\sphinxhyphen{}TRF \sphinxhyphen{} Least squares, Trust Region Reflective
\end{quote}


\subsubsection{Classes}
\label{\detokenize{qsim:id26}}\begin{description}
\item[{{\hyperref[\detokenize{qsim:qsim.optimize.Optimizer}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Optimizer}}}}}}] \leavevmode
Base class optimizer.

\item[{{\hyperref[\detokenize{qsim:qsim.optimize.LeastSquaresOptimizer}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{LeastSquaresOptimizer}}}}}}] \leavevmode
An interface to scipy’s least squares optimizer.

\item[{{\hyperref[\detokenize{qsim:qsim.optimize.WallTimeExceeded}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{WallTimeExceeded}}}}}}] \leavevmode
Exception for exceeding the optimization’s time limit.

\end{description}

\begin{sphinxadmonition}{note}{Notes}

The implementation was inspired by the optimal control package of QuTiP \sphinxcite{qsim:rf32976d78454-1}
(Quantum Toolbox in Python)
\end{sphinxadmonition}
\subsubsection*{References}
\index{LeastSquaresOptimizer (class in qsim.optimize)@\spxentry{LeastSquaresOptimizer}\spxextra{class in qsim.optimize}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:qsim.optimize.LeastSquaresOptimizer}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxbfcode{\sphinxupquote{LeastSquaresOptimizer}}}{\emph{\DUrole{n}{system\_simulator}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}{\hyperref[\detokenize{qsim:qsim.simulator.Simulator}]{\sphinxcrossref{qsim.simulator.Simulator}}}\DUrole{p}{{]}}} \DUrole{o}{=} \DUrole{default_value}{None}}, \emph{\DUrole{n}{termination\_cond}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}Dict\DUrole{p}{{]}}} \DUrole{o}{=} \DUrole{default_value}{None}}, \emph{\DUrole{n}{save\_intermediary\_steps}\DUrole{p}{:} \DUrole{n}{bool} \DUrole{o}{=} \DUrole{default_value}{False}}, \emph{\DUrole{n}{method}\DUrole{p}{:} \DUrole{n}{str} \DUrole{o}{=} \DUrole{default_value}{\textquotesingle{}trf\textquotesingle{}}}, \emph{\DUrole{n}{bounds}\DUrole{p}{:} \DUrole{n}{Union{[}numpy.ndarray, List, None{]}} \DUrole{o}{=} \DUrole{default_value}{None}}, \emph{\DUrole{n}{use\_jacobian\_function}\DUrole{o}{=}\DUrole{default_value}{True}}}{}
Bases: {\hyperref[\detokenize{qsim:qsim.optimize.Optimizer}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{qsim.optimize.Optimizer}}}}}

Uses the scipy least squares method for optimization.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{system\_simulator}} (\sphinxtitleref{Simulator}) \textendash{} The systems simulator.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{termination\_cond}} (\sphinxstyleliteralemphasis{\sphinxupquote{dict}}) \textendash{} Termination conditions.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{save\_intermediary\_steps}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} If False, only the simulation result is stored. Defaults to False.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{method}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} The optimization method used. Currently implemented are:
\sphinxhyphen{} ‘trf’: A trust region optimization algorithm. This is the default.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{bounds}} (\sphinxstyleliteralemphasis{\sphinxupquote{array}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{list of boundaries}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} The boundary conditions for the pulse optimizations. If none are given
then the pulse is assumed to take any real value.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{use\_jacobian\_function}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} If set to true, then the jacobians are calculated analytically.

\end{itemize}

\end{description}\end{quote}

\begin{sphinxadmonition}{note}{\label{\detokenize{qsim:id28}}Todo:}\begin{itemize}
\item {} \begin{description}
\item[{in the handling of a wall time exceeded message, the last parameters}] \leavevmode\begin{itemize}
\item {} 
are stored instead of the best ones.

\end{itemize}

\end{description}

\end{itemize}
\end{sphinxadmonition}
\index{run\_optimization() (LeastSquaresOptimizer method)@\spxentry{run\_optimization()}\spxextra{LeastSquaresOptimizer method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:qsim.optimize.LeastSquaresOptimizer.run_optimization}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{run\_optimization}}}{\emph{self}, \emph{initial\_control\_amplitudes: \textless{}built\sphinxhyphen{}in function array\textgreater{}}}{{ $\rightarrow$ {\hyperref[\detokenize{qsim:qsim.optimization_data.OptimizationResult}]{\sphinxcrossref{qsim.optimization\_data.OptimizationResult}}}}}
See base class.

\end{fulllineitems}


\end{fulllineitems}

\index{Optimizer (class in qsim.optimize)@\spxentry{Optimizer}\spxextra{class in qsim.optimize}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:qsim.optimize.Optimizer}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxbfcode{\sphinxupquote{Optimizer}}}{\emph{\DUrole{n}{system\_simulator}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}{\hyperref[\detokenize{qsim:qsim.simulator.Simulator}]{\sphinxcrossref{qsim.simulator.Simulator}}}\DUrole{p}{{]}}} \DUrole{o}{=} \DUrole{default_value}{None}}, \emph{\DUrole{n}{termination\_cond}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}Dict\DUrole{p}{{]}}} \DUrole{o}{=} \DUrole{default_value}{None}}, \emph{\DUrole{n}{save\_intermediary\_steps}\DUrole{p}{:} \DUrole{n}{bool} \DUrole{o}{=} \DUrole{default_value}{False}}}{}
Bases: \sphinxcode{\sphinxupquote{abc.ABC}}

Abstract base class for the optimizer.
\index{system\_simulator (Optimizer attribute)@\spxentry{system\_simulator}\spxextra{Optimizer attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:qsim.optimize.Optimizer.system_simulator}}\pysigline{\sphinxbfcode{\sphinxupquote{system\_simulator}}}
The simulator is the interface to the simulation.
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
{\hyperref[\detokenize{qsim:qsim.simulator.Simulator}]{\sphinxcrossref{Simulator}}}

\end{description}\end{quote}

\end{fulllineitems}

\index{pulse\_shape (Optimizer attribute)@\spxentry{pulse\_shape}\spxextra{Optimizer attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:qsim.optimize.Optimizer.pulse_shape}}\pysigline{\sphinxbfcode{\sphinxupquote{pulse\_shape}}}
The shape of the control amplitudes is saved and used for the
cost functions while the optimization function might need them flatted.
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
Tuple of int

\end{description}\end{quote}

\end{fulllineitems}

\index{TODO (Optimizer attribute)@\spxentry{TODO}\spxextra{Optimizer attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:qsim.optimize.Optimizer.TODO}}\pysigline{\sphinxbfcode{\sphinxupquote{TODO}}}~\begin{itemize}
\item {} 
implement termination conditions such as wall time!

\end{itemize}

\end{fulllineitems}

\index{cost\_fktn\_wrapper() (Optimizer method)@\spxentry{cost\_fktn\_wrapper()}\spxextra{Optimizer method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:qsim.optimize.Optimizer.cost_fktn_wrapper}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{cost\_fktn\_wrapper}}}{\emph{\DUrole{n}{self}}, \emph{\DUrole{n}{optimization\_parameters}}}{}
Wraps the cost function given by the simulator class.

The relevant information for the analysis is saved.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{optimization\_parameters}} (\sphinxstyleliteralemphasis{\sphinxupquote{np.array}}) \textendash{} Raw optimization parameters in a linear array.

\item[{Returns}] \leavevmode
\sphinxstylestrong{costs} \textendash{} Cost values.

\item[{Return type}] \leavevmode
np.array

\end{description}\end{quote}

\end{fulllineitems}

\index{cost\_jacobian\_wrapper() (Optimizer method)@\spxentry{cost\_jacobian\_wrapper()}\spxextra{Optimizer method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:qsim.optimize.Optimizer.cost_jacobian_wrapper}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{cost\_jacobian\_wrapper}}}{\emph{\DUrole{n}{self}}, \emph{\DUrole{n}{optimization\_parameters}}}{}
Wraps the cost Jacobian function given by the simulator class.

The relevant information for the analysis is saved.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{optimization\_parameters}} (\sphinxstyleliteralemphasis{\sphinxupquote{np.array}}) \textendash{} Raw optimization parameters in a linear array.

\item[{Returns}] \leavevmode
\sphinxstylestrong{jacobian} \textendash{} Jacobian of the cost functions.

\item[{Return type}] \leavevmode
np.array

\end{description}\end{quote}

\end{fulllineitems}

\index{prepare\_optimization() (Optimizer method)@\spxentry{prepare\_optimization()}\spxextra{Optimizer method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:qsim.optimize.Optimizer.prepare_optimization}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{prepare\_optimization}}}{\emph{\DUrole{n}{self}}, \emph{\DUrole{n}{initial\_optimization\_parameters}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}}{}
Prepare for the next optimization.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{initial\_optimization\_parameters}} (\sphinxstyleliteralemphasis{\sphinxupquote{array}}) \textendash{} shape (num\_t, num\_ctrl)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{stored in this class might be overwritten.}} (\sphinxstyleliteralemphasis{\sphinxupquote{Data}}) \textendash{} 

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{run\_optimization() (Optimizer method)@\spxentry{run\_optimization()}\spxextra{Optimizer method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:qsim.optimize.Optimizer.run_optimization}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{abstract }}\sphinxbfcode{\sphinxupquote{run\_optimization}}}{\emph{\DUrole{n}{self}}, \emph{\DUrole{n}{initial\_control\_amplitudes}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}}{{ $\rightarrow$ {\hyperref[\detokenize{qsim:qsim.optimization_data.OptimizationResult}]{\sphinxcrossref{qsim.optimization\_data.OptimizationResult}}}}}
Runs the optimization of the control amplitudes.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{initial\_control\_amplitudes}} (\sphinxstyleliteralemphasis{\sphinxupquote{array}}) \textendash{} shape (num\_t, num\_ctrl)

\item[{Returns}] \leavevmode
\sphinxstylestrong{optimization\_result} \textendash{} The resulting data of the simulation.

\item[{Return type}] \leavevmode
\sphinxtitleref{OptimizationResult}

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{PulseAnnealer (class in qsim.optimize)@\spxentry{PulseAnnealer}\spxextra{class in qsim.optimize}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:qsim.optimize.PulseAnnealer}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxbfcode{\sphinxupquote{PulseAnnealer}}}{\emph{\DUrole{n}{state}}, \emph{\DUrole{n}{bounds}}, \emph{\DUrole{n}{energy\_function}\DUrole{p}{:} \DUrole{n}{Callable}}, \emph{\DUrole{n}{step\_size}\DUrole{p}{:} \DUrole{n}{int} \DUrole{o}{=} \DUrole{default_value}{1}}, \emph{\DUrole{n}{step\_ratio}\DUrole{p}{:} \DUrole{n}{float} \DUrole{o}{=} \DUrole{default_value}{1.0}}, \emph{\DUrole{n}{Tmax}\DUrole{o}{=}\DUrole{default_value}{1.0}}, \emph{\DUrole{n}{Tmin}\DUrole{o}{=}\DUrole{default_value}{1e\sphinxhyphen{}08}}, \emph{\DUrole{n}{steps}\DUrole{p}{:} \DUrole{n}{int} \DUrole{o}{=} \DUrole{default_value}{100}}, \emph{\DUrole{n}{updates}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}int\DUrole{p}{{]}}} \DUrole{o}{=} \DUrole{default_value}{None}}}{}
Bases: \sphinxcode{\sphinxupquote{simanneal.anneal.Annealer}}

Simulated annealer for the discrete optimization of pulses.

The state is the pulse.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{state}} \textendash{} 

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{bounds}} \textendash{} 

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{energy\_function}} \textendash{} 

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{step\_size}} \textendash{} 

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{step\_ratio}} \textendash{} 

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{Tmax}} \textendash{} 

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{Tmin}} \textendash{} 

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{steps}} \textendash{} 

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{updates}} \textendash{} 

\end{itemize}

\end{description}\end{quote}
\index{energy() (PulseAnnealer method)@\spxentry{energy()}\spxextra{PulseAnnealer method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:qsim.optimize.PulseAnnealer.energy}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{energy}}}{\emph{\DUrole{n}{self}}}{}
The energy or cost function of the annealer.

\end{fulllineitems}

\index{move() (PulseAnnealer method)@\spxentry{move()}\spxextra{PulseAnnealer method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:qsim.optimize.PulseAnnealer.move}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{move}}}{\emph{\DUrole{n}{self}}}{}
Moving into a random direction.

\end{fulllineitems}


\end{fulllineitems}

\index{SimulatedAnnealing (class in qsim.optimize)@\spxentry{SimulatedAnnealing}\spxextra{class in qsim.optimize}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:qsim.optimize.SimulatedAnnealing}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxbfcode{\sphinxupquote{SimulatedAnnealing}}}{\emph{\DUrole{n}{system\_simulator}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}{\hyperref[\detokenize{qsim:qsim.simulator.Simulator}]{\sphinxcrossref{qsim.simulator.Simulator}}}\DUrole{p}{{]}}} \DUrole{o}{=} \DUrole{default_value}{None}}, \emph{\DUrole{n}{termination\_cond}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}Dict\DUrole{p}{{]}}} \DUrole{o}{=} \DUrole{default_value}{None}}, \emph{\DUrole{n}{save\_intermediary\_steps}\DUrole{p}{:} \DUrole{n}{bool} \DUrole{o}{=} \DUrole{default_value}{False}}, \emph{\DUrole{n}{initial\_temperature}\DUrole{p}{:} \DUrole{n}{float} \DUrole{o}{=} \DUrole{default_value}{1.0}}, \emph{\DUrole{n}{final\_temperature}\DUrole{p}{:} \DUrole{n}{float} \DUrole{o}{=} \DUrole{default_value}{1e\sphinxhyphen{}06}}, \emph{\DUrole{n}{step\_size}\DUrole{p}{:} \DUrole{n}{int} \DUrole{o}{=} \DUrole{default_value}{1}}, \emph{\DUrole{n}{step\_ratio}\DUrole{p}{:} \DUrole{n}{float} \DUrole{o}{=} \DUrole{default_value}{1.0}}, \emph{\DUrole{n}{bounds}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}numpy.ndarray\DUrole{p}{{]}}} \DUrole{o}{=} \DUrole{default_value}{None}}, \emph{\DUrole{n}{updates}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}int\DUrole{p}{{]}}} \DUrole{o}{=} \DUrole{default_value}{None}}}{}
Bases: {\hyperref[\detokenize{qsim:qsim.optimize.Optimizer}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{qsim.optimize.Optimizer}}}}}

This class uses simulated annealing for discrete optimization.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{initial\_temperature}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} Initial temperature for the annealing algorithm.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{step\_size}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Initial stepsize.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{interval}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Number of optimization iterations before the step size is reduced.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{bounds}} (\sphinxstyleliteralemphasis{\sphinxupquote{array of boundaries}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{shape:}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{2}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{num\_t}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{num\_ctrl}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} The boundary conditions for the pulse optimizations. bounds{[}0{]} should be
the lower bounds, and bounds{[}1{]} the upper ones.

\end{itemize}

\end{description}\end{quote}
\index{prepare\_optimization() (SimulatedAnnealing method)@\spxentry{prepare\_optimization()}\spxextra{SimulatedAnnealing method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:qsim.optimize.SimulatedAnnealing.prepare_optimization}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{prepare\_optimization}}}{\emph{\DUrole{n}{self}}, \emph{\DUrole{n}{initial\_optimization\_parameters}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}}{}
Prepare for the next optimization.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{initial\_optimization\_parameters}} (\sphinxstyleliteralemphasis{\sphinxupquote{array}}) \textendash{} shape (num\_t, num\_ctrl)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{stored in this class might be overwritten.}} (\sphinxstyleliteralemphasis{\sphinxupquote{Data}}) \textendash{} 

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{run\_optimization() (SimulatedAnnealing method)@\spxentry{run\_optimization()}\spxextra{SimulatedAnnealing method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:qsim.optimize.SimulatedAnnealing.run_optimization}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{run\_optimization}}}{\emph{\DUrole{n}{self}}, \emph{\DUrole{n}{initial\_control\_amplitudes}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}}{}
See base class.

\end{fulllineitems}


\end{fulllineitems}

\index{SimulatedAnnealingScipy (class in qsim.optimize)@\spxentry{SimulatedAnnealingScipy}\spxextra{class in qsim.optimize}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:qsim.optimize.SimulatedAnnealingScipy}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxbfcode{\sphinxupquote{SimulatedAnnealingScipy}}}{\emph{\DUrole{n}{system\_simulator}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}{\hyperref[\detokenize{qsim:qsim.simulator.Simulator}]{\sphinxcrossref{qsim.simulator.Simulator}}}\DUrole{p}{{]}}} \DUrole{o}{=} \DUrole{default_value}{None}}, \emph{\DUrole{n}{termination\_cond}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}Dict\DUrole{p}{{]}}} \DUrole{o}{=} \DUrole{default_value}{None}}, \emph{\DUrole{n}{save\_intermediary\_steps}\DUrole{p}{:} \DUrole{n}{bool} \DUrole{o}{=} \DUrole{default_value}{False}}, \emph{\DUrole{n}{temperature}\DUrole{p}{:} \DUrole{n}{float} \DUrole{o}{=} \DUrole{default_value}{1.0}}, \emph{\DUrole{n}{step\_size}\DUrole{p}{:} \DUrole{n}{int} \DUrole{o}{=} \DUrole{default_value}{1}}, \emph{\DUrole{n}{interval}\DUrole{p}{:} \DUrole{n}{int} \DUrole{o}{=} \DUrole{default_value}{50}}, \emph{\DUrole{n}{bounds}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}numpy.ndarray\DUrole{p}{{]}}} \DUrole{o}{=} \DUrole{default_value}{None}}}{}
Bases: {\hyperref[\detokenize{qsim:qsim.optimize.Optimizer}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{qsim.optimize.Optimizer}}}}}

This class uses simulated annealing for discrete optimization.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{temperature}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} Initial temperature for the annealing algorithm.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{step\_size}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Initial stepsize.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{interval}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Number of optimization iterations before the step size is reduced.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{bounds}} (\sphinxstyleliteralemphasis{\sphinxupquote{array of boundaries}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{shape:}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{2}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{num\_t}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{num\_ctrl}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} The boundary conditions for the pulse optimizations. bounds{[}0{]} should
be the lower bounds, and bounds{[}1{]} the upper ones.

\end{itemize}

\end{description}\end{quote}
\index{run\_optimization() (SimulatedAnnealingScipy method)@\spxentry{run\_optimization()}\spxextra{SimulatedAnnealingScipy method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:qsim.optimize.SimulatedAnnealingScipy.run_optimization}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{run\_optimization}}}{\emph{\DUrole{n}{self}}, \emph{\DUrole{n}{initial\_control\_amplitudes}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}}{}
See base class.

\end{fulllineitems}


\end{fulllineitems}

\index{WallTimeExceeded@\spxentry{WallTimeExceeded}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:qsim.optimize.WallTimeExceeded}}\pysigline{\sphinxbfcode{\sphinxupquote{exception }}\sphinxbfcode{\sphinxupquote{WallTimeExceeded}}}
Bases: \sphinxcode{\sphinxupquote{Exception}}

Raised when the time limit for the optimization is exceeded.

\end{fulllineitems}



\subsection{qsim.performance\_statistics module}
\label{\detokenize{qsim:module-qsim.performance_statistics}}\label{\detokenize{qsim:qsim-performance-statistics-module}}\index{module@\spxentry{module}!qsim.performance\_statistics@\spxentry{qsim.performance\_statistics}}\index{qsim.performance\_statistics@\spxentry{qsim.performance\_statistics}!module@\spxentry{module}}
Statistics of the use of computational resources.

\begin{sphinxadmonition}{note}{Notes}

The implementation was inspired by the optimal control package of QuTiP \sphinxcite{qsim:reaf67fb149ce-1}
(Quantum Toolbox in Python)
\end{sphinxadmonition}
\subsubsection*{References}
\index{PerformanceStatistics (class in qsim.performance\_statistics)@\spxentry{PerformanceStatistics}\spxextra{class in qsim.performance\_statistics}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:qsim.performance_statistics.PerformanceStatistics}}\pysigline{\sphinxbfcode{\sphinxupquote{class }}\sphinxbfcode{\sphinxupquote{PerformanceStatistics}}}
Bases: \sphinxcode{\sphinxupquote{object}}

Stores performance statistics.
\index{start\_t\_opt (PerformanceStatistics attribute)@\spxentry{start\_t\_opt}\spxextra{PerformanceStatistics attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:qsim.performance_statistics.PerformanceStatistics.start_t_opt}}\pysigline{\sphinxbfcode{\sphinxupquote{start\_t\_opt}}}
Time of the optimizations start. None if it has not been set yet.
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
float or None

\end{description}\end{quote}

\end{fulllineitems}

\index{end\_t\_opt (PerformanceStatistics attribute)@\spxentry{end\_t\_opt}\spxextra{PerformanceStatistics attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:qsim.performance_statistics.PerformanceStatistics.end_t_opt}}\pysigline{\sphinxbfcode{\sphinxupquote{end\_t\_opt}}}
Time of the optimizations end. None if it has not been set yet.
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
float or None

\end{description}\end{quote}

\end{fulllineitems}

\index{indices (PerformanceStatistics attribute)@\spxentry{indices}\spxextra{PerformanceStatistics attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:qsim.performance_statistics.PerformanceStatistics.indices}}\pysigline{\sphinxbfcode{\sphinxupquote{indices}}}
The indices of the cost functions.
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
List{[}str{]}

\end{description}\end{quote}

\end{fulllineitems}

\index{cost\_func\_eval\_times (PerformanceStatistics attribute)@\spxentry{cost\_func\_eval\_times}\spxextra{PerformanceStatistics attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:qsim.performance_statistics.PerformanceStatistics.cost_func_eval_times}}\pysigline{\sphinxbfcode{\sphinxupquote{cost\_func\_eval\_times}}}
List of durations of the evaluation of the cost functions.
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
list of float

\end{description}\end{quote}

\end{fulllineitems}

\index{grad\_func\_eval\_times (PerformanceStatistics attribute)@\spxentry{grad\_func\_eval\_times}\spxextra{PerformanceStatistics attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:qsim.performance_statistics.PerformanceStatistics.grad_func_eval_times}}\pysigline{\sphinxbfcode{\sphinxupquote{grad\_func\_eval\_times}}}
List of durations of the evaluation of the gradients.
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
list of float

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\subsection{qsim.simulator module}
\label{\detokenize{qsim:module-qsim.simulator}}\label{\detokenize{qsim:qsim-simulator-module}}\index{module@\spxentry{module}!qsim.simulator@\spxentry{qsim.simulator}}\index{qsim.simulator@\spxentry{qsim.simulator}!module@\spxentry{module}}
The Dynamics class provides the interface between the optimizer and the
actual simulation.


\subsubsection{Classes}
\label{\detokenize{qsim:id30}}\begin{description}
\item[{{\hyperref[\detokenize{qsim:qsim.simulator.Simulator}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Simulator}}}}}}] \leavevmode
Base class.

\end{description}

\begin{sphinxadmonition}{note}{Notes}

The current implementation is intended as minimal working requirement.
Especially the interface for the user is still object of discussion.
\begin{description}
\item[{Regarding the construction of class instance at run time:}] \leavevmode
This construction can be encapsulated by set functions working as an
internal builder pattern.
Or by explicit construction by the user and sharing the class instance.
This might be extended by convenience function as in pulseoptim of qutip
control.

\end{description}
\end{sphinxadmonition}

\begin{sphinxadmonition}{note}{Notes}

The implementation was inspired by the optimal control package of QuTiP \sphinxcite{qsim:r1b5c14c6e5c3-1}
(Quantum Toolbox in Python)
\end{sphinxadmonition}
\subsubsection*{References}
\index{Simulator (class in qsim.simulator)@\spxentry{Simulator}\spxextra{class in qsim.simulator}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:qsim.simulator.Simulator}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxbfcode{\sphinxupquote{Simulator}}}{\emph{\DUrole{n}{solvers}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}Sequence\DUrole{p}{{[}}{\hyperref[\detokenize{qsim:qsim.solver_algorithms.Solver}]{\sphinxcrossref{qsim.solver\_algorithms.Solver}}}\DUrole{p}{{]}}\DUrole{p}{{]}}}}, \emph{\DUrole{n}{cost\_fktns}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}Sequence\DUrole{p}{{[}}{\hyperref[\detokenize{qsim:qsim.cost_functions.CostFunction}]{\sphinxcrossref{qsim.cost\_functions.CostFunction}}}\DUrole{p}{{]}}\DUrole{p}{{]}}}}, \emph{\DUrole{n}{optimization\_parameters}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{num\_ctrl}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{times}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{num\_times}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{record\_performance\_statistics}\DUrole{p}{:} \DUrole{n}{bool} \DUrole{o}{=} \DUrole{default_value}{True}}, \emph{\DUrole{n}{numeric\_jacobian}\DUrole{p}{:} \DUrole{n}{bool} \DUrole{o}{=} \DUrole{default_value}{False}}, \emph{\DUrole{n}{cost\_fktn\_weights}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}Sequence\DUrole{p}{{[}}float\DUrole{p}{{]}}\DUrole{p}{{]}}} \DUrole{o}{=} \DUrole{default_value}{None}}}{}
Bases: \sphinxcode{\sphinxupquote{object}}

The Dynamics class provides the interface for the Optimizer class.

It wraps the infidelity and optionally the gradient of the infidelity.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{solvers}} ({\hyperref[\detokenize{qsim:qsim.solver_algorithms.Solver}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{Solver}}}}}) \textendash{} This object calculates the evolution of the system under
consideration.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{cost\_fktns}} (\sphinxstyleliteralemphasis{\sphinxupquote{List}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{FidelityComputer}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} These are the parameters which are optimized.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{optimization\_parameters}} (\sphinxstyleliteralemphasis{\sphinxupquote{numpy array}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} The initial pulse of shape (N\_t, N\_c) where N\_t is the
number of time steps and N\_c the number of controlled parameters.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{num\_ctrl}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} The number of controlled parameters N\_c.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{times}} (\sphinxstyleliteralemphasis{\sphinxupquote{numpy array}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{list}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} A one dimensional numpy array of the discrete time steps.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{num\_times}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} The number of time steps N\_t. Mainly for consistency checks.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{record\_performance\_statistics}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}) \textendash{} If True, then the evaluation times of the cost functions and their
gradients are stored.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{cost\_fktn\_weights}} (\sphinxstyleliteralemphasis{\sphinxupquote{list of float}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} The cost functions are multiplied with these weights during the
optimisation.

\end{itemize}

\end{description}\end{quote}
\index{solvers (Simulator attribute)@\spxentry{solvers}\spxextra{Simulator attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:qsim.simulator.Simulator.solvers}}\pysigline{\sphinxbfcode{\sphinxupquote{solvers}}}
Instances of the time slot computers used by the cost functions.
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
list of \sphinxtitleref{Solver}

\end{description}\end{quote}

\end{fulllineitems}

\index{cost\_fktns (Simulator attribute)@\spxentry{cost\_fktns}\spxextra{Simulator attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:qsim.simulator.Simulator.cost_fktns}}\pysigline{\sphinxbfcode{\sphinxupquote{cost\_fktns}}}
Instances of the cost functions which are to be optimized.
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
list of \sphinxtitleref{CostFunction}

\end{description}\end{quote}

\end{fulllineitems}

\index{stats (Simulator attribute)@\spxentry{stats}\spxextra{Simulator attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:qsim.simulator.Simulator.stats}}\pysigline{\sphinxbfcode{\sphinxupquote{stats}}}
Performance statistics.
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
Stats

\end{description}\end{quote}

\end{fulllineitems}

\index{TODO (Simulator attribute)@\spxentry{TODO}\spxextra{Simulator attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:qsim.simulator.Simulator.TODO}}\pysigline{\sphinxbfcode{\sphinxupquote{TODO}}}~\begin{itemize}
\item {} 
properly implement check method as parser

\item {} 
flags controlling how much data is saved

\item {} 
is the pulse attribute useful?

\item {} \begin{description}
\item[{check attributes for duplication: should num\_ctrl and num\_times be}] \leavevmode
saved at this level?

\end{description}

\item {} 
move cost function weights to the optimizer

\end{itemize}

\end{fulllineitems}

\index{check() (Simulator method)@\spxentry{check()}\spxextra{Simulator method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:qsim.simulator.Simulator.check}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{check}}}{\emph{\DUrole{n}{self}}}{}
Verifies the shape of the time steps and the pulse.

\end{fulllineitems}

\index{compare\_numeric\_to\_analytic\_gradient() (Simulator method)@\spxentry{compare\_numeric\_to\_analytic\_gradient()}\spxextra{Simulator method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:qsim.simulator.Simulator.compare_numeric_to_analytic_gradient}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{compare\_numeric\_to\_analytic\_gradient}}}{\emph{\DUrole{n}{self}}, \emph{\DUrole{n}{pulse}\DUrole{p}{:} \DUrole{n}{Union\DUrole{p}{{[}}numpy.ndarray\DUrole{p}{, }NoneType\DUrole{p}{{]}}} \DUrole{o}{=} \DUrole{default_value}{None}}, \emph{\DUrole{n}{delta\_eps}\DUrole{p}{:} \DUrole{n}{float} \DUrole{o}{=} \DUrole{default_value}{1e\sphinxhyphen{}08}}, \emph{\DUrole{n}{symmetric}\DUrole{p}{:} \DUrole{n}{bool} \DUrole{o}{=} \DUrole{default_value}{False}}}{}
This function compares the numerical to the analytical gradient in order
to serve as a consistency check.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{pulse}} (\sphinxstyleliteralemphasis{\sphinxupquote{array}}) \textendash{} The pulse at which the gradient is evaluated.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{delta\_eps}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} The finite difference.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{symmetric}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}) \textendash{} If True, then the finite differences are evaluated symmetrically
around the pulse. Otherwise by forward finite differences.

\end{itemize}

\item[{Returns}] \leavevmode
\begin{itemize}
\item {} 
\sphinxstylestrong{gradient\_difference\_norm} (\sphinxstyleemphasis{float}) \textendash{} The matrix norm of the difference between the numeric and analytic
gradient.

\item {} 
\sphinxstylestrong{gradient\_difference\_relative} (\sphinxstyleemphasis{float}) \textendash{} The relation of the aforementioned norm of the difference matrix
and the average norm of the numeric and analytic gradient.

\end{itemize}


\end{description}\end{quote}

\end{fulllineitems}

\index{cost\_indices() (Simulator property)@\spxentry{cost\_indices()}\spxextra{Simulator property}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:qsim.simulator.Simulator.cost_indices}}\pysigline{\sphinxbfcode{\sphinxupquote{property }}\sphinxbfcode{\sphinxupquote{cost\_indices}}}
Indices of cost functions.

\end{fulllineitems}

\index{numeric\_gradient() (Simulator method)@\spxentry{numeric\_gradient()}\spxextra{Simulator method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:qsim.simulator.Simulator.numeric_gradient}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{numeric\_gradient}}}{\emph{\DUrole{n}{self}}, \emph{\DUrole{n}{pulse}\DUrole{p}{:} \DUrole{n}{Union\DUrole{p}{{[}}numpy.ndarray\DUrole{p}{, }NoneType\DUrole{p}{{]}}} \DUrole{o}{=} \DUrole{default_value}{None}}, \emph{\DUrole{n}{delta\_eps}\DUrole{p}{:} \DUrole{n}{float} \DUrole{o}{=} \DUrole{default_value}{1e\sphinxhyphen{}08}}, \emph{\DUrole{n}{symmetric}\DUrole{p}{:} \DUrole{n}{bool} \DUrole{o}{=} \DUrole{default_value}{False}}}{{ $\rightarrow$ numpy.ndarray}}
This function calculates the gradient numerically and analytically
in order to serve as a consistency check.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{pulse}} (\sphinxstyleliteralemphasis{\sphinxupquote{array}}) \textendash{} The pulse at which the gradient is evaluated.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{delta\_eps}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} The finite difference.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{symmetric}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}) \textendash{} If True, then the finite differences are evaluated symmetrically
around the pulse. Otherwise by forward finite differences.

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxstylestrong{gradients} \textendash{} The gradients as numpy array of shape (n\_time, n\_func, n\_opers).

\item[{Return type}] \leavevmode
array

\end{description}\end{quote}

\end{fulllineitems}

\index{pulse() (Simulator property)@\spxentry{pulse()}\spxextra{Simulator property}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:qsim.simulator.Simulator.pulse}}\pysigline{\sphinxbfcode{\sphinxupquote{property }}\sphinxbfcode{\sphinxupquote{pulse}}}
Optimization parameters.

\end{fulllineitems}

\index{wrapped\_cost\_functions() (Simulator method)@\spxentry{wrapped\_cost\_functions()}\spxextra{Simulator method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:qsim.simulator.Simulator.wrapped_cost_functions}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{wrapped\_cost\_functions}}}{\emph{\DUrole{n}{self}}, \emph{\DUrole{n}{pulse}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
Wraps the cost functions of the fidelity computer.

This function coordinates the complete simulation including the
application of the transfer function, the execution of the time
slot computer and the evaluation of the actual cost functions.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{pulse}} (\sphinxstyleliteralemphasis{\sphinxupquote{numpy array optional}}) \textendash{} If no pulse is specified the cost function is evaluated for the
attribute pulse.

\item[{Returns}] \leavevmode
\begin{itemize}
\item {} 
\sphinxstylestrong{costs} (\sphinxstyleemphasis{numpy array}) \textendash{} Array of costs (i.e. infidelities).

\item {} 
\sphinxstylestrong{costs\_indices} (\sphinxstyleemphasis{list of str}) \textendash{} Names of the costs.

\end{itemize}


\end{description}\end{quote}

\end{fulllineitems}

\index{wrapped\_jac\_function() (Simulator method)@\spxentry{wrapped\_jac\_function()}\spxextra{Simulator method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:qsim.simulator.Simulator.wrapped_jac_function}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{wrapped\_jac\_function}}}{\emph{\DUrole{n}{self}}, \emph{\DUrole{n}{pulse}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
Wraps the gradient calculation functions of the fidelity computer.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{pulse}} (\sphinxstyleliteralemphasis{\sphinxupquote{numpy array}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} shape: (num\_t, num\_ctrl) If no pulse is specified the cost function
is evaluated for the attribute pulse.

\item[{Returns}] \leavevmode
\sphinxstylestrong{jac} \textendash{} Array of gradients of shape (num\_t, num\_func, num\_amp).

\item[{Return type}] \leavevmode
numpy array

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\subsection{qsim.solver\_algorithms module}
\label{\detokenize{qsim:module-qsim.solver_algorithms}}\label{\detokenize{qsim:qsim-solver-algorithms-module}}\index{module@\spxentry{module}!qsim.solver\_algorithms@\spxentry{qsim.solver\_algorithms}}\index{qsim.solver\_algorithms@\spxentry{qsim.solver\_algorithms}!module@\spxentry{module}}
The Solver calculates the propagators as solutions to Schroedinger’s
equation or a master equation in Lindblad form.

If requested, also derivatives of the propagators by the control amplitudes are
calculated or approximated. Please note that this Docstring only documents the
classes currently supported.


\subsubsection{Classes}
\label{\detokenize{qsim:id32}}\begin{description}
\item[{{\hyperref[\detokenize{qsim:qsim.solver_algorithms.Solver}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Solver}}}}}}] \leavevmode
Abstract base class of the time slot computers.

\item[{{\hyperref[\detokenize{qsim:qsim.solver_algorithms.SchroedingerSolver}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{SchroedingerSolver}}}}}}] \leavevmode
Solver for the the unperturbed Schroedinger equation.

\item[{{\hyperref[\detokenize{qsim:qsim.solver_algorithms.SchroedingerSMonteCarlo}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{SchroedingerSMonteCarlo}}}}}}] \leavevmode
Solver for the Schroedinger equation under the influence of noise.

\item[{{\hyperref[\detokenize{qsim:qsim.solver_algorithms.SchroedingerSMCControlNoise}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{SchroedingerSMCControlNoise}}}}}}] \leavevmode
Solver for the Schroedinger equation under the influence of noise affecting
the control terms.

\item[{{\hyperref[\detokenize{qsim:qsim.solver_algorithms.LindbladSolver}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{LindbladSolver}}}}}}] \leavevmode
Solves the master equation in Lindblad form.

\end{description}

\begin{sphinxadmonition}{note}{Notes}

The implementation was inspired by the optimal control package of QuTiP \sphinxcite{qsim:rb0fedd4c4e4c-1}
(Quantum Toolbox in Python)
\end{sphinxadmonition}
\subsubsection*{References}
\index{LindbladSControlNoise (class in qsim.solver\_algorithms)@\spxentry{LindbladSControlNoise}\spxextra{class in qsim.solver\_algorithms}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:qsim.solver_algorithms.LindbladSControlNoise}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxbfcode{\sphinxupquote{LindbladSControlNoise}}}{\emph{\DUrole{n}{h\_drift}}, \emph{\DUrole{n}{h\_ctrl}}, \emph{\DUrole{n}{initial\_state}}, \emph{\DUrole{n}{tau}}, \emph{\DUrole{n}{ctrl\_amps}}, \emph{\DUrole{n}{transfer\_function}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{calculate\_unitary\_derivatives}\DUrole{o}{=}\DUrole{default_value}{True}}, \emph{\DUrole{n}{filter\_function\_h\_n}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{exponential\_method}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{lindblad\_operators}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{constant\_lindblad\_operators}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{noise\_psd}\DUrole{o}{=}\DUrole{default_value}{1}}}{}
Bases: {\hyperref[\detokenize{qsim:qsim.solver_algorithms.LindbladSolver}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{qsim.solver\_algorithms.LindbladSolver}}}}}

Special case of the Lindblad master equation. It considers white noise on
the control parameters. The same functionality should be implementable
with the parent class, but less convenient.

\end{fulllineitems}

\index{LindbladSolver (class in qsim.solver\_algorithms)@\spxentry{LindbladSolver}\spxextra{class in qsim.solver\_algorithms}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:qsim.solver_algorithms.LindbladSolver}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxbfcode{\sphinxupquote{LindbladSolver}}}{\emph{\DUrole{n}{h\_drift}\DUrole{p}{:} \DUrole{n}{List\DUrole{p}{{[}}{\hyperref[\detokenize{qsim:qsim.matrix.OperatorMatrix}]{\sphinxcrossref{qsim.matrix.OperatorMatrix}}}\DUrole{p}{{]}}}}, \emph{\DUrole{n}{h\_ctrl}\DUrole{p}{:} \DUrole{n}{List\DUrole{p}{{[}}{\hyperref[\detokenize{qsim:qsim.matrix.OperatorMatrix}]{\sphinxcrossref{qsim.matrix.OperatorMatrix}}}\DUrole{p}{{]}}}}, \emph{\DUrole{n}{initial\_state}\DUrole{p}{:} \DUrole{n}{{\hyperref[\detokenize{qsim:qsim.matrix.OperatorMatrix}]{\sphinxcrossref{qsim.matrix.OperatorMatrix}}}}}, \emph{\DUrole{n}{tau}\DUrole{p}{:} \DUrole{n}{List\DUrole{p}{{[}}float\DUrole{p}{{]}}}}, \emph{\DUrole{n}{ctrl\_amps}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}numpy.array\DUrole{p}{{]}}} \DUrole{o}{=} \DUrole{default_value}{None}}, \emph{\DUrole{n}{calculate\_unitary\_derivatives}\DUrole{p}{:} \DUrole{n}{bool} \DUrole{o}{=} \DUrole{default_value}{False}}, \emph{\DUrole{n}{filter\_function\_h\_n}\DUrole{p}{:} \DUrole{n}{Union{[}List{[}List{]}, numpy.array, None{]}} \DUrole{o}{=} \DUrole{default_value}{None}}, \emph{\DUrole{n}{filter\_function\_basis}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}filter\_functions.basis.Basis\DUrole{p}{{]}}} \DUrole{o}{=} \DUrole{default_value}{None}}, \emph{\DUrole{n}{exponential\_method}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}str\DUrole{p}{{]}}} \DUrole{o}{=} \DUrole{default_value}{None}}, \emph{\DUrole{n}{frechet\_deriv\_approx\_method}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}str\DUrole{p}{{]}}} \DUrole{o}{=} \DUrole{default_value}{None}}, \emph{\DUrole{n}{initial\_diss\_super\_op}\DUrole{p}{:} \DUrole{n}{List\DUrole{p}{{[}}{\hyperref[\detokenize{qsim:qsim.matrix.OperatorMatrix}]{\sphinxcrossref{qsim.matrix.OperatorMatrix}}}\DUrole{p}{{]}}} \DUrole{o}{=} \DUrole{default_value}{None}}, \emph{\DUrole{n}{lindblad\_operators}\DUrole{p}{:} \DUrole{n}{List\DUrole{p}{{[}}{\hyperref[\detokenize{qsim:qsim.matrix.OperatorMatrix}]{\sphinxcrossref{qsim.matrix.OperatorMatrix}}}\DUrole{p}{{]}}} \DUrole{o}{=} \DUrole{default_value}{None}}, \emph{\DUrole{n}{prefactor\_function}\DUrole{p}{:} \DUrole{n}{Callable\DUrole{p}{{[}}\DUrole{p}{{[}}numpy.array\DUrole{p}{{]}}\DUrole{p}{, }numpy.array\DUrole{p}{{]}}} \DUrole{o}{=} \DUrole{default_value}{None}}, \emph{\DUrole{n}{prefactor\_derivative\_function}\DUrole{p}{:} \DUrole{n}{Callable\DUrole{p}{{[}}\DUrole{p}{{[}}numpy.array\DUrole{p}{{]}}\DUrole{p}{, }numpy.array\DUrole{p}{{]}}} \DUrole{o}{=} \DUrole{default_value}{None}}, \emph{\DUrole{n}{super\_operator\_function}\DUrole{p}{:} \DUrole{n}{Callable\DUrole{p}{{[}}\DUrole{p}{{[}}numpy.array\DUrole{p}{{]}}\DUrole{p}{, }List\DUrole{p}{{[}}{\hyperref[\detokenize{qsim:qsim.matrix.OperatorMatrix}]{\sphinxcrossref{qsim.matrix.OperatorMatrix}}}\DUrole{p}{{]}}\DUrole{p}{{]}}} \DUrole{o}{=} \DUrole{default_value}{None}}, \emph{\DUrole{n}{super\_operator\_derivative\_function}\DUrole{p}{:} \DUrole{n}{Callable\DUrole{p}{{[}}\DUrole{p}{{[}}numpy.array\DUrole{p}{{]}}\DUrole{p}{, }List\DUrole{p}{{[}}List\DUrole{p}{{[}}{\hyperref[\detokenize{qsim:qsim.matrix.OperatorMatrix}]{\sphinxcrossref{qsim.matrix.OperatorMatrix}}}\DUrole{p}{{]}}\DUrole{p}{{]}}\DUrole{p}{{]}}} \DUrole{o}{=} \DUrole{default_value}{None}}, \emph{\DUrole{n}{is\_skew\_hermitian}\DUrole{p}{:} \DUrole{n}{bool} \DUrole{o}{=} \DUrole{default_value}{False}}, \emph{\DUrole{n}{transfer\_function}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}{\hyperref[\detokenize{qsim:qsim.transfer_function.TransferFunction}]{\sphinxcrossref{qsim.transfer\_function.TransferFunction}}}\DUrole{p}{{]}}} \DUrole{o}{=} \DUrole{default_value}{None}}, \emph{\DUrole{n}{amplitude\_function}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}{\hyperref[\detokenize{qsim:qsim.amplitude_functions.AmplitudeFunction}]{\sphinxcrossref{qsim.amplitude\_functions.AmplitudeFunction}}}\DUrole{p}{{]}}} \DUrole{o}{=} \DUrole{default_value}{None}}}{}
Bases: {\hyperref[\detokenize{qsim:qsim.solver_algorithms.SchroedingerSolver}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{qsim.solver\_algorithms.SchroedingerSolver}}}}}
\begin{quote}

Solves a master equation for an open quantum system in the Markov
approximation using the Lindblad super operator formalism.

The master equation to be solved is

d
\end{quote}

ho / dt = i {[}
ho, H{]} + sum\_k (L\_k
ho L\_k\textasciicircum{}dag
\begin{itemize}
\item {} 
.5 L\_k\textasciicircum{}dag L\_k

\end{itemize}

ho \sphinxhyphen{} .5
ho L\_k\textasciicircum{}dag L\_k)
\begin{quote}

with the Lindblad operators L\_k. The solution is calculated as
\end{quote}

ho(t) = exp{[}(\sphinxhyphen{}i mathcal\{H\} + mathcal\{G\})t{]}
ho(0)
\begin{quote}

with the dissipative super operator

mathcal\{G\} = sum\_k D(L\_k)
\begin{description}
\item[{D(L) = L\textasciicircum{}st otimes L \sphinxhyphen{} .5 I otimes (L\textasciicircum{}dag L)}] \leavevmode\begin{itemize}
\item {} 
.5 (L\textasciicircum{}T L\textasciicircum{}st) otimes I

\end{itemize}

\end{description}

The dissipation super operator can be given in three different ways.

1. A nested list of dissipation super operators D(L\_k) as control
matrices.
2. A nested list of Lindblad operators L as control matrices.
3. A function handle receiving the control amplitudes as sole argument and
returning a dissipation super operator as list of control matrices.

Optionally a prefactor function can be given for 1. and 2. This function
receives the control parameters and returns an array of the shape
num\_t x num\_l where num\_t is the number of time steps in the control and
num\_l is the number of Lindblad operators or dissipation super operators.

If multiple construction arguments are given, the implementation
prioritises the function (3.) over the Lindblad operators (2.) over the
dissipation super operator (1.).
\end{quote}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{initial\_diss\_super\_op: List{[}ControlMatrix{]}, len: num\_l}}] \leavevmode\begin{quote}

Initial dissipation super operator; num\_l is the number of
Lindbladians. Set if you want to use (1.) (See documentation above!).
The control matrices are expected to be of shape (dim, dim) where dim
is the dimension of the system.
\end{quote}
\begin{description}
\item[{lindblad\_operators: List{[}ControlMatrix{]}, len: num\_l}] \leavevmode
Lindblad operators; num\_l is the number of Lindbladians. Set if you
want to use (2.) (See documentation above!). The Lindblad operators are
assumend to be of shape (dim, dim) where dim is the dimension of the
system.

\item[{prefactor\_function: Callable{[}{[}np.array{]}, np.array{]}}] \leavevmode
Receives the control amplitudes u (as numpy array of shape
(num\_t, num\_ctrl)) and returns prefactors as numpy array
of shape (num\_t, num\_l). The prefactors a\_k are used as weights in the
sum of the total dissipation operator.
\begin{quote}

mathcal\{G\} = sum\_k a\_k * D(L\_k)
\end{quote}

If the Lindblad operator is for example given by a complex number b\_k
times a constant (in time) matrix C\_k.
\begin{quote}

L\_k = b\_k * C\_k
\end{quote}
\begin{description}
\item[{Then the prefactor is the squared absolute value of this number:}] \leavevmode
a\_k = {\color{red}\bfseries{}|}b\_k|\textasciicircum{}2

\end{description}

Set if you want to use method (1.) or (2.). (See class documentation.)

\item[{prefactor\_derivative\_function: Callable{[}{[}np.array{]}, np.array{]}}] \leavevmode
Receives the control amplitudes u (as numpy array of shape
(num\_t, num\_ctrl)) and returns the derivatives of the
prefactors as numpy array of shape (num\_t, num\_ctrl, num\_l). The
derivatives d\_k are used as weights in the sum of the derivative of the
total dissipation operator.
\begin{quote}

d mathcal\{G\} / d u\_k = sum\_k d\_k * D(L\_k)
\end{quote}

If the Lindblad operator is for example given by a complex number b\_k
times a constant (in time) matrix C\_k. And this number depends on the
control amplitudes u\_k
\begin{quote}

L\_k = b\_k (u\_k) * C\_k
\end{quote}

Then the derivative of the prefactor is the derivative of the squared
absolute value of this number:
\begin{quote}

d\_k = d {\color{red}\bfseries{}|}b\_k|\textasciicircum{}2 / d u\_k
\end{quote}

Set if you want to use method (1.) or (2.). (See class documentation.)

\item[{super\_operator\_function: Callable{[}{[}np.array{]}, List{[}ControlMatrix{]}{]}}] \leavevmode
Receives the control amlitudes u (as numpy array of shape
(num\_t, num\_ctrl)) and returns the total dissipation
operators as list of length num\_t. Set if you want to use method (3.).
(See class documentation.)

\item[{super\_operator\_derivative\_function: Callable{[}{[}np.array{]},}] \leavevmode\begin{quote}

List{[}List{[}ControlMatrix{]}{]}{]}
\end{quote}

Receives the control amlitudes u (as numpy array of shape
(num\_t, num\_ctrl)) and returns the derivatives of the total dissipation
operators as nested list of shape {[}{[}{]} * num\_ctrl{]} * num\_t. Set if you
want to use method (3.). (See class documentation.)

\item[{is\_skew\_hermitian: bool}] \leavevmode
If True, then the total dynamics generator is assumed to be skew
hermitian.

\end{description}

\end{description}

\item[{Attributes}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{\_diss\_sup\_op: List{[}ControlMatrix{]}, len: num\_t}}] \leavevmode\begin{quote}

Total dissipaton super operator.
\end{quote}
\begin{description}
\item[{\_diss\_sup\_op\_deriv: List{[}List{[}ControlMatrix{]}{]},}] \leavevmode\begin{quote}

shape: {[}{[}{]} * num\_ctrl{]} * num\_t
\end{quote}

Derivative of the total dissipation operator with respect to the
control amplitudes.

\item[{\_initial\_diss\_super\_op: List{[}ControlMatrix{]}, len: num\_l}] \leavevmode
Initial dissipation super operator; num\_l is the number of
Lindbladians.

\item[{\_lindblad\_operatorsList{[}ControlMatrix{]}, len: num\_l}] \leavevmode
Lindblad operators; num\_l is the number of Lindbladians.

\item[{\_prefactor\_function: Callable{[}{[}np.array{]}, np.array{]}}] \leavevmode
Receives the control amplitudes u (as numpy array of shape
(num\_t, num\_ctrl)) and returns prefactors as numpy array
of shape (num\_t, num\_l). The prefactors a\_k are used as weights in the
sum of the total dissipation operator.
\begin{quote}

mathcal\{G\} = sum\_k a\_k * D(L\_k)
\end{quote}

If the Lindblad operator is for example given by a complex number b\_k
times a constant (in time) matrix C\_k.
\begin{quote}

L\_k = b\_k * C\_k
\end{quote}
\begin{description}
\item[{Then the prefactor is the squared absolute value of this number:}] \leavevmode
a\_k = {\color{red}\bfseries{}|}b\_k|\textasciicircum{}2

\end{description}

Set if you want to use method (1.) or (2.). (See class documentation.)

\item[{\_prefactor\_deriv\_function: Callable{[}{[}np.array{]}, np.array{]}}] \leavevmode
Receives the control amplitudes u (as numpy array of shape
(num\_t, num\_ctrl)) and returns the derivatives of the
prefactors as numpy array of shape (num\_t, num\_ctrl, num\_l). The
derivatives d\_k are used as weights in the sum of the derivative of the
total dissipation operator.
\begin{quote}

d mathcal\{G\} / d u\_k = sum\_k d\_k * D(L\_k)
\end{quote}

If the Lindblad operator is for example given by a complex number b\_k
times a constant (in time) matrix C\_k. And this number depends on the
control amplitudes u\_k
\begin{quote}

L\_k = b\_k (u\_k) * C\_k
\end{quote}

Then the derivative of the prefactor is the derivative of the squared
absolute value of this number:
\begin{quote}

d\_k = d {\color{red}\bfseries{}|}b\_k|\textasciicircum{}2 / d u\_k
\end{quote}

\item[{\_sup\_op\_func: Callable{[}{[}np.array{]}, List{[}ControlMatrix{]}{]}}] \leavevmode
Receives the control amlitudes u (as numpy array of shape
(num\_t, num\_ctrl)) and returns the total dissipation
operators as list of length num\_t.

\item[{\_sup\_op\_deriv\_func: Callable{[}{[}np.array{]}, List{[}List{[}ControlMatrix{]}{]}{]}}] \leavevmode
Receives the control amlitudes u (as numpy array of shape
(num\_t, num\_ctrl)) and returns the derivatives of the total dissipation
operators as nested list of shape {[}{[}{]} * num\_ctrl{]} * num\_t.

\end{description}

\end{description}

\end{description}\end{quote}
\subsubsection*{Methods}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

\sphinxstylestrong{\_parse\_dissipative\_super\_operator: None}
&
\_calc\_diss\_sup\_op: List{[}ControlMatrix{]} Calculates the total dissipation super operator.  \_calc\_diss\_sup\_op\_deriv: Optional{[}List{[}List{[}ControlMatrix{]}{]}{]} Calculates the derivatives of the total dissipation super operators with respect to the control amplitudes.  Todo: * Write parser
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\index{set\_optimization\_parameters() (LindbladSolver method)@\spxentry{set\_optimization\_parameters()}\spxextra{LindbladSolver method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:qsim.solver_algorithms.LindbladSolver.set_optimization_parameters}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{set\_optimization\_parameters}}}{\emph{self}, \emph{y: \textless{}built\sphinxhyphen{}in function array\textgreater{}}}{{ $\rightarrow$ None}}
See base class.

\end{fulllineitems}


\end{fulllineitems}

\index{SchroedingerSMCControlNoise (class in qsim.solver\_algorithms)@\spxentry{SchroedingerSMCControlNoise}\spxextra{class in qsim.solver\_algorithms}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:qsim.solver_algorithms.SchroedingerSMCControlNoise}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxbfcode{\sphinxupquote{SchroedingerSMCControlNoise}}}{\emph{\DUrole{n}{h\_drift}\DUrole{p}{:} \DUrole{n}{List\DUrole{p}{{[}}{\hyperref[\detokenize{qsim:qsim.matrix.OperatorMatrix}]{\sphinxcrossref{qsim.matrix.OperatorMatrix}}}\DUrole{p}{{]}}}}, \emph{\DUrole{n}{h\_ctrl}\DUrole{p}{:} \DUrole{n}{List\DUrole{p}{{[}}{\hyperref[\detokenize{qsim:qsim.matrix.OperatorMatrix}]{\sphinxcrossref{qsim.matrix.OperatorMatrix}}}\DUrole{p}{{]}}}}, \emph{\DUrole{n}{initial\_state}\DUrole{p}{:} \DUrole{n}{{\hyperref[\detokenize{qsim:qsim.matrix.OperatorMatrix}]{\sphinxcrossref{qsim.matrix.OperatorMatrix}}}}}, \emph{\DUrole{n}{tau}\DUrole{p}{:} \DUrole{n}{List\DUrole{p}{{[}}float\DUrole{p}{{]}}}}, \emph{\DUrole{n}{noise\_trace\_generator}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}{\hyperref[\detokenize{qsim:qsim.noise.NoiseTraceGenerator}]{\sphinxcrossref{qsim.noise.NoiseTraceGenerator}}}\DUrole{p}{{]}}}}, \emph{\DUrole{n}{ctrl\_amps}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}numpy.array\DUrole{p}{{]}}} \DUrole{o}{=} \DUrole{default_value}{None}}, \emph{\DUrole{n}{calculate\_propagator\_derivatives}\DUrole{p}{:} \DUrole{n}{bool} \DUrole{o}{=} \DUrole{default_value}{False}}, \emph{\DUrole{n}{filter\_function\_h\_n}\DUrole{p}{:} \DUrole{n}{Union{[}List{[}List{]}, numpy.array, None{]}} \DUrole{o}{=} \DUrole{default_value}{None}}, \emph{\DUrole{n}{filter\_function\_basis}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}filter\_functions.basis.Basis\DUrole{p}{{]}}} \DUrole{o}{=} \DUrole{default_value}{None}}, \emph{\DUrole{n}{exponential\_method}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}str\DUrole{p}{{]}}} \DUrole{o}{=} \DUrole{default_value}{None}}, \emph{\DUrole{n}{frechet\_deriv\_approx\_method}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}str\DUrole{p}{{]}}} \DUrole{o}{=} \DUrole{default_value}{None}}, \emph{\DUrole{n}{is\_skew\_hermitian}\DUrole{p}{:} \DUrole{n}{bool} \DUrole{o}{=} \DUrole{default_value}{True}}, \emph{\DUrole{n}{transfer\_function}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}{\hyperref[\detokenize{qsim:qsim.transfer_function.TransferFunction}]{\sphinxcrossref{qsim.transfer\_function.TransferFunction}}}\DUrole{p}{{]}}} \DUrole{o}{=} \DUrole{default_value}{None}}, \emph{\DUrole{n}{amplitude\_function}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}{\hyperref[\detokenize{qsim:qsim.amplitude_functions.AmplitudeFunction}]{\sphinxcrossref{qsim.amplitude\_functions.AmplitudeFunction}}}\DUrole{p}{{]}}} \DUrole{o}{=} \DUrole{default_value}{None}}}{}
Bases: {\hyperref[\detokenize{qsim:qsim.solver_algorithms.SchroedingerSMonteCarlo}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{qsim.solver\_algorithms.SchroedingerSMonteCarlo}}}}}

Convenience class like \sphinxtitleref{SchroedingerSMonteCarlo} but with noise on the
optimization parameters.

This time slot computer solves the Schroedinger equation explicitly for
concrete control noise realizations. This time slot computer assumes,
that the noise is sampled on the time scale of the already transferred
optimization parameters. The control Hamiltionians are also used as noise
Hamiltionians and the noise amplitude function adds the noise samples to
the unperturbed transferred optimization parameters and applies the
amplitude function of the control amplitudes.

\end{fulllineitems}

\index{SchroedingerSMonteCarlo (class in qsim.solver\_algorithms)@\spxentry{SchroedingerSMonteCarlo}\spxextra{class in qsim.solver\_algorithms}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:qsim.solver_algorithms.SchroedingerSMonteCarlo}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxbfcode{\sphinxupquote{SchroedingerSMonteCarlo}}}{\emph{\DUrole{n}{h\_drift}\DUrole{p}{:} \DUrole{n}{List\DUrole{p}{{[}}{\hyperref[\detokenize{qsim:qsim.matrix.OperatorMatrix}]{\sphinxcrossref{qsim.matrix.OperatorMatrix}}}\DUrole{p}{{]}}}}, \emph{\DUrole{n}{h\_ctrl}\DUrole{p}{:} \DUrole{n}{List\DUrole{p}{{[}}{\hyperref[\detokenize{qsim:qsim.matrix.OperatorMatrix}]{\sphinxcrossref{qsim.matrix.OperatorMatrix}}}\DUrole{p}{{]}}}}, \emph{\DUrole{n}{initial\_state}\DUrole{p}{:} \DUrole{n}{{\hyperref[\detokenize{qsim:qsim.matrix.OperatorMatrix}]{\sphinxcrossref{qsim.matrix.OperatorMatrix}}}}}, \emph{\DUrole{n}{tau}\DUrole{p}{:} \DUrole{n}{List\DUrole{p}{{[}}float\DUrole{p}{{]}}}}, \emph{\DUrole{n}{h\_noise}\DUrole{p}{:} \DUrole{n}{List\DUrole{p}{{[}}{\hyperref[\detokenize{qsim:qsim.matrix.OperatorMatrix}]{\sphinxcrossref{qsim.matrix.OperatorMatrix}}}\DUrole{p}{{]}}}}, \emph{\DUrole{n}{noise\_trace\_generator}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}{\hyperref[\detokenize{qsim:qsim.noise.NoiseTraceGenerator}]{\sphinxcrossref{qsim.noise.NoiseTraceGenerator}}}\DUrole{p}{{]}}}}, \emph{\DUrole{n}{ctrl\_amps}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}numpy.array\DUrole{p}{{]}}} \DUrole{o}{=} \DUrole{default_value}{None}}, \emph{\DUrole{n}{calculate\_propagator\_derivatives}\DUrole{p}{:} \DUrole{n}{bool} \DUrole{o}{=} \DUrole{default_value}{False}}, \emph{\DUrole{n}{filter\_function\_h\_n}\DUrole{p}{:} \DUrole{n}{Union{[}List{[}List{]}, numpy.array, None{]}} \DUrole{o}{=} \DUrole{default_value}{None}}, \emph{\DUrole{n}{filter\_function\_basis}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}filter\_functions.basis.Basis\DUrole{p}{{]}}} \DUrole{o}{=} \DUrole{default_value}{None}}, \emph{\DUrole{n}{exponential\_method}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}str\DUrole{p}{{]}}} \DUrole{o}{=} \DUrole{default_value}{None}}, \emph{\DUrole{n}{frechet\_deriv\_approx\_method}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}str\DUrole{p}{{]}}} \DUrole{o}{=} \DUrole{default_value}{None}}, \emph{\DUrole{n}{is\_skew\_hermitian}\DUrole{p}{:} \DUrole{n}{bool} \DUrole{o}{=} \DUrole{default_value}{True}}, \emph{\DUrole{n}{transfer\_function}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}{\hyperref[\detokenize{qsim:qsim.transfer_function.TransferFunction}]{\sphinxcrossref{qsim.transfer\_function.TransferFunction}}}\DUrole{p}{{]}}} \DUrole{o}{=} \DUrole{default_value}{None}}, \emph{\DUrole{n}{amplitude\_function}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}{\hyperref[\detokenize{qsim:qsim.amplitude_functions.AmplitudeFunction}]{\sphinxcrossref{qsim.amplitude\_functions.AmplitudeFunction}}}\DUrole{p}{{]}}} \DUrole{o}{=} \DUrole{default_value}{None}}, \emph{\DUrole{n}{noise\_amplitude\_function}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}Callable\DUrole{p}{{[}}\DUrole{p}{{[}}numpy.array\DUrole{p}{, }numpy.array\DUrole{p}{, }numpy.array\DUrole{p}{, }numpy.array\DUrole{p}{{]}}\DUrole{p}{, }numpy.array\DUrole{p}{{]}}\DUrole{p}{{]}}} \DUrole{o}{=} \DUrole{default_value}{None}}}{}
Bases: {\hyperref[\detokenize{qsim:qsim.solver_algorithms.SchroedingerSolver}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{qsim.solver\_algorithms.SchroedingerSolver}}}}}

Solves Schroedinger’s equation for explicit noise realisations as Monte
Carlo experiment.

This time slot computer solves the Schroedinger equation explicitly for
concrete noise realizations. The noise traces are generated by an instance
of the Noise Trace Generator Class. Then they can be processed by the
noise amplitude function, before they are multiplied by the noise
hamiltionians.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{h\_noise}} (\sphinxstyleliteralemphasis{\sphinxupquote{List}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{ControlMatrix}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{len: num\_noise\_operators}}) \textendash{} List of noise operators occurring in the Hamiltonian.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{noise\_trace\_generator}} ({\hyperref[\detokenize{qsim:qsim.noise.NoiseTraceGenerator}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{noise.NoiseTraceGenerator}}}}}) \textendash{} Noise trace generator object.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{noise\_amplitude\_function}} (\sphinxstyleliteralemphasis{\sphinxupquote{Callable}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{noise\_samples: np.array}}\sphinxstyleliteralemphasis{\sphinxupquote{,}}) \textendash{} optimization\_parameters: np.array,
transferred\_parameters: np.array,
control\_amplitudes: np.array{]}, np.array{]}
The noise amplitude function calculated the noisy control amplitudes
corresponding to the noise samples. They recieve 4 keyword arguments
being the noise samples, the optimization parameters, the transferred
optimization parameters and the control amplitudes in this order.
The noise samples are given with the shape (n\_samples\_per\_trace,
n\_traces, n\_noise\_operators), the optimization parameters
(num\_x, num\_ctrl), the transferred parameters (num\_t, num\_ctrl) and
the control amplitudes (num\_t, num\_ctrl). The returned noise amplitudes
should be of the shape (num\_t, n\_traces, n\_noise\_operators).

\end{itemize}

\end{description}\end{quote}
\index{h\_noise (SchroedingerSMonteCarlo attribute)@\spxentry{h\_noise}\spxextra{SchroedingerSMonteCarlo attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:qsim.solver_algorithms.SchroedingerSMonteCarlo.h_noise}}\pysigline{\sphinxbfcode{\sphinxupquote{h\_noise}}}
List of noise operators occurring in the Hamiltonian.
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
List{[}ControlMatrix{]}, len: num\_noise\_operators

\end{description}\end{quote}

\end{fulllineitems}

\index{noise\_trace\_generator (SchroedingerSMonteCarlo attribute)@\spxentry{noise\_trace\_generator}\spxextra{SchroedingerSMonteCarlo attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:qsim.solver_algorithms.SchroedingerSMonteCarlo.noise_trace_generator}}\pysigline{\sphinxbfcode{\sphinxupquote{noise\_trace\_generator}}}
Noise trace generator object.
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
{\hyperref[\detokenize{qsim:qsim.noise.NoiseTraceGenerator}]{\sphinxcrossref{noise.NoiseTraceGenerator}}}

\end{description}\end{quote}

\end{fulllineitems}

\index{\_dyn\_gen\_noise (SchroedingerSMonteCarlo attribute)@\spxentry{\_dyn\_gen\_noise}\spxextra{SchroedingerSMonteCarlo attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:qsim.solver_algorithms.SchroedingerSMonteCarlo._dyn_gen_noise}}\pysigline{\sphinxbfcode{\sphinxupquote{\_dyn\_gen\_noise}}}~\begin{quote}

shape: {[}{[}{]} * num\_t{]} * num\_noise\_traces
\end{quote}

Dynamics generators for the individual noise traces.
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
List{[}List{[}ControlMatrix{]}{]},

\end{description}\end{quote}

\end{fulllineitems}

\index{\_prop\_noise (SchroedingerSMonteCarlo attribute)@\spxentry{\_prop\_noise}\spxextra{SchroedingerSMonteCarlo attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:qsim.solver_algorithms.SchroedingerSMonteCarlo._prop_noise}}\pysigline{\sphinxbfcode{\sphinxupquote{\_prop\_noise}}}~\begin{quote}

shape: {[}{[}{]} * num\_t{]} * num\_noise\_traces
\end{quote}

Propagators for the individual noise traces.
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
List{[}List{[}ControlMatrix{]}{]},

\end{description}\end{quote}

\end{fulllineitems}

\index{\_fwd\_prop\_noise (SchroedingerSMonteCarlo attribute)@\spxentry{\_fwd\_prop\_noise}\spxextra{SchroedingerSMonteCarlo attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:qsim.solver_algorithms.SchroedingerSMonteCarlo._fwd_prop_noise}}\pysigline{\sphinxbfcode{\sphinxupquote{\_fwd\_prop\_noise}}}~\begin{quote}

shape: {[}{[}{]} * (num\_t + 1){]} * num\_noise\_traces
\end{quote}

Cumulation of the propagators for the individual noise traces. They
describe the forward propagation of the systems state.
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
List{[}List{[}ControlMatrix{]}{]},

\end{description}\end{quote}

\end{fulllineitems}

\index{\_reversed\_prop\_noise (SchroedingerSMonteCarlo attribute)@\spxentry{\_reversed\_prop\_noise}\spxextra{SchroedingerSMonteCarlo attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:qsim.solver_algorithms.SchroedingerSMonteCarlo._reversed_prop_noise}}\pysigline{\sphinxbfcode{\sphinxupquote{\_reversed\_prop\_noise}}}~\begin{quote}

shape: {[}{[}{]} * (num\_t + 1){]} * num\_noise\_traces
\end{quote}

Cumulation of propagators in reversed order for the individual noise
traces.
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
List{[}List{[}ControlMatrix{]}{]},

\end{description}\end{quote}

\end{fulllineitems}

\index{\_derivative\_prop\_noise (SchroedingerSMonteCarlo attribute)@\spxentry{\_derivative\_prop\_noise}\spxextra{SchroedingerSMonteCarlo attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:qsim.solver_algorithms.SchroedingerSMonteCarlo._derivative_prop_noise}}\pysigline{\sphinxbfcode{\sphinxupquote{\_derivative\_prop\_noise}}}~\begin{quote}

shape: {[}{[}{[}{]} * num\_t{]} * num\_ctrl{]} * num\_noise\_traces
\end{quote}

Frechet derivatives of the propagators by the control amplitudes for
the individual noise traces.
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
List{[}List{[}List{[}ControlMatrix{]}{]}{]},

\end{description}\end{quote}

\end{fulllineitems}



\begin{fulllineitems}
\pysigline{\sphinxbfcode{\sphinxupquote{propagators\_noise:~List{[}List{[}ControlMatrix{]}{]},}}}~\begin{quote}

shape: {[}{[}{]} * num\_t{]} * num\_noise\_traces
\end{quote}

Propagators for the individual noise traces.

\end{fulllineitems}



\begin{fulllineitems}
\pysigline{\sphinxbfcode{\sphinxupquote{forward\_propagators\_noise:~List{[}List{[}ControlMatrix{]}{]},}}}~\begin{quote}

shape: {[}{[}{]} * (num\_t + 1){]} * num\_noise\_traces
\end{quote}

Cumulation of the propagators for the individual noise traces. They
describe the forward propagation of the systems state.

\end{fulllineitems}



\begin{fulllineitems}
\pysigline{\sphinxbfcode{\sphinxupquote{reversed\_propagators\_noise:~List{[}List{[}ControlMatrix{]}{]},}}}~\begin{quote}

shape: {[}{[}{]} * (num\_t + 1){]} * num\_noise\_traces
\end{quote}

Cumulation of propagators in reversed order for the individual noise
traces.

\end{fulllineitems}



\begin{fulllineitems}
\pysigline{\sphinxbfcode{\sphinxupquote{frechet\_deriv\_propagators\_noise:~List{[}List{[}List{[}ControlMatrix{]}{]}{]},}}}~\begin{quote}

shape: {[}{[}{[}{]} * num\_t{]} * num\_ctrl{]} * num\_noise\_traces
\end{quote}

Frechet derivatives of the propagators by the control amplitudes for
the individual noise traces.

\end{fulllineitems}

\index{forward\_propagators\_noise() (SchroedingerSMonteCarlo property)@\spxentry{forward\_propagators\_noise()}\spxextra{SchroedingerSMonteCarlo property}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:qsim.solver_algorithms.SchroedingerSMonteCarlo.forward_propagators_noise}}\pysigline{\sphinxbfcode{\sphinxupquote{property }}\sphinxbfcode{\sphinxupquote{forward\_propagators\_noise}}}
Returns the forward propagation of the initial state for every time
slice and every noise trace and calculate it if necessary. If the
initial state is the identity matrix, then the cumulative propagators
are given. The element forward\_propagators{[}k{]}{[}i{]} propagates a state by
the first i time steps under the kth noise trace, if the initial state
is the identity matrix.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxstylestrong{forward\_propagation} \textendash{}          shape: {[}{[}{]} * (num\_t + 1){]} * num\_noise\_traces
Propagation of the initial state of the system. fwd{[}0{]} gives the
initial state itself.

\item[{Return type}] \leavevmode
List{[}List{[}ControlMatrix{]}{]},

\end{description}\end{quote}

\end{fulllineitems}

\index{frechet\_deriv\_propagators\_noise() (SchroedingerSMonteCarlo property)@\spxentry{frechet\_deriv\_propagators\_noise()}\spxextra{SchroedingerSMonteCarlo property}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:qsim.solver_algorithms.SchroedingerSMonteCarlo.frechet_deriv_propagators_noise}}\pysigline{\sphinxbfcode{\sphinxupquote{property }}\sphinxbfcode{\sphinxupquote{frechet\_deriv\_propagators\_noise}}}
Returns the frechet derivatives of the propagators with respect to the
control amplitudes for each noise trace.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxstylestrong{derivative\_prop\_noise} \textendash{}                 shape: {[}{[}{[}{]} * num\_t{]} * num\_ctrl{]} * num\_noise\_traces
Frechet derivatives of the propagators by the control amplitudes.

\item[{Return type}] \leavevmode
List{[}List{[}List{[}ControlMatrix{]}{]}{]},

\end{description}\end{quote}

\end{fulllineitems}

\index{propagators\_noise() (SchroedingerSMonteCarlo property)@\spxentry{propagators\_noise()}\spxextra{SchroedingerSMonteCarlo property}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:qsim.solver_algorithms.SchroedingerSMonteCarlo.propagators_noise}}\pysigline{\sphinxbfcode{\sphinxupquote{property }}\sphinxbfcode{\sphinxupquote{propagators\_noise}}}
Returns the propagators of the system for each noise trace and
calculates them if necessary.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxstylestrong{propagators\_noise} \textendash{}                shape: {[}{[}{]} * num\_t{]} * num\_noise\_traces
Propagators of the system for each noise trace.

\item[{Return type}] \leavevmode
List{[}List{[}ControlMatrix{]}{]},

\end{description}\end{quote}

\end{fulllineitems}

\index{reversed\_propagators\_noise() (SchroedingerSMonteCarlo property)@\spxentry{reversed\_propagators\_noise()}\spxextra{SchroedingerSMonteCarlo property}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:qsim.solver_algorithms.SchroedingerSMonteCarlo.reversed_propagators_noise}}\pysigline{\sphinxbfcode{\sphinxupquote{property }}\sphinxbfcode{\sphinxupquote{reversed\_propagators\_noise}}}
Returns the reversed propagation of the initial state for every noise
trace and calculate it if necessary. If the initial state is the
identity matrix, then the reversed cumulative propagators are given.
The element forward\_propagators{[}k{]}{[}i{]} propagates a state by the first i
time steps under the kth noise trace, if the initial state is the
identity matrix.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxstylestrong{reversed\_propagation\_noise} \textendash{}     shape: {[}{[}{]} * (num\_t + 1){]} * num\_noise\_traces
Propagation of the initial state of the system. reversed{[}k{]}{[}0{]}
gives the initial state itself.

\item[{Return type}] \leavevmode
List{[}List{[}ControlMatrix{]}{]},

\end{description}\end{quote}

\end{fulllineitems}

\index{set\_optimization\_parameters() (SchroedingerSMonteCarlo method)@\spxentry{set\_optimization\_parameters()}\spxextra{SchroedingerSMonteCarlo method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:qsim.solver_algorithms.SchroedingerSMonteCarlo.set_optimization_parameters}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{set\_optimization\_parameters}}}{\emph{self}, \emph{y: \textless{}built\sphinxhyphen{}in function array\textgreater{}}}{{ $\rightarrow$ None}}
See base class.

\end{fulllineitems}


\end{fulllineitems}

\index{SchroedingerSolver (class in qsim.solver\_algorithms)@\spxentry{SchroedingerSolver}\spxextra{class in qsim.solver\_algorithms}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:qsim.solver_algorithms.SchroedingerSolver}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxbfcode{\sphinxupquote{SchroedingerSolver}}}{\emph{\DUrole{n}{h\_drift}\DUrole{p}{:} \DUrole{n}{List\DUrole{p}{{[}}{\hyperref[\detokenize{qsim:qsim.matrix.OperatorMatrix}]{\sphinxcrossref{qsim.matrix.OperatorMatrix}}}\DUrole{p}{{]}}}}, \emph{\DUrole{n}{h\_ctrl}\DUrole{p}{:} \DUrole{n}{List\DUrole{p}{{[}}{\hyperref[\detokenize{qsim:qsim.matrix.OperatorMatrix}]{\sphinxcrossref{qsim.matrix.OperatorMatrix}}}\DUrole{p}{{]}}}}, \emph{\DUrole{n}{tau}\DUrole{p}{:} \DUrole{n}{numpy.array}}, \emph{\DUrole{n}{initial\_state}\DUrole{p}{:} \DUrole{n}{{\hyperref[\detokenize{qsim:qsim.matrix.OperatorMatrix}]{\sphinxcrossref{qsim.matrix.OperatorMatrix}}}} \DUrole{o}{=} \DUrole{default_value}{None}}, \emph{\DUrole{n}{ctrl\_amps}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}numpy.array\DUrole{p}{{]}}} \DUrole{o}{=} \DUrole{default_value}{None}}, \emph{\DUrole{n}{calculate\_propagator\_derivatives}\DUrole{p}{:} \DUrole{n}{bool} \DUrole{o}{=} \DUrole{default_value}{True}}, \emph{\DUrole{n}{filter\_function\_h\_n}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}List\DUrole{p}{{]}}} \DUrole{o}{=} \DUrole{default_value}{None}}, \emph{\DUrole{n}{filter\_function\_basis}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}filter\_functions.basis.Basis\DUrole{p}{{]}}} \DUrole{o}{=} \DUrole{default_value}{None}}, \emph{\DUrole{n}{exponential\_method}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}str\DUrole{p}{{]}}} \DUrole{o}{=} \DUrole{default_value}{None}}, \emph{\DUrole{n}{frechet\_deriv\_approx\_method}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}str\DUrole{p}{{]}}} \DUrole{o}{=} \DUrole{default_value}{None}}, \emph{\DUrole{n}{is\_skew\_hermitian}\DUrole{p}{:} \DUrole{n}{bool} \DUrole{o}{=} \DUrole{default_value}{True}}, \emph{\DUrole{n}{transfer\_function}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}{\hyperref[\detokenize{qsim:qsim.transfer_function.TransferFunction}]{\sphinxcrossref{qsim.transfer\_function.TransferFunction}}}\DUrole{p}{{]}}} \DUrole{o}{=} \DUrole{default_value}{None}}, \emph{\DUrole{n}{amplitude\_function}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}{\hyperref[\detokenize{qsim:qsim.amplitude_functions.AmplitudeFunction}]{\sphinxcrossref{qsim.amplitude\_functions.AmplitudeFunction}}}\DUrole{p}{{]}}} \DUrole{o}{=} \DUrole{default_value}{None}}}{}
Bases: {\hyperref[\detokenize{qsim:qsim.solver_algorithms.Solver}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{qsim.solver\_algorithms.Solver}}}}}

This time slot computer solves the unperturbed Schroedinger equation.

All intermediary propagators are calculated and cached. Takes also input
parameters of the base class.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{calculate\_propagator\_derivatives}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}) \textendash{} If true, the derivatives of the propagators by the control amplitudes
are always calculated. Otherwise only on demand.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{frechet\_deriv\_approx\_method}} (\sphinxstyleliteralemphasis{\sphinxupquote{Optional}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} Method for the approximation of the derivatives of the propagators, if
they are not calculated analytically. Note that this method is never
used if calculate\_propagator\_derivatives is set to True!
Methods:
None: The derivatives are not approximated by calculated by the control
matrix class.
‘grape’: use the approximation given in the original grape paper.

\end{itemize}

\end{description}\end{quote}
\index{\_dyn\_gen (SchroedingerSolver attribute)@\spxentry{\_dyn\_gen}\spxextra{SchroedingerSolver attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:qsim.solver_algorithms.SchroedingerSolver._dyn_gen}}\pysigline{\sphinxbfcode{\sphinxupquote{\_dyn\_gen}}}
The generators of the systems dynamics
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
List{[}ControlMatrix{]}, len: num\_t

\end{description}\end{quote}

\end{fulllineitems}

\index{calculate\_propagator\_derivatives (SchroedingerSolver attribute)@\spxentry{calculate\_propagator\_derivatives}\spxextra{SchroedingerSolver attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:qsim.solver_algorithms.SchroedingerSolver.calculate_propagator_derivatives}}\pysigline{\sphinxbfcode{\sphinxupquote{calculate\_propagator\_derivatives}}}
If true, the derivatives of the propagators by the control amplitudes
are always calculated. Otherwise only on demand.
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
bool

\end{description}\end{quote}

\end{fulllineitems}

\index{frechet\_deriv\_approx\_method (SchroedingerSolver attribute)@\spxentry{frechet\_deriv\_approx\_method}\spxextra{SchroedingerSolver attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:qsim.solver_algorithms.SchroedingerSolver.frechet_deriv_approx_method}}\pysigline{\sphinxbfcode{\sphinxupquote{frechet\_deriv\_approx\_method}}}
Method for the approximation of the derivatives of the propagators, if
they are not calculated analytically. Note that this method is never
used if calculate\_propagator\_derivatives is set to True!
Methods:
‘grape’: use the approximation given in the original grape paper.
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
Optional{[}str{]}

\end{description}\end{quote}

\end{fulllineitems}



\begin{fulllineitems}
\pysigline{\sphinxbfcode{\sphinxupquote{\_compute\_derivative\_directions:~List{[}List{[}q\_mat.ControlMatrix{]}{]},}}}~\begin{quote}

shape: {[}{[}{]} * num\_ctrl{]} * num\_t
\end{quote}

Computes the directions of change with respect to the control
parameters.

\end{fulllineitems}



\begin{fulllineitems}
\pysigline{\sphinxbfcode{\sphinxupquote{\_compute\_dyn\_gen:~List{[}ControlMatrix{]},~len:~num\_t}}}
Computes the dynamics generators.

\end{fulllineitems}



\begin{fulllineitems}
\pysigline{\sphinxbfcode{\sphinxupquote{Todo:}}}~\begin{itemize}
\item {} 
raise a warning if the approximation method although the gradient

\end{itemize}

is always calculated.
* raise a warning if the grape approximation is chosen but its
requirement of small time steps is not met.

\end{fulllineitems}

\index{set\_optimization\_parameters() (SchroedingerSolver method)@\spxentry{set\_optimization\_parameters()}\spxextra{SchroedingerSolver method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:qsim.solver_algorithms.SchroedingerSolver.set_optimization_parameters}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{set\_optimization\_parameters}}}{\emph{self}, \emph{y: \textless{}built\sphinxhyphen{}in function array\textgreater{}}}{{ $\rightarrow$ None}}
See base class.

\end{fulllineitems}


\end{fulllineitems}

\index{Solver (class in qsim.solver\_algorithms)@\spxentry{Solver}\spxextra{class in qsim.solver\_algorithms}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:qsim.solver_algorithms.Solver}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxbfcode{\sphinxupquote{Solver}}}{\emph{\DUrole{n}{h\_ctrl}\DUrole{p}{:} \DUrole{n}{List\DUrole{p}{{[}}{\hyperref[\detokenize{qsim:qsim.matrix.OperatorMatrix}]{\sphinxcrossref{qsim.matrix.OperatorMatrix}}}\DUrole{p}{{]}}}}, \emph{\DUrole{n}{h\_drift}\DUrole{p}{:} \DUrole{n}{List\DUrole{p}{{[}}{\hyperref[\detokenize{qsim:qsim.matrix.OperatorMatrix}]{\sphinxcrossref{qsim.matrix.OperatorMatrix}}}\DUrole{p}{{]}}}}, \emph{\DUrole{n}{tau}\DUrole{p}{:} \DUrole{n}{numpy.array}}, \emph{\DUrole{n}{initial\_state}\DUrole{p}{:} \DUrole{n}{{\hyperref[\detokenize{qsim:qsim.matrix.OperatorMatrix}]{\sphinxcrossref{qsim.matrix.OperatorMatrix}}}} \DUrole{o}{=} \DUrole{default_value}{None}}, \emph{\DUrole{n}{opt\_pars}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}numpy.array\DUrole{p}{{]}}} \DUrole{o}{=} \DUrole{default_value}{None}}, \emph{\DUrole{n}{ctrl\_amps}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}numpy.array\DUrole{p}{{]}}} \DUrole{o}{=} \DUrole{default_value}{None}}, \emph{\DUrole{n}{filter\_function\_h\_n}\DUrole{p}{:} \DUrole{n}{Union{[}List{[}List{]}, numpy.array, None{]}} \DUrole{o}{=} \DUrole{default_value}{None}}, \emph{\DUrole{n}{filter\_function\_basis}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}filter\_functions.basis.Basis\DUrole{p}{{]}}} \DUrole{o}{=} \DUrole{default_value}{None}}, \emph{\DUrole{n}{exponential\_method}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}str\DUrole{p}{{]}}} \DUrole{o}{=} \DUrole{default_value}{None}}, \emph{\DUrole{n}{is\_skew\_hermitian}\DUrole{p}{:} \DUrole{n}{bool} \DUrole{o}{=} \DUrole{default_value}{True}}, \emph{\DUrole{n}{transfer\_function}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}{\hyperref[\detokenize{qsim:qsim.transfer_function.TransferFunction}]{\sphinxcrossref{qsim.transfer\_function.TransferFunction}}}\DUrole{p}{{]}}} \DUrole{o}{=} \DUrole{default_value}{None}}, \emph{\DUrole{n}{amplitude\_function}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}{\hyperref[\detokenize{qsim:qsim.amplitude_functions.AmplitudeFunction}]{\sphinxcrossref{qsim.amplitude\_functions.AmplitudeFunction}}}\DUrole{p}{{]}}} \DUrole{o}{=} \DUrole{default_value}{None}}, \emph{\DUrole{n}{paranoia\_level}\DUrole{p}{:} \DUrole{n}{int} \DUrole{o}{=} \DUrole{default_value}{2}}}{}
Bases: \sphinxcode{\sphinxupquote{abc.ABC}}

Abstract base class for Solvers.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{h\_ctrl}} (\sphinxstyleliteralemphasis{\sphinxupquote{List}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{ControlMatrix}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{len:  num\_ctrl}}) \textendash{} Control operators in the Hamiltonian as nested list of
shape n\_t, num\_ctrl.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{h\_drift}} (\sphinxstyleliteralemphasis{\sphinxupquote{List}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{ControlMatrix}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{len: num\_t}}) \textendash{} Drift operators in the Hamiltonian.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{initial\_state}} (\sphinxstyleliteralemphasis{\sphinxupquote{ControlMatrix}}) \textendash{} Initial state of the system as state vector. Can also be set to the
identity matrix. Then the forward propagation gives the total
propagator of the system.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{tau}} (\sphinxstyleliteralemphasis{\sphinxupquote{array of float}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{shape:}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{num\_t}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} Durations of the time slices.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{opt\_pars}} (\sphinxstyleliteralemphasis{\sphinxupquote{np.array}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{shape:}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{num\_y}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{num\_par}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} Raw optimization parameters.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ctrl\_amps}} (\sphinxstyleliteralemphasis{\sphinxupquote{np.array}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{shape:}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{num\_t}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{num\_ctrl}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} The initial control amplitudes.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{filter\_function\_h\_n}} (\sphinxstyleliteralemphasis{\sphinxupquote{List}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{List}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{np.array}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}\sphinxstyleliteralemphasis{\sphinxupquote{{]} or }}\sphinxstyleliteralemphasis{\sphinxupquote{List}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{List}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{Qobj}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} 
Nested list of noise Operators. Used in the filter function
formalism. filter\_function\_h\_n should look something like this:
\begin{quote}
\begin{description}
\item[{H = {[}{[}n\_oper1, n\_coeff1, n\_oper\_identifier1{]},}] \leavevmode
{[}n\_oper2, n\_coeff2, n\_oper\_identifier2{]}, …{]}

\end{description}
\end{quote}

The operators may be given either as NumPy arrays or QuTiP Qobjs
and each coefficient array should have the same number of elements
as \sphinxstyleemphasis{dt}, and should be given in units of \(\hbar\). If not every
sublist (read: operator) was given a identifier, they are automatically
filled up with ‘A\_i’ where i is the position of the operator.


\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{filter\_function\_basis}} (\sphinxstyleliteralemphasis{\sphinxupquote{Basis}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{shape}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{d**2}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{d}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{d}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} The operator basis in which to calculate. If a Generalized Gell\sphinxhyphen{}Mann
basis (see \sphinxcode{\sphinxupquote{ggm()}}) is chosen, some calculations will
be faster for large dimensions due to a simpler basis expansion.
However, when extending the pulse sequence to larger qubit registers,
cached filter functions cannot be retained since the GGM basis does not
factor into tensor products. In this case a Pauli basis is preferable.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{exponential\_method}} (\sphinxstyleliteralemphasis{\sphinxupquote{string}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} Method used by the ControlMatrix class for the calculation of the
matrix exponential. The default is ‘Frechet’. See also the Docstring of
the file ‘control\_2.matrix’.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{is\_skew\_hermitian}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}) \textendash{} Only important for the exponential\_method ‘spectral’. If set to true,
the dynamical generator is assumed to be skew hermitian during the
spectral decomposition.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{transfer\_function}} ({\hyperref[\detokenize{qsim:qsim.transfer_function.TransferFunction}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{TransferFunction}}}}}) \textendash{} The transfer function for reshaping the optimization parameters.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{amplitude\_function}} ({\hyperref[\detokenize{qsim:qsim.amplitude_functions.AmplitudeFunction}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{AmplitudeFunction}}}}}) \textendash{} The amplitude function connecting the transferred optimization
parameters to the control amplitudes.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{paranoia\_level}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} The paranoia\_level determines how many checks are conducted.
0: No tests
1: Some tests
2: Exhaustive tests, dimension checks

\end{itemize}

\end{description}\end{quote}
\index{h\_ctrl (Solver attribute)@\spxentry{h\_ctrl}\spxextra{Solver attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:qsim.solver_algorithms.Solver.h_ctrl}}\pysigline{\sphinxbfcode{\sphinxupquote{h\_ctrl}}}
Control operators in the Hamiltonian as list of length num\_ctrl.
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
List{[}ControlMatrix{]}, len: num\_ctrl

\end{description}\end{quote}

\end{fulllineitems}

\index{h\_drift (Solver attribute)@\spxentry{h\_drift}\spxextra{Solver attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:qsim.solver_algorithms.Solver.h_drift}}\pysigline{\sphinxbfcode{\sphinxupquote{h\_drift}}}
Drift operators in the Hamiltonian.
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
List{[}ControlMatrix{]}, len: num\_t

\end{description}\end{quote}

\end{fulllineitems}

\index{initial\_state (Solver attribute)@\spxentry{initial\_state}\spxextra{Solver attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:qsim.solver_algorithms.Solver.initial_state}}\pysigline{\sphinxbfcode{\sphinxupquote{initial\_state}}}
Initial state of the system as state vector. Can also be set to the
identity matrix. Then the forward propagation gives the total
propagator of the system.
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
ControlMatrix

\end{description}\end{quote}

\end{fulllineitems}

\index{tau (Solver attribute)@\spxentry{tau}\spxextra{Solver attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:qsim.solver_algorithms.Solver.tau}}\pysigline{\sphinxbfcode{\sphinxupquote{tau}}}
Durations of the time slices.
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
List{[}float{]}

\end{description}\end{quote}

\end{fulllineitems}

\index{filter\_function\_h\_n (Solver attribute)@\spxentry{filter\_function\_h\_n}\spxextra{Solver attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:qsim.solver_algorithms.Solver.filter_function_h_n}}\pysigline{\sphinxbfcode{\sphinxupquote{filter\_function\_h\_n}}}
Nested list of noise Operators. Used in the filter function
formalism.
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
List{[}List{[}np.array{]}{]} or List{[}List{[}Qobj{]}{]}

\end{description}\end{quote}

\end{fulllineitems}

\index{filter\_function\_basis (Solver attribute)@\spxentry{filter\_function\_basis}\spxextra{Solver attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:qsim.solver_algorithms.Solver.filter_function_basis}}\pysigline{\sphinxbfcode{\sphinxupquote{filter\_function\_basis}}}
The filter function pulse sequence will be expressed in this basis.
See documentation of the filter function package.
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
Basis

\end{description}\end{quote}

\end{fulllineitems}

\index{exponential\_method (Solver attribute)@\spxentry{exponential\_method}\spxextra{Solver attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:qsim.solver_algorithms.Solver.exponential_method}}\pysigline{\sphinxbfcode{\sphinxupquote{exponential\_method}}}
Method used by the ControlMatrix class for the calculation of the
matrix exponential. The default is ‘Frechet’. See also the Docstring of
the file ‘control\_2.matrix’.
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
string, optional

\end{description}\end{quote}

\end{fulllineitems}

\index{transfer\_function (Solver attribute)@\spxentry{transfer\_function}\spxextra{Solver attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:qsim.solver_algorithms.Solver.transfer_function}}\pysigline{\sphinxbfcode{\sphinxupquote{transfer\_function}}}
The transfer function for reshaping the optimization parameters.
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
{\hyperref[\detokenize{qsim:qsim.transfer_function.TransferFunction}]{\sphinxcrossref{TransferFunction}}}

\end{description}\end{quote}

\end{fulllineitems}

\index{amplitude\_function (Solver attribute)@\spxentry{amplitude\_function}\spxextra{Solver attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:qsim.solver_algorithms.Solver.amplitude_function}}\pysigline{\sphinxbfcode{\sphinxupquote{amplitude\_function}}}
The amplitude function connecting the transferred optimization
parameters to the control amplitudes.
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
{\hyperref[\detokenize{qsim:qsim.amplitude_functions.AmplitudeFunction}]{\sphinxcrossref{AmplitudeFunction}}}

\end{description}\end{quote}

\end{fulllineitems}

\index{\_prop (Solver attribute)@\spxentry{\_prop}\spxextra{Solver attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:qsim.solver_algorithms.Solver._prop}}\pysigline{\sphinxbfcode{\sphinxupquote{\_prop}}}
Propagators of the system.
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
List{[}ControlMatrix{]}, len: num\_t

\end{description}\end{quote}

\end{fulllineitems}

\index{\_fwd\_prop (Solver attribute)@\spxentry{\_fwd\_prop}\spxextra{Solver attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:qsim.solver_algorithms.Solver._fwd_prop}}\pysigline{\sphinxbfcode{\sphinxupquote{\_fwd\_prop}}}
Ordered product of the propagators. They describe the forward
propagation of the systems state.
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
List{[}ControlMatrix{]}, len: num\_t + 1

\end{description}\end{quote}

\end{fulllineitems}

\index{\_reversed\_prop (Solver attribute)@\spxentry{\_reversed\_prop}\spxextra{Solver attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:qsim.solver_algorithms.Solver._reversed_prop}}\pysigline{\sphinxbfcode{\sphinxupquote{\_reversed\_prop}}}
Ordered product of propagators in reversed order.
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
List{[}ControlMatrix{]}, len: num\_t + 1

\end{description}\end{quote}

\end{fulllineitems}

\index{\_derivative\_prop (Solver attribute)@\spxentry{\_derivative\_prop}\spxextra{Solver attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:qsim.solver_algorithms.Solver._derivative_prop}}\pysigline{\sphinxbfcode{\sphinxupquote{\_derivative\_prop}}}
Frechet derivatives of the propagators by the control amplitudes.
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
List{[}List{[}ControlMatrix{]}{]}, shape: {[}{[}{]} * num\_t{]} * num\_ctrl

\end{description}\end{quote}

\end{fulllineitems}



\begin{fulllineitems}
\pysigline{\sphinxbfcode{\sphinxupquote{set\_optimization\_parameters(u,~**kwargs):}}}
Set the control amplitudes. The key word arguments may include the
key transferred parameters.

\end{fulllineitems}



\begin{fulllineitems}
\pysigline{\sphinxbfcode{\sphinxupquote{propagators:~List{[}ControlMatrix{]},~len:~num\_t}}}
Returns the propagators of the system.

\end{fulllineitems}



\begin{fulllineitems}
\pysigline{\sphinxbfcode{\sphinxupquote{forward\_propagators:~List{[}ControlMatrix{]},~len:~num\_t~+~1}}}
Returns the forward propagation of the initial state. The element
forward\_propagators{[}i{]} propagates a state by the first i time steps, if
the initial state is the identity matrix.

\end{fulllineitems}



\begin{fulllineitems}
\pysigline{\sphinxbfcode{\sphinxupquote{frechet\_deriv\_propagators:~List{[}List{[}ControlMatrix{]}{]},}}}~\begin{quote}

shape: {[}{[}{]} * num\_t{]} * num\_ctrl
\end{quote}

Returns the frechet derivatives of the propagators by the control
amplitudes.

\end{fulllineitems}



\begin{fulllineitems}
\pysigline{\sphinxbfcode{\sphinxupquote{reversed\_propagators:~List{[}ControlMatrix{]},~len:~num\_t~+~1}}}
Returns the reversed propagation of the initial state. The element
reversed\_propagators{[}i{]} propagates a state by the last i time steps, if
the initial state is the identity matrix.

\end{fulllineitems}



\begin{fulllineitems}
\pysigline{\sphinxbfcode{\sphinxupquote{plot\_bloch\_sphere:}}}
Uses a pulse sequence to plot the systems evolution on the blochs
sphere. For 2 dimensional systems only.

\end{fulllineitems}



\begin{fulllineitems}
\pysigline{\sphinxbfcode{\sphinxupquote{\_compute\_propagation:~abstract~method}}}
Computes the propagators.

\end{fulllineitems}



\begin{fulllineitems}
\pysigline{\sphinxbfcode{\sphinxupquote{\_compute\_forward\_propagation:}}}
Compute the forward propagation of the initial state / system.

\end{fulllineitems}



\begin{fulllineitems}
\pysigline{\sphinxbfcode{\sphinxupquote{\_compute\_reversed\_propagation:}}}
Compute the reversed propagation of the initial state / system.

\end{fulllineitems}



\begin{fulllineitems}
\pysigline{\sphinxbfcode{\sphinxupquote{\_compute\_propagation\_derivatives:~abstract~method}}}
Compute the derivatives of the propagators by the control amplitudes.

\end{fulllineitems}



\begin{fulllineitems}
\pysigline{\sphinxbfcode{\sphinxupquote{create\_pulse\_sequence(new\_amps):}}}
filter\_functions.pulse\_sequence.PulseSequence
Creates a pulse sequence instance corresponding to the current control
amplitudes.

\end{fulllineitems}


\begin{sphinxadmonition}{note}{\label{\detokenize{qsim:id42}}Todo:}\begin{itemize}
\item {} \begin{description}
\item[{Write parser}] \leavevmode\begin{itemize}
\item {} 
setter for new hamiltonians

\item {} 
make hamiltonians private

\item {} 
also for the initial state

\item {} 
extend constant drift hamiltonian

\end{itemize}

\end{description}

\item {} \begin{description}
\item[{Implement the drift operator with an amplitude. Right now,}] \leavevmode\begin{itemize}
\item {} 
the operator is already multiplied with the amplitude, which is

\item {} 
not coherent with the pulse sequence interface. Alternatively

\item {} 
amplitude=1?

\end{itemize}

\end{description}

\item {} 
tau should be taken from the transfer function

\end{itemize}
\end{sphinxadmonition}
\index{consistency\_checks() (Solver method)@\spxentry{consistency\_checks()}\spxextra{Solver method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:qsim.solver_algorithms.Solver.consistency_checks}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{consistency\_checks}}}{\emph{\DUrole{n}{self}}, \emph{\DUrole{n}{paranoia\_level}\DUrole{p}{:} \DUrole{n}{int}}}{}
Checks attributes for inner consistency.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{paranoia\_level}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} The paranoia\_level determines how many checks are conducted.
0: No tests
1: Some tests
2: Exhaustive tests, dimension checks

\end{description}\end{quote}

\end{fulllineitems}

\index{create\_pulse\_sequence() (Solver method)@\spxentry{create\_pulse\_sequence()}\spxextra{Solver method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:qsim.solver_algorithms.Solver.create_pulse_sequence}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{create\_pulse\_sequence}}}{\emph{self}, \emph{new\_amps: Union{[}\textless{}built\sphinxhyphen{}in function array\textgreater{}}, \emph{NoneType{]} = None}, \emph{ff\_basis: Union{[}filter\_functions.basis.Basis}, \emph{NoneType{]} = None}}{{ $\rightarrow$ \textless{}module ‘filter\_functions.pulse\_sequence’ from ‘C:\textbackslash{}Users\textbackslash{}Inst2C\textbackslash{}miniconda3\textbackslash{}envs\textbackslash{}qsim\sphinxhyphen{}2\textbackslash{}lib\textbackslash{}site\sphinxhyphen{}packages\textbackslash{}filter\_functions\textbackslash{}pulse\_sequence.py’\textgreater{}}}
Create a pulse sequence of the filter function package written by
Tobias Hangleiter.

See the documentation of the filter function package.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{new\_amps}} (\sphinxstyleliteralemphasis{\sphinxupquote{np.array}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{shape:}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{num\_t}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{num\_ctrl}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} New control amplitudes can be set before the pulse sequence is
initialized.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ff\_basis}} (\sphinxstyleliteralemphasis{\sphinxupquote{Basis}}) \textendash{} The pulse sequence will be expanded in this basis. See
documentation of the filter function package.

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxstylestrong{pulse\_sequence} \textendash{} The pulse sequence corresponding to the control model and the
control amplitudes set.

\item[{Return type}] \leavevmode
filter\_functions.pulse\_sequence.PulseSequence

\end{description}\end{quote}

\end{fulllineitems}

\index{forward\_propagators() (Solver property)@\spxentry{forward\_propagators()}\spxextra{Solver property}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:qsim.solver_algorithms.Solver.forward_propagators}}\pysigline{\sphinxbfcode{\sphinxupquote{property }}\sphinxbfcode{\sphinxupquote{forward\_propagators}}}
Returns the forward propagation of the initial state for every time
slice and calculate it if necessary. If the initial state is the
identity matrix, then the cumulative propagators are given. The element
forward\_propagators{[}i{]} propagates a state by the first i time steps, if
the initial state is the identity matrix.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxstylestrong{forward\_propagation} \textendash{} Propagation of the initial state of the system. fwd{[}0{]} gives the
initial state itself.

\item[{Return type}] \leavevmode
List{[}ControlMatrix{]}, len: num\_t + 1

\end{description}\end{quote}

\end{fulllineitems}

\index{frechet\_deriv\_propagators() (Solver property)@\spxentry{frechet\_deriv\_propagators()}\spxextra{Solver property}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:qsim.solver_algorithms.Solver.frechet_deriv_propagators}}\pysigline{\sphinxbfcode{\sphinxupquote{property }}\sphinxbfcode{\sphinxupquote{frechet\_deriv\_propagators}}}
Returns the frechet derivatives of the propagators.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxstylestrong{derivative\_prop} \textendash{}              shape: {[}{[}{]} * num\_t{]} * num\_ctrl
Frechet derivatives of the propagators by the control amplitudes

\item[{Return type}] \leavevmode
List{[}List{[}ControlMatrix{]}{]},

\end{description}\end{quote}

\end{fulllineitems}

\index{plot\_bloch\_sphere() (Solver method)@\spxentry{plot\_bloch\_sphere()}\spxextra{Solver method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:qsim.solver_algorithms.Solver.plot_bloch_sphere}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{plot\_bloch\_sphere}}}{\emph{\DUrole{n}{self}}}{{ $\rightarrow$ None}}
Uses the pulse sequence to plot the systems evolution on the bloch
sphere.

Only available for two dimensional systems.

\end{fulllineitems}

\index{propagators() (Solver property)@\spxentry{propagators()}\spxextra{Solver property}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:qsim.solver_algorithms.Solver.propagators}}\pysigline{\sphinxbfcode{\sphinxupquote{property }}\sphinxbfcode{\sphinxupquote{propagators}}}
Returns the propagators of the system and calculates them if necessary.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxstylestrong{propagators} \textendash{} Propagators of the system.

\item[{Return type}] \leavevmode
List{[}ControlMatrix{]}, len: num\_t

\end{description}\end{quote}

\end{fulllineitems}

\index{reversed\_propagators() (Solver property)@\spxentry{reversed\_propagators()}\spxextra{Solver property}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:qsim.solver_algorithms.Solver.reversed_propagators}}\pysigline{\sphinxbfcode{\sphinxupquote{property }}\sphinxbfcode{\sphinxupquote{reversed\_propagators}}}
Returns the reversed propagation of the initial state for every time
slice and calculate it if necessary. If the initial state is the
identity matrix, then the reversed cumulative propagators are given.
The element forward\_propagators{[}i{]} propagates a state by the first i
time steps, if the initial state is the identity matrix.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxstylestrong{reversed\_propagation} \textendash{} Propagation of the initial state of the system. reversed{[}0{]} gives
the initial state itself.

\item[{Return type}] \leavevmode
List{[}ControlMatrix{]}, len: num\_t + 1

\end{description}\end{quote}

\end{fulllineitems}

\index{set\_optimization\_parameters() (Solver method)@\spxentry{set\_optimization\_parameters()}\spxextra{Solver method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:qsim.solver_algorithms.Solver.set_optimization_parameters}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{set\_optimization\_parameters}}}{\emph{self}, \emph{y: \textless{}built\sphinxhyphen{}in function array\textgreater{}}}{{ $\rightarrow$ None}}
Set the control amplitudes.

All computation flags are set to false.

The new control amplitudes u are calculated:
u: np.array, shape: (num\_t, num\_ctrl)
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{y}} (\sphinxstyleliteralemphasis{\sphinxupquote{np.array}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{shape:}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{num\_x}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{num\_ctrl}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} Raw optimization parameters.

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\subsection{qsim.transfer\_function module}
\label{\detokenize{qsim:module-qsim.transfer_function}}\label{\detokenize{qsim:qsim-transfer-function-module}}\index{module@\spxentry{module}!qsim.transfer\_function@\spxentry{qsim.transfer\_function}}\index{qsim.transfer\_function@\spxentry{qsim.transfer\_function}!module@\spxentry{module}}
Models the response function of control electronics and pulse smoothing.

Due to the imperfection of the control electronics, the generated control pulse
which is received by the physical qubit is not exactly the pulse which has been
implemented at the control level.

If for example a voltage is changed from one
value to another at a single point in time at the control level, then the
control electronics might need some time to physically reach the new voltage.

Another example would be an amplifier, which has a non\sphinxhyphen{}linearity in the
amplification of a control pulse.

Optimal control methods for rapidly time\sphinxhyphen{}varying Hamiltonians, 2011
Motzoi, F. and Gambetta, J. M. and Merkel, S. T. and Wilhelm, F. K.
PhysRevA.84.022307, \sphinxurl{https://link.aps.org/doi/10.1103/PhysRevA.84.022307}


\subsubsection{Classes}
\label{\detokenize{qsim:id43}}\begin{description}
\item[{{\hyperref[\detokenize{qsim:qsim.transfer_function.TransferFunction}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{TransferFunction}}}}}}] \leavevmode
Abstract base class.

\item[{{\hyperref[\detokenize{qsim:qsim.transfer_function.IdentityTF}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{IdentityTF}}}}}}] \leavevmode
Optimization variables are the amplitudes of the control fields.

\item[{{\hyperref[\detokenize{qsim:qsim.transfer_function.ConcatenateTF}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{ConcatenateTF}}}}}}] \leavevmode
Concatenation of two transfer functions.

\item[{{\hyperref[\detokenize{qsim:qsim.transfer_function.ParallelTF}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{ParallelTF}}}}}}] \leavevmode
Using to transfer functions for two sets of parameters in paralell.

\item[{{\hyperref[\detokenize{qsim:qsim.transfer_function.CustomTF}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{CustomTF}}}}}}] \leavevmode
Transfer function which receives an explicitly constructed constant
transfer matrix.

\item[{{\hyperref[\detokenize{qsim:qsim.transfer_function.ExponentialTF}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{ExponentialTF}}}}}}] \leavevmode
The amplitudes are smoothed by exponential saturation functions.

\end{description}


\subsubsection{Functions}
\label{\detokenize{qsim:id44}}\begin{description}
\item[{{\hyperref[\detokenize{qsim:qsim.transfer_function.exp_saturation}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{exp\_saturation()}}}}}}] \leavevmode
Exponential saturation function.

\end{description}

\begin{sphinxadmonition}{note}{Notes}

The implementation was inspired by the optimal control package of QuTiP \sphinxcite{qsim:r04aaa0b1dcb4-1}
(Quantum Toolbox in Python)
\end{sphinxadmonition}
\subsubsection*{References}
\index{ConcatenateTF (class in qsim.transfer\_function)@\spxentry{ConcatenateTF}\spxextra{class in qsim.transfer\_function}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:qsim.transfer_function.ConcatenateTF}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxbfcode{\sphinxupquote{ConcatenateTF}}}{\emph{\DUrole{n}{tf1}\DUrole{p}{:} \DUrole{n}{{\hyperref[\detokenize{qsim:qsim.transfer_function.TransferFunction}]{\sphinxcrossref{qsim.transfer\_function.TransferFunction}}}}}, \emph{\DUrole{n}{tf2}\DUrole{p}{:} \DUrole{n}{{\hyperref[\detokenize{qsim:qsim.transfer_function.TransferFunction}]{\sphinxcrossref{qsim.transfer\_function.TransferFunction}}}}}}{}
Bases: {\hyperref[\detokenize{qsim:qsim.transfer_function.TransferFunction}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{qsim.transfer\_function.TransferFunction}}}}}

Concatenates two transfer functions.

This class can be used if there are two transfer functions which are to be
applied one after another. For example if first the pulse generation and
subsequently a pulse amplification shall be modeled.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{tf1}} ({\hyperref[\detokenize{qsim:qsim.transfer_function.TransferFunction}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{TransferFunction}}}}}) \textendash{} First transfer function. This function operates directly on the
optimization variables.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{tf2}} ({\hyperref[\detokenize{qsim:qsim.transfer_function.TransferFunction}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{TransferFunction}}}}}) \textendash{} Second transfer function. This function operates on the
output of the first transfer function.

\end{itemize}

\end{description}\end{quote}
\index{gradient\_chain\_rule() (ConcatenateTF method)@\spxentry{gradient\_chain\_rule()}\spxextra{ConcatenateTF method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:qsim.transfer_function.ConcatenateTF.gradient_chain_rule}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{gradient\_chain\_rule}}}{\emph{\DUrole{n}{self}}, \emph{\DUrole{n}{deriv\_by\_transferred\_par}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}}{{ $\rightarrow$ numpy.ndarray}}
Applies the concatenation formula for both transfer functions.

\end{fulllineitems}

\index{plot\_pulse() (ConcatenateTF method)@\spxentry{plot\_pulse()}\spxextra{ConcatenateTF method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:qsim.transfer_function.ConcatenateTF.plot_pulse}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{plot\_pulse}}}{\emph{\DUrole{n}{self}}, \emph{\DUrole{n}{y}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}}{{ $\rightarrow$ None}}
Calls the plot\_pulse routine of the second transfer function.

\end{fulllineitems}

\index{set\_times() (ConcatenateTF method)@\spxentry{set\_times()}\spxextra{ConcatenateTF method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:qsim.transfer_function.ConcatenateTF.set_times}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{set\_times}}}{\emph{\DUrole{n}{self}}, \emph{\DUrole{n}{y\_times}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}}{{ $\rightarrow$ None}}
Sets x\_times on the first transfer function and sets the resulting
x\_times on the second transfer function.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{y\_times}} (\sphinxstyleliteralemphasis{\sphinxupquote{Optional}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{np.array}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{list}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} Time durations of the constant control steps of the raw
optimization parameters.

\end{description}\end{quote}

\end{fulllineitems}

\index{transfer\_matrix() (ConcatenateTF property)@\spxentry{transfer\_matrix()}\spxextra{ConcatenateTF property}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:qsim.transfer_function.ConcatenateTF.transfer_matrix}}\pysigline{\sphinxbfcode{\sphinxupquote{property }}\sphinxbfcode{\sphinxupquote{transfer\_matrix}}}
The total transfer matrix is the product of the individual ones.

\end{fulllineitems}


\end{fulllineitems}

\index{CustomTF (class in qsim.transfer\_function)@\spxentry{CustomTF}\spxextra{class in qsim.transfer\_function}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:qsim.transfer_function.CustomTF}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxbfcode{\sphinxupquote{CustomTF}}}{\emph{\DUrole{n}{transfer\_function}\DUrole{p}{:} \DUrole{n}{numpy.array}}, \emph{\DUrole{n}{x\_times}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}numpy.array\DUrole{p}{{]}}} \DUrole{o}{=} \DUrole{default_value}{None}}, \emph{\DUrole{n}{bound\_type}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}Tuple\DUrole{p}{{]}}} \DUrole{o}{=} \DUrole{default_value}{None}}, \emph{\DUrole{n}{oversampling}\DUrole{p}{:} \DUrole{n}{int} \DUrole{o}{=} \DUrole{default_value}{1}}, \emph{\DUrole{n}{offset}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}float\DUrole{p}{{]}}} \DUrole{o}{=} \DUrole{default_value}{None}}, \emph{\DUrole{n}{num\_ctrls}\DUrole{p}{:} \DUrole{n}{int} \DUrole{o}{=} \DUrole{default_value}{1}}}{}
Bases: {\hyperref[\detokenize{qsim:qsim.transfer_function.TransferFunction}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{qsim.transfer\_function.TransferFunction}}}}}

This class implements a linear transfer function.

The action is fully described by the transfer function and a constant
offset, given at the initialization of the instance.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{transfer\_function}} (\sphinxstyleliteralemphasis{\sphinxupquote{np.array}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{shape}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{num\_x}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{num\_y}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{num\_par}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} Constant transfer function.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{offset}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} Constant offset.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{x\_times}} (\sphinxstyleliteralemphasis{\sphinxupquote{np.array}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{shape}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{num\_x}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} Time slices of the control amplitudes. If they are not explicitly
given, they are constructed from oversampling and bound\_type.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{bound\_type}} (\sphinxstyleliteralemphasis{\sphinxupquote{see base class}}) \textendash{} If no bound\_type is specified. The program assumes that there is no
padding.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{oversampling}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} If the oversampling is not explicitly given, it is constructed from
the bound\_type and the transfer matrix.

\end{itemize}

\end{description}\end{quote}

\begin{sphinxadmonition}{note}{\label{\detokenize{qsim:id46}}Todo:}\begin{itemize}
\item {} \begin{description}
\item[{does it make sense so set the utimes explicitly? breakes the usual}] \leavevmode\begin{itemize}
\item {} 
workflow

\end{itemize}

\end{description}

\end{itemize}
\end{sphinxadmonition}
\index{set\_times() (CustomTF method)@\spxentry{set\_times()}\spxextra{CustomTF method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:qsim.transfer_function.CustomTF.set_times}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{set\_times}}}{\emph{\DUrole{n}{self}}, \emph{\DUrole{n}{y\_times}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}}{{ $\rightarrow$ None}}
See base class.

\end{fulllineitems}

\index{transfer\_matrix() (CustomTF property)@\spxentry{transfer\_matrix()}\spxextra{CustomTF property}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:qsim.transfer_function.CustomTF.transfer_matrix}}\pysigline{\sphinxbfcode{\sphinxupquote{property }}\sphinxbfcode{\sphinxupquote{transfer\_matrix}}}
See base class.

\end{fulllineitems}


\end{fulllineitems}

\index{ExponentialTF (class in qsim.transfer\_function)@\spxentry{ExponentialTF}\spxextra{class in qsim.transfer\_function}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:qsim.transfer_function.ExponentialTF}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxbfcode{\sphinxupquote{ExponentialTF}}}{\emph{\DUrole{n}{awg\_rise\_time}\DUrole{p}{:} \DUrole{n}{float}}, \emph{\DUrole{n}{oversampling}\DUrole{p}{:} \DUrole{n}{int} \DUrole{o}{=} \DUrole{default_value}{1}}, \emph{\DUrole{n}{bound\_type}\DUrole{p}{:} \DUrole{n}{Tuple} \DUrole{o}{=} \DUrole{default_value}{\textquotesingle{}x\textquotesingle{}, 0}}, \emph{\DUrole{n}{offset}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}float\DUrole{p}{{]}}} \DUrole{o}{=} \DUrole{default_value}{None}}, \emph{\DUrole{n}{num\_ctrls}\DUrole{p}{:} \DUrole{n}{int} \DUrole{o}{=} \DUrole{default_value}{1}}}{}
Bases: {\hyperref[\detokenize{qsim:qsim.transfer_function.TransferFunction}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{qsim.transfer\_function.TransferFunction}}}}}

This transfer function model smooths the control amplitudes by exponential
saturation.

The functionality is meant to model the finite rise time of voltage
sources.

\begin{sphinxadmonition}{note}{\label{\detokenize{qsim:id47}}Todo:}\begin{itemize}
\item {} 
add initial and final level. Currently fixed at 0 (or the offset)

\end{itemize}
\end{sphinxadmonition}
\index{gradient\_chain\_rule() (ExponentialTF method)@\spxentry{gradient\_chain\_rule()}\spxextra{ExponentialTF method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:qsim.transfer_function.ExponentialTF.gradient_chain_rule}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{gradient\_chain\_rule}}}{\emph{\DUrole{n}{self}}, \emph{\DUrole{n}{deriv\_by\_transferred\_par}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}}{{ $\rightarrow$ numpy.ndarray}}
See base class.

\end{fulllineitems}

\index{old\_call() (ExponentialTF method)@\spxentry{old\_call()}\spxextra{ExponentialTF method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:qsim.transfer_function.ExponentialTF.old_call}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{old\_call}}}{\emph{\DUrole{n}{self}}, \emph{\DUrole{n}{x}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}}{}
TODO: only alive for testing

\end{fulllineitems}

\index{plot\_pulse\_old() (ExponentialTF method)@\spxentry{plot\_pulse\_old()}\spxextra{ExponentialTF method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:qsim.transfer_function.ExponentialTF.plot_pulse_old}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{plot\_pulse\_old}}}{\emph{\DUrole{n}{self}}, \emph{\DUrole{n}{x}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}}{{ $\rightarrow$ None}}
Plot the control amplitudes corresponding to the given optimisation
variables.

\end{fulllineitems}

\index{reverse\_state() (ExponentialTF method)@\spxentry{reverse\_state()}\spxextra{ExponentialTF method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:qsim.transfer_function.ExponentialTF.reverse_state}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{reverse\_state}}}{\emph{\DUrole{n}{self}}, \emph{\DUrole{n}{amplitudes}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{times}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{targetfunc}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
I assume only to be applied to Pulses generated by self.\_\_call\_\_(x)
If times is None:
We either need to know num\_x or the oversampling. For now I assume that
self.num\_x is valid for the input data.
:param amplitudes:
:param times
:param targetfunc:
:return:

\end{fulllineitems}

\index{transfer\_matrix() (ExponentialTF property)@\spxentry{transfer\_matrix()}\spxextra{ExponentialTF property}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:qsim.transfer_function.ExponentialTF.transfer_matrix}}\pysigline{\sphinxbfcode{\sphinxupquote{property }}\sphinxbfcode{\sphinxupquote{transfer\_matrix}}}
See base class.

\end{fulllineitems}


\end{fulllineitems}

\index{Gaussian (class in qsim.transfer\_function)@\spxentry{Gaussian}\spxextra{class in qsim.transfer\_function}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:qsim.transfer_function.Gaussian}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxbfcode{\sphinxupquote{Gaussian}}}{\emph{\DUrole{n}{omega}\DUrole{o}{=}\DUrole{default_value}{1}}, \emph{\DUrole{n}{over\_sample\_rate}\DUrole{o}{=}\DUrole{default_value}{5}}, \emph{\DUrole{n}{start}\DUrole{o}{=}\DUrole{default_value}{0.0}}, \emph{\DUrole{n}{end}\DUrole{o}{=}\DUrole{default_value}{0.0}}, \emph{\DUrole{n}{bound\_type}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}w\textquotesingle{}, 2}}}{}
Bases: {\hyperref[\detokenize{qsim:qsim.transfer_function.TransferFunction}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{qsim.transfer\_function.TransferFunction}}}}}

Represent square function filtered through a gaussian filter.

Can not be used in conjunction with the concatenate tf.
\index{gradient\_chain\_rule() (Gaussian method)@\spxentry{gradient\_chain\_rule()}\spxextra{Gaussian method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:qsim.transfer_function.Gaussian.gradient_chain_rule}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{gradient\_chain\_rule}}}{\emph{\DUrole{n}{self}}, \emph{\DUrole{n}{deriv\_by\_transferred\_par}}}{}
See base class.

\end{fulllineitems}

\index{make\_T() (Gaussian method)@\spxentry{make\_T()}\spxextra{Gaussian method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:qsim.transfer_function.Gaussian.make_T}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{make\_T}}}{\emph{\DUrole{n}{self}}}{}
Calculate the transfer matrix.

\end{fulllineitems}

\index{set\_times() (Gaussian method)@\spxentry{set\_times()}\spxextra{Gaussian method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:qsim.transfer_function.Gaussian.set_times}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{set\_times}}}{\emph{\DUrole{n}{self}}, \emph{\DUrole{n}{times}}}{}
See base class.

Times/tau correspond to the timeslot before the interpolation.

\end{fulllineitems}

\index{transfer\_matrix() (Gaussian property)@\spxentry{transfer\_matrix()}\spxextra{Gaussian property}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:qsim.transfer_function.Gaussian.transfer_matrix}}\pysigline{\sphinxbfcode{\sphinxupquote{property }}\sphinxbfcode{\sphinxupquote{transfer\_matrix}}}
See base class.

\end{fulllineitems}


\end{fulllineitems}

\index{IdentityTF (class in qsim.transfer\_function)@\spxentry{IdentityTF}\spxextra{class in qsim.transfer\_function}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:qsim.transfer_function.IdentityTF}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxbfcode{\sphinxupquote{IdentityTF}}}{\emph{\DUrole{n}{oversampling}\DUrole{p}{:} \DUrole{n}{int} \DUrole{o}{=} \DUrole{default_value}{1}}, \emph{\DUrole{n}{bound\_type}\DUrole{p}{:} \DUrole{n}{Tuple} \DUrole{o}{=} \DUrole{default_value}{None}}, \emph{\DUrole{n}{num\_ctrls}\DUrole{p}{:} \DUrole{n}{int} \DUrole{o}{=} \DUrole{default_value}{1}}, \emph{\DUrole{n}{offset}\DUrole{p}{:} \DUrole{n}{float} \DUrole{o}{=} \DUrole{default_value}{0}}}{}
Bases: {\hyperref[\detokenize{qsim:qsim.transfer_function.TransferFunction}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{qsim.transfer\_function.TransferFunction}}}}}

Identity as transfer function.

\end{fulllineitems}

\index{LinearTF (class in qsim.transfer\_function)@\spxentry{LinearTF}\spxextra{class in qsim.transfer\_function}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:qsim.transfer_function.LinearTF}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxbfcode{\sphinxupquote{LinearTF}}}{\emph{\DUrole{n}{oversampling}\DUrole{p}{:} \DUrole{n}{int} \DUrole{o}{=} \DUrole{default_value}{1}}, \emph{\DUrole{n}{bound\_type}\DUrole{p}{:} \DUrole{n}{Tuple} \DUrole{o}{=} \DUrole{default_value}{None}}, \emph{\DUrole{n}{num\_ctrls}\DUrole{p}{:} \DUrole{n}{int} \DUrole{o}{=} \DUrole{default_value}{1}}, \emph{\DUrole{n}{offset}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}float\DUrole{p}{{]}}} \DUrole{o}{=} \DUrole{default_value}{None}}, \emph{\DUrole{n}{linear\_factor}\DUrole{p}{:} \DUrole{n}{float} \DUrole{o}{=} \DUrole{default_value}{1}}}{}
Bases: {\hyperref[\detokenize{qsim:qsim.transfer_function.IdentityTF}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{qsim.transfer\_function.IdentityTF}}}}}

A linear transfer function.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{linear\_factor}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} The factor by which the optimization parameters are multiplied to
calculate the control amplitudes.

\end{description}\end{quote}

\end{fulllineitems}

\index{ParallelTF (class in qsim.transfer\_function)@\spxentry{ParallelTF}\spxextra{class in qsim.transfer\_function}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:qsim.transfer_function.ParallelTF}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxbfcode{\sphinxupquote{ParallelTF}}}{\emph{\DUrole{n}{tf1}\DUrole{p}{:} \DUrole{n}{{\hyperref[\detokenize{qsim:qsim.transfer_function.TransferFunction}]{\sphinxcrossref{qsim.transfer\_function.TransferFunction}}}}}, \emph{\DUrole{n}{tf2}\DUrole{p}{:} \DUrole{n}{{\hyperref[\detokenize{qsim:qsim.transfer_function.TransferFunction}]{\sphinxcrossref{qsim.transfer\_function.TransferFunction}}}}}}{}
Bases: {\hyperref[\detokenize{qsim:qsim.transfer_function.TransferFunction}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{qsim.transfer\_function.TransferFunction}}}}}

This transfer function will parallelize two transfer functions, such that
they are applied to different control terms. Thus adding in the third
dimension of the transfer matrix.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{tf1}} ({\hyperref[\detokenize{qsim:qsim.transfer_function.TransferFunction}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{TransferFunction}}}}}) \textendash{} First transfer function. This function operates on the first
tf1.num\_ctrls control pulses.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{tf2}} ({\hyperref[\detokenize{qsim:qsim.transfer_function.TransferFunction}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{TransferFunction}}}}}) \textendash{} Second transfer function. This function operates on the
next tf2.\_num\_ctrls number of control pulses.

\end{itemize}

\end{description}\end{quote}
\index{set\_times() (ParallelTF method)@\spxentry{set\_times()}\spxextra{ParallelTF method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:qsim.transfer_function.ParallelTF.set_times}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{set\_times}}}{\emph{\DUrole{n}{self}}, \emph{\DUrole{n}{y\_times}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}}{}
See base class.

\end{fulllineitems}


\end{fulllineitems}

\index{TransferFunction (class in qsim.transfer\_function)@\spxentry{TransferFunction}\spxextra{class in qsim.transfer\_function}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:qsim.transfer_function.TransferFunction}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxbfcode{\sphinxupquote{TransferFunction}}}{\emph{\DUrole{n}{num\_ctrls}\DUrole{p}{:} \DUrole{n}{int} \DUrole{o}{=} \DUrole{default_value}{1}}, \emph{\DUrole{n}{bound\_type}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}Tuple\DUrole{p}{{[}}str\DUrole{p}{, }int\DUrole{p}{{]}}\DUrole{p}{{]}}} \DUrole{o}{=} \DUrole{default_value}{None}}, \emph{\DUrole{n}{oversampling}\DUrole{p}{:} \DUrole{n}{int} \DUrole{o}{=} \DUrole{default_value}{1}}, \emph{\DUrole{n}{offset}\DUrole{p}{:} \DUrole{n}{Optional\DUrole{p}{{[}}float\DUrole{p}{{]}}} \DUrole{o}{=} \DUrole{default_value}{None}}}{}
Bases: \sphinxcode{\sphinxupquote{abc.ABC}}

A class for representing transfer functions, between optimization
variables of the optimization algorithm and the amplitudes of the control
fields.

The intended workflow is to initialise the transfer function object first
and subsequently set the x\_times, which is the time scale of the
optimization variables. Then the transfer function is called to calculate
control amplitudes and gradients.
\subsubsection*{Examples}

Example work flow with the abstract base class:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{x\PYGZus{}times} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{ones}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{optimization\PYGZus{}variables} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{rand}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{gradient\PYGZus{}fidelity\PYGZus{}by\PYGZus{}control\PYGZus{}amplitudes} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{rand}\PYG{p}{(}\PYG{n}{shape}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{30}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{transfer\PYGZus{}function} \PYG{o}{=} \PYG{n}{TransferFunction}\PYG{p}{(}\PYG{n}{oversampling}\PYG{o}{=}\PYG{l+m+mi}{5}\PYG{p}{,}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }                                     \PYG{n}{bound\PYGZus{}type}\PYG{o}{=}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{x}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{transfer\PYGZus{}function}\PYG{o}{.}\PYG{n}{set\PYGZus{}times}\PYG{p}{(}\PYG{n}{x\PYGZus{}times}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{control\PYGZus{}amplitudes} \PYG{o}{=} \PYG{n}{transfer\PYGZus{}function}\PYG{p}{(}\PYG{n}{optimization\PYGZus{}variables}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{gradient\PYGZus{}fidelity\PYGZus{}by\PYGZus{}optimization\PYGZus{}variables} \PYG{o}{=}     \PYG{o}{\PYGZgt{}\PYGZgt{}}\PYG{o}{\PYGZgt{}}     \PYG{n}{transfer\PYGZus{}function}\PYG{o}{.}\PYG{n}{gradient\PYGZus{}chain\PYGZus{}rule}\PYG{p}{(}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }        \PYG{n}{gradient\PYGZus{}fidelity\PYGZus{}by\PYGZus{}control\PYGZus{}amplitudes}\PYG{p}{)}
\end{sphinxVerbatim}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{num\_ctrls}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Number of controlled amplitudes.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{oversampling}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Each time step of the optimization variables is sliced into a number
of time steps of the control amplitudes.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{bound\_type}} (\sphinxstyleliteralemphasis{\sphinxupquote{(}}\sphinxstyleliteralemphasis{\sphinxupquote{code}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{number}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} 
Control the number of time slice of padding before and after the
original time range. Let dt denote the first or respectively last time
duration of the optimization variables.
\begin{description}
\item[{code:}] \leavevmode
”n”: n extra slice of dt/overSampleRate
“x”: n extra slice of dt (default with n=1)
“right\_n”: n extra slice of dt/overSampleRage on the right side

\end{description}


\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{offset}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} Constant offset which is added to the optimization parameters.

\end{itemize}

\end{description}\end{quote}
\index{num\_ctrls (TransferFunction attribute)@\spxentry{num\_ctrls}\spxextra{TransferFunction attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:qsim.transfer_function.TransferFunction.num_ctrls}}\pysigline{\sphinxbfcode{\sphinxupquote{num\_ctrls}}}
Number of controlled amplitudes.
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
int

\end{description}\end{quote}

\end{fulllineitems}

\index{oversampling (TransferFunction attribute)@\spxentry{oversampling}\spxextra{TransferFunction attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:qsim.transfer_function.TransferFunction.oversampling}}\pysigline{\sphinxbfcode{\sphinxupquote{oversampling}}}
Each time step of the optimization variables is sliced into a number
of time steps of the control amplitudes.
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
int

\end{description}\end{quote}

\end{fulllineitems}

\index{bound\_type (TransferFunction attribute)@\spxentry{bound\_type}\spxextra{TransferFunction attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:qsim.transfer_function.TransferFunction.bound_type}}\pysigline{\sphinxbfcode{\sphinxupquote{bound\_type}}}
Control the number of time slice of padding before and after the
original time range. Let dt denote the first or respectively last time
duration of the optimization variables.
\begin{description}
\item[{code:}] \leavevmode
“n”: n extra slice of dt/overSampleRate
“x”: n extra slice of dt (default with n=1)
“right\_n”: n extra slice of dt/overSampleRage on the right side

\end{description}
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
(code, number)

\end{description}\end{quote}

\end{fulllineitems}

\index{offset (TransferFunction attribute)@\spxentry{offset}\spxextra{TransferFunction attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:qsim.transfer_function.TransferFunction.offset}}\pysigline{\sphinxbfcode{\sphinxupquote{offset}}}
Constant offset which is added to the optimization parameters.
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
float

\end{description}\end{quote}

\end{fulllineitems}

\index{\_num\_y (TransferFunction attribute)@\spxentry{\_num\_y}\spxextra{TransferFunction attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:qsim.transfer_function.TransferFunction._num_y}}\pysigline{\sphinxbfcode{\sphinxupquote{\_num\_y}}}
Number of time slices of the raw optimization variables.
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
int

\end{description}\end{quote}

\end{fulllineitems}

\index{\_num\_x (TransferFunction attribute)@\spxentry{\_num\_x}\spxextra{TransferFunction attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:qsim.transfer_function.TransferFunction._num_x}}\pysigline{\sphinxbfcode{\sphinxupquote{\_num\_x}}}
Number of time slices of the transferred optimization variables.
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
int

\end{description}\end{quote}

\end{fulllineitems}

\index{\_x\_times (TransferFunction attribute)@\spxentry{\_x\_times}\spxextra{TransferFunction attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:qsim.transfer_function.TransferFunction._x_times}}\pysigline{\sphinxbfcode{\sphinxupquote{\_x\_times}}}
Time values for the transferred optimization parameters. These
describe the length of the time slices.
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
array, shape (num\_u)

\end{description}\end{quote}

\end{fulllineitems}

\index{\_y\_times (TransferFunction attribute)@\spxentry{\_y\_times}\spxextra{TransferFunction attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:qsim.transfer_function.TransferFunction._y_times}}\pysigline{\sphinxbfcode{\sphinxupquote{\_y\_times}}}
Time values for the raw control variables. These  describe the length
of the time slices.
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
array, shape (num\_x)

\end{description}\end{quote}

\end{fulllineitems}

\index{\_absolute\_y\_times (TransferFunction attribute)@\spxentry{\_absolute\_y\_times}\spxextra{TransferFunction attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:qsim.transfer_function.TransferFunction._absolute_y_times}}\pysigline{\sphinxbfcode{\sphinxupquote{\_absolute\_y\_times}}}
Absolute times of the raw optimization variables. The values describe
the point in time where a time slice ends and the next one begins.
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
array\_like, shape (num\_x + 1)

\end{description}\end{quote}

\end{fulllineitems}



\begin{fulllineitems}
\pysigline{\sphinxbfcode{\sphinxupquote{\_\_call\_\_(y):}}}
Application of the transfer function.

\end{fulllineitems}



\begin{fulllineitems}
\pysigline{\sphinxbfcode{\sphinxupquote{transfer\_matrix:~property,~returns~array,~shape~(num\_x,~num\_y,~num\_par)}}}
Returns the transfer matrix.

\end{fulllineitems}



\begin{fulllineitems}
\pysigline{\sphinxbfcode{\sphinxupquote{num\_padding\_elements:~property,~returns~list}}}
Two elements list with the number of elements padded to the beginning
and end, as specified by the bound type.

\end{fulllineitems}



\begin{fulllineitems}
\pysigline{\sphinxbfcode{\sphinxupquote{set\_times(times):}}}
Set the times of the optimization variables and calculates the times
of the optimization variables.

\end{fulllineitems}



\begin{fulllineitems}
\pysigline{\sphinxbfcode{\sphinxupquote{set\_absolute\_times(absolute\_y\_times):}}}
Set the absolute times (time points of beginning and ending a time
step) of the optimization variables.

\end{fulllineitems}



\begin{fulllineitems}
\pysigline{\sphinxbfcode{\sphinxupquote{plot\_pulse(y):}}}
For the raw optimisation variables (y), plot the resulting pulse.

\end{fulllineitems}



\begin{fulllineitems}
\pysigline{\sphinxbfcode{\sphinxupquote{TODO:}}}~\begin{itemize}
\item {} 
make the x\_times public

\item {} 
bound type seems to be buggy. test with exp\_transfer

\item {} 
parse bound\_type to raise exception only in one function.

\item {} 
add exception to the docstring

\item {} 
\_x\_max, \_x\_min only useful for deprecated functions

\item {} \begin{description}
\item[{combinator transfer function that allows multiple controls with}] \leavevmode\begin{itemize}
\item {} 
distinct transfer functions

\end{itemize}

\end{description}

\item {} 
use the name attribute?

\item {} \begin{description}
\item[{refactor the use of the offset. maybe make it an array of the}] \leavevmode\begin{itemize}
\item {} 
shape of u

\end{itemize}

\end{description}

\end{itemize}

\end{fulllineitems}

\index{gradient\_chain\_rule() (TransferFunction method)@\spxentry{gradient\_chain\_rule()}\spxextra{TransferFunction method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:qsim.transfer_function.TransferFunction.gradient_chain_rule}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{gradient\_chain\_rule}}}{\emph{self}, \emph{deriv\_by\_transferred\_par: \textless{}built\sphinxhyphen{}in function array\textgreater{}}}{{ $\rightarrow$ \textless{}built\sphinxhyphen{}in function array\textgreater{}}}
Obtain the derivatives of a quantity a i.e. da/dy by the optimization
variables from the derivatives by the amplitude of the control fields.

The chain rule applies: df/dy = df/dx * dx/dy.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{deriv\_by\_transferred\_par}} (\sphinxstyleliteralemphasis{\sphinxupquote{np.array}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{shape}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{num\_x}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{num\_f}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{num\_par}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} The gradients of num\_f functions by num\_par optimization parameters
at num\_x different time steps.

\item[{Returns}] \leavevmode
\sphinxstylestrong{deriv\_by\_opt\_par} \textendash{} The derivatives by the optimization parameters at num\_y time steps.

\item[{Return type}] \leavevmode
np.array, shape: (num\_y, num\_f, num\_par)

\end{description}\end{quote}

\end{fulllineitems}

\index{num\_padding\_elements() (TransferFunction property)@\spxentry{num\_padding\_elements()}\spxextra{TransferFunction property}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:qsim.transfer_function.TransferFunction.num_padding_elements}}\pysigline{\sphinxbfcode{\sphinxupquote{property }}\sphinxbfcode{\sphinxupquote{num\_padding\_elements}}}
Convenience function. Returns the number of elements padded to the
beginning and the end of the control amplitude times.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxstylestrong{num\_padding\_elements} \textendash{} (elements padded to the beginning, elements padded to the end)

\item[{Return type}] \leavevmode
(int, int)

\end{description}\end{quote}

\end{fulllineitems}

\index{plot\_pulse() (TransferFunction method)@\spxentry{plot\_pulse()}\spxextra{TransferFunction method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:qsim.transfer_function.TransferFunction.plot_pulse}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{plot\_pulse}}}{\emph{self}, \emph{y: \textless{}built\sphinxhyphen{}in function array\textgreater{}}}{{ $\rightarrow$ None}}
Plot the control amplitudes corresponding to the given optimisation
variables.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{y}} (\sphinxstyleliteralemphasis{\sphinxupquote{array}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{shape}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{num\_y}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{num\_par}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} Raw optimization parameters.

\end{description}\end{quote}

\end{fulllineitems}

\index{set\_absolute\_times() (TransferFunction method)@\spxentry{set\_absolute\_times()}\spxextra{TransferFunction method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:qsim.transfer_function.TransferFunction.set_absolute_times}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{set\_absolute\_times}}}{\emph{\DUrole{n}{self}}, \emph{\DUrole{n}{absolute\_y\_times}\DUrole{p}{:} \DUrole{n}{numpy.ndarray}}}{{ $\rightarrow$ None}}
Generate the time\_slot duration array ‘tau’ (here: x\_times)

This time slices depend on the oversampling of the control variables
and the boundary conditions. The differences of the absolute times
give the time steps x\_times.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{absolute\_y\_times}} (\sphinxstyleliteralemphasis{\sphinxupquote{Union}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{np.ndarray}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{list}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} Absolute times of the start / end of each time segment for the raw
optimization parameters.

\end{description}\end{quote}

\end{fulllineitems}

\index{set\_times() (TransferFunction method)@\spxentry{set\_times()}\spxextra{TransferFunction method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:qsim.transfer_function.TransferFunction.set_times}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{set\_times}}}{\emph{self}, \emph{y\_times: \textless{}built\sphinxhyphen{}in function array\textgreater{}}}{{ $\rightarrow$ None}}
Generate the time\_slot duration array ‘tau’ (here: x\_times).

The time slices depend on the oversampling of the control variables
and the boundary conditions. The times are for the intended use cases
only set once.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{y\_times}} (\sphinxstyleliteralemphasis{\sphinxupquote{Union}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{np.ndarray}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{list}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{shape}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{num\_y}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} The time steps / durations of constant optimization variables.
num\_y is the number of time steps for the raw optimization
variables.

\end{description}\end{quote}

\end{fulllineitems}

\index{transfer\_matrix() (TransferFunction property)@\spxentry{transfer\_matrix()}\spxextra{TransferFunction property}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:qsim.transfer_function.TransferFunction.transfer_matrix}}\pysigline{\sphinxbfcode{\sphinxupquote{property }}\sphinxbfcode{\sphinxupquote{transfer\_matrix}}}
If necessary, calculates the transfer matrix. Then returns it.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxstylestrong{T} \textendash{} Transfer matrix (the linearization of the control amplitudes).

\item[{Return type}] \leavevmode
ndarray, shape (num\_u, num\_x, num\_ctrl)

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{exp\_saturation() (in module qsim.transfer\_function)@\spxentry{exp\_saturation()}\spxextra{in module qsim.transfer\_function}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:qsim.transfer_function.exp_saturation}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{exp\_saturation}}}{\emph{\DUrole{n}{t}\DUrole{p}{:} \DUrole{n}{float}}, \emph{\DUrole{n}{t\_rise}\DUrole{p}{:} \DUrole{n}{float}}, \emph{\DUrole{n}{val\_1}\DUrole{p}{:} \DUrole{n}{float}}, \emph{\DUrole{n}{val\_2}\DUrole{p}{:} \DUrole{n}{float}}}{{ $\rightarrow$ int}}
Exponential saturation function.

\end{fulllineitems}



\subsection{qsim.util module}
\label{\detokenize{qsim:module-qsim.util}}\label{\detokenize{qsim:qsim-util-module}}\index{module@\spxentry{module}!qsim.util@\spxentry{qsim.util}}\index{qsim.util@\spxentry{qsim.util}!module@\spxentry{module}}
Utility functions for the optimal control package.


\subsubsection{Functions}
\label{\detokenize{qsim:id48}}\begin{description}
\item[{{\hyperref[\detokenize{qsim:qsim.util.deprecated}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{deprecated()}}}}} decorator}] \leavevmode
Marks functions and methods which are deprecated.

\item[{{\hyperref[\detokenize{qsim:qsim.util.needs_refactoring}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{needs\_refactoring()}}}}} decorator}] \leavevmode
Marks objects which need refactoring.

\item[{{\hyperref[\detokenize{qsim:qsim.util.timeit}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{timeit()}}}}} decorator}] \leavevmode
Measures the run time of a function evaluation.

\item[{{\hyperref[\detokenize{qsim:qsim.util.closest_unitary}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{closest\_unitary()}}}}}}] \leavevmode
Calculates the closest unitary matrix to a square matrix.

\end{description}

\begin{sphinxadmonition}{note}{Notes}

The implementation was inspired by the optimal control package of QuTiP \sphinxcite{qsim:rea134e69e503-1}
(Quantum Toolbox in Python)
\end{sphinxadmonition}
\subsubsection*{References}
\index{closest\_unitary() (in module qsim.util)@\spxentry{closest\_unitary()}\spxextra{in module qsim.util}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:qsim.util.closest_unitary}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{closest\_unitary}}}{\emph{\DUrole{n}{A}}}{}
Closest unitary to given square matrix.

Calculate the unitary matrix U that is closest with respect to the
operator norm distance to the general matrix A.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxstylestrong{U} \textendash{} Closest unitary.

\item[{Return type}] \leavevmode
np.array

\end{description}\end{quote}

\end{fulllineitems}

\index{deprecated() (in module qsim.util)@\spxentry{deprecated()}\spxextra{in module qsim.util}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:qsim.util.deprecated}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{deprecated}}}{\emph{\DUrole{n}{func}}}{}
This is a decorator which can be used to mark functions
as deprecated. It will result in a warning being emitted
when the function is used.

\end{fulllineitems}

\index{needs\_refactoring() (in module qsim.util)@\spxentry{needs\_refactoring()}\spxextra{in module qsim.util}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:qsim.util.needs_refactoring}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{needs\_refactoring}}}{\emph{\DUrole{n}{func}}}{}
This is a decorator which can be used to mark functions
which need to be refactored. It will result in a warning being emitted
when the function is used.

\end{fulllineitems}

\index{timeit() (in module qsim.util)@\spxentry{timeit()}\spxextra{in module qsim.util}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qsim:qsim.util.timeit}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{timeit}}}{\emph{\DUrole{n}{function}}}{}
Convenience function to measure the run time of a function.

This function can be applied as decorator to get a function that evaluates
the input function an measures the run time.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{function}} (\sphinxstyleliteralemphasis{\sphinxupquote{Callable}}) \textendash{} The function of which the run time is measured.

\item[{Returns}] \leavevmode
\sphinxstylestrong{timed} \textendash{} Timed function.

\item[{Return type}] \leavevmode
Callable

\end{description}\end{quote}

\end{fulllineitems}



\subsection{Module contents}
\label{\detokenize{qsim:module-qsim}}\label{\detokenize{qsim:module-contents}}\index{module@\spxentry{module}!qsim@\spxentry{qsim}}\index{qsim@\spxentry{qsim}!module@\spxentry{module}}

\chapter{Indices and tables}
\label{\detokenize{index:indices-and-tables}}\begin{itemize}
\item {} 
\DUrole{xref,std,std-ref}{genindex}

\item {} 
\DUrole{xref,std,std-ref}{modindex}

\item {} 
\DUrole{xref,std,std-ref}{search}

\end{itemize}

\begin{sphinxthebibliography}{R4a6e0c6}
\bibitem[R4a6e0c6bb1f9\sphinxhyphen{}1]{qsim:r4a6e0c6bb1f9-1}
J. R. Johansson, P. D. Nation, and F. Nori: “QuTiP 2: A Python framework
for the dynamics of open quantum systems.”, Comp. Phys. Comm. 184, 1234
(2013) {[}DOI: 10.1016/j.cpc.2012.11.019{]}.
\bibitem[R60048f1bd449\sphinxhyphen{}1]{qsim:r60048f1bd449-1}
J. R. Johansson, P. D. Nation, and F. Nori: “QuTiP 2: A Python framework
for the dynamics of open quantum systems.”, Comp. Phys. Comm. 184, 1234
(2013) {[}DOI: 10.1016/j.cpc.2012.11.019{]}.
\bibitem[R5b9320e02ee3\sphinxhyphen{}1]{qsim:r5b9320e02ee3-1}
J. R. Johansson, P. D. Nation, and F. Nori: “QuTiP 2: A Python framework
for the dynamics of open quantum systems.”, Comp. Phys. Comm. 184, 1234
(2013) {[}DOI: 10.1016/j.cpc.2012.11.019{]}.
\bibitem[R40c5148f82d6\sphinxhyphen{}1]{qsim:r40c5148f82d6-1}
J. R. Johansson, P. D. Nation, and F. Nori: “QuTiP 2: A Python framework
for the dynamics of open quantum systems.”, Comp. Phys. Comm. 184, 1234
(2013) {[}DOI: 10.1016/j.cpc.2012.11.019{]}.
\bibitem[R35617950a937\sphinxhyphen{}1]{qsim:r35617950a937-1}
J. R. Johansson, P. D. Nation, and F. Nori: “QuTiP 2: A Python framework
for the dynamics of open quantum systems.”, Comp. Phys. Comm. 184, 1234
(2013) {[}DOI: 10.1016/j.cpc.2012.11.019{]}.
\bibitem[R8081257120ee\sphinxhyphen{}1]{qsim:r8081257120ee-1}
J. R. Johansson, P. D. Nation, and F. Nori: “QuTiP 2: A Python framework
for the dynamics of open quantum systems.”, Comp. Phys. Comm. 184, 1234
(2013) {[}DOI: 10.1016/j.cpc.2012.11.019{]}.
\bibitem[R2896d74c7423\sphinxhyphen{}1]{qsim:r2896d74c7423-1}
J. R. Johansson, P. D. Nation, and F. Nori: “QuTiP 2: A Python framework
for the dynamics of open quantum systems.”, Comp. Phys. Comm. 184, 1234
(2013) {[}DOI: 10.1016/j.cpc.2012.11.019{]}.
\bibitem[Rf32976d78454\sphinxhyphen{}1]{qsim:rf32976d78454-1}
J. R. Johansson, P. D. Nation, and F. Nori: “QuTiP 2: A Python framework
for the dynamics of open quantum systems.”, Comp. Phys. Comm. 184, 1234
(2013) {[}DOI: 10.1016/j.cpc.2012.11.019{]}.
\bibitem[1]{qsim:reaf67fb149ce-1}
J. R. Johansson, P. D. Nation, and F. Nori: “QuTiP 2: A Python framework
for the dynamics of open quantum systems.”, Comp. Phys. Comm. 184, 1234
(2013) {[}DOI: 10.1016/j.cpc.2012.11.019{]}.
\bibitem[R1b5c14c6e5c3\sphinxhyphen{}1]{qsim:r1b5c14c6e5c3-1}
J. R. Johansson, P. D. Nation, and F. Nori: “QuTiP 2: A Python framework
for the dynamics of open quantum systems.”, Comp. Phys. Comm. 184, 1234
(2013) {[}DOI: 10.1016/j.cpc.2012.11.019{]}.
\bibitem[Rb0fedd4c4e4c\sphinxhyphen{}1]{qsim:rb0fedd4c4e4c-1}
J. R. Johansson, P. D. Nation, and F. Nori: “QuTiP 2: A Python framework
for the dynamics of open quantum systems.”, Comp. Phys. Comm. 184, 1234
(2013) {[}DOI: 10.1016/j.cpc.2012.11.019{]}.
\bibitem[R04aaa0b1dcb4\sphinxhyphen{}1]{qsim:r04aaa0b1dcb4-1}
J. R. Johansson, P. D. Nation, and F. Nori: “QuTiP 2: A Python framework
for the dynamics of open quantum systems.”, Comp. Phys. Comm. 184, 1234
(2013) {[}DOI: 10.1016/j.cpc.2012.11.019{]}.
\bibitem[Rea134e69e503\sphinxhyphen{}1]{qsim:rea134e69e503-1}
J. R. Johansson, P. D. Nation, and F. Nori: “QuTiP 2: A Python framework
for the dynamics of open quantum systems.”, Comp. Phys. Comm. 184, 1234
(2013) {[}DOI: 10.1016/j.cpc.2012.11.019{]}.
\end{sphinxthebibliography}


\renewcommand{\indexname}{Python Module Index}
\begin{sphinxtheindex}
\let\bigletter\sphinxstyleindexlettergroup
\bigletter{q}
\item\relax\sphinxstyleindexentry{qsim}\sphinxstyleindexpageref{qsim:\detokenize{module-qsim}}
\item\relax\sphinxstyleindexentry{qsim.amplitude\_functions}\sphinxstyleindexpageref{qsim:\detokenize{module-qsim.amplitude_functions}}
\item\relax\sphinxstyleindexentry{qsim.analyser}\sphinxstyleindexpageref{qsim:\detokenize{module-qsim.analyser}}
\item\relax\sphinxstyleindexentry{qsim.cost\_functions}\sphinxstyleindexpageref{qsim:\detokenize{module-qsim.cost_functions}}
\item\relax\sphinxstyleindexentry{qsim.data\_container}\sphinxstyleindexpageref{qsim:\detokenize{module-qsim.data_container}}
\item\relax\sphinxstyleindexentry{qsim.energy\_spectrum}\sphinxstyleindexpageref{qsim:\detokenize{module-qsim.energy_spectrum}}
\item\relax\sphinxstyleindexentry{qsim.matrix}\sphinxstyleindexpageref{qsim:\detokenize{module-qsim.matrix}}
\item\relax\sphinxstyleindexentry{qsim.noise}\sphinxstyleindexpageref{qsim:\detokenize{module-qsim.noise}}
\item\relax\sphinxstyleindexentry{qsim.optimization\_data}\sphinxstyleindexpageref{qsim:\detokenize{module-qsim.optimization_data}}
\item\relax\sphinxstyleindexentry{qsim.optimize}\sphinxstyleindexpageref{qsim:\detokenize{module-qsim.optimize}}
\item\relax\sphinxstyleindexentry{qsim.performance\_statistics}\sphinxstyleindexpageref{qsim:\detokenize{module-qsim.performance_statistics}}
\item\relax\sphinxstyleindexentry{qsim.simulator}\sphinxstyleindexpageref{qsim:\detokenize{module-qsim.simulator}}
\item\relax\sphinxstyleindexentry{qsim.solver\_algorithms}\sphinxstyleindexpageref{qsim:\detokenize{module-qsim.solver_algorithms}}
\item\relax\sphinxstyleindexentry{qsim.transfer\_function}\sphinxstyleindexpageref{qsim:\detokenize{module-qsim.transfer_function}}
\item\relax\sphinxstyleindexentry{qsim.util}\sphinxstyleindexpageref{qsim:\detokenize{module-qsim.util}}
\end{sphinxtheindex}

\renewcommand{\indexname}{Index}
\printindex
\end{document}